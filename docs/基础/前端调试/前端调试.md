# 前端调试
以下是主要内容：
1. 用 VSCode Debugger 调试网页的 JS、
2. 用 VSCode Debugger 调试 Node.js、
3. 用 Chrome DevTools 调试网页
4. 调试工具的原理。

可以给调试下个定义：
> 代码在某个平台运行（浏览器、Node.js、Electron、小程序等任何能执行 JS 代码的平台），把运行时的状态（调用栈、执行上下文，或者 DOM 的结构，React 组件的状态等）通过某种方式（一般是通过基于 WebSocket 的调试协议）暴露出来，传递给开发工具做 UI 的展示和交互，辅助开发者排查问题、梳理流程、了解代码运行状态等，这个就是调试。

## 原理
### Chrome DevTools 原理
Chrome DevTools 分为两部分，backend 和 frontend：
- backend 和 Chrome 集成，负责把 Chrome 的网页运行时状态通过调试协议暴露出来。
- frontend 是独立的，负责对接调试协议，做 UI 的展示和交互。

两者之间的调试协议叫做 Chrome DevTools Protocol，简称 CDP。

传输协议数据的方式叫做信道（message channel），有很多种，比如 Chrome DevTools 嵌入在 Chrome 里时，两者通过全局的函数通信；当 Chrome DevTools 远程调试某个目标的代码时，两者通过 WebSocket 通信。

> frontend、backend、调试协议（CDP）、信道，这是 Chrome DevTools 的 4 个组成部分。

![](assets/img/chrome_devtools_principle.png)
[Chrome DevTools原理](./assets/drowio/chrome_devtools_principle.drawio ':include :type=code')

backend 可以是 Chromium，也可以是 Node.js 或者 V8，这些 JS 的运行时都支持 Chrome DevTools Protocol。

这就是 Chrome DevTools 的调试原理。

### VSCode Debugger 原理
和 Chrome DevTools 差不多，也是分为 frontend、backend、调试协议这几部分，只不过它多了一层适配器协议。
![](assets/img/vscode_debugger_principle1.png)
[VSCode Debugger原理](./assets/drowio/VSCodeDebuggerProtocol.drawio ':include :type=code')

为了能直接用 Chrome DevTools 调试 Node.js 代码，Node.js 6 以上就使用 Chrome DevTools Protocol 作为调试协议了，所以 VSCode Debugger 要调试 Node.js 也是通过这个协议。

但是中间多了一层适配器协议 Debug Adapter Protocol，这是为什么呢？
  因为 VSCode 不是 JS 专用编辑器呀，它可能用来调试 Python 代码、Rust 代码等等，自然不能和某一种语言的调试协议深度耦合，所以多了一个适配器层。
![](assets/img/vscode_debugger_principle2.png)
[VSCode Debugger原理](./assets/drowio/VSCodeDebuggerAdapter.drawio.drawio ':include :type=code')

这样 VSCode Debugger 就可以用同一套 UI 和逻辑来调试各种语言的代码，只要对接不同的 Debug Adapter 做协议转换即可。

还有另一个好处，就是别的编辑器也可以用这个 Debug Adapter Protocol 来实现调试，这样就可以直接复用 VSCode 的各种语言的 Debug Adapter 了。

> VSCode Debugger 的 UI 的部分算是 frontend，而调试的目标语言算是 backend 部分，中间也是通过 WebSocket 传递调试协议。

### Vue/React DevTools
以 Chrome 插件（Chrome Extension）的形式存在的，要搞懂它们的原理就得了解 Chrome 插件的机制。

Chrome 插件中可以访问网页的 DOM 的部分叫做 Content Script，随页面启动而生效，可以写一些操作 DOM 的逻辑。还有一部分是后台运行的，叫做 Background，浏览器启动就生效了，生命周期比较长，可以做一些常驻的逻辑。
![](assets/img/content_script.png)
如果是扩展 DevTools 的 Chrome 插件，那还有一部分 DevTools Page，是在 DevTools 里显示的页面：
![](assets/img/devTools_page.png)
- Content Script 部分可以操作 DOM，可以监听 DOM Event。
- Backgroud 部分可以访问 extension api，可以和 Content Script 还有 DevTools Page 通信。
- DevTools Page 部分可以访问 devtools api，可以向当前 window 注入 JS 执行。

Vue DevTools 和 React DevTools 就是基于Chrome插件架构来实现的调试功能。

看 [Vue DevTools 的源码目录](https://github.com/vuejs/devtools/tree/main/packages)会发现，它也是分为 backend 和 frontend 的
![](assets/img/vue_devtools_source_code.png)

那 backend 运行在哪，frontend 运行在哪，两者怎么通信呢？
- DevTools Page 是可以在页面 eval JS 的，那就可以注入 backend 的代码。
- backend 的代码可以拿到 Vue 组件的信息，通过 window message 的方式传递给 Background。
- Background 可以和 DevTools Page 通信，从而实现消息转发。
- DevTools Page 根据拿到的数据，渲染组件的信息，实现交互功能。
![](assets/img/devTools_page_progress.png)
DevTools Page 部分渲染出的界面是这样的：
![](assets/img/vue_devtools_res.png)
React DevTools 也是类似的，都是通过 backend 拿到组件信息，然后传递给 DevTools Page 做渲染和交互。
![](assets/img/react_developer_tools.png)

不过 React DevTools 还有独立的 Electron 应用，可以用于 React Native 的调试。
![](assets/img/react_developer_tools_res.png)
这种自定义调试工具也是用的 Chrome DevTools Protocol 协议么？
明显不是，CDP 协议用来调试 DOM、JS 等挺不错的，但是不好扩展，如果有别的需求，一般都是自定义调试协议。

都有 backend 部分负责拿到运行时的信息，有 frontend 部分负责渲染和交互，也有调试协议用来规定不同数据的格式，还有不同的信道，比如 WebSocket 、Chrome 插件的 background 转发等。

> frontend、backend、调试协议、信道，这是调试工具的四要素。

不过，不同的调试工具都会有不同的设计，比如 VSCode Debugger 为了跨语言复用，多了一层 Debugger Adapter，React DevTools 有独立的 electron 应用，用自定义调试协议，可以调试 React Native 代码。

## 调试网页的JS
以 React 项目为例，用 create-react-app 创建一个 react 项目：
```bash
$ yarn create react-app test-react-debug
```
进入项目目录，执行 `yarn start`。

它会启动一个开发服务，然后浏览器访问 localhost:3000：
![](assets/img/localhost3000.png)
打开 Chrome DevTools，在 Sources 面板找到 src/index.js，打上个断点：
![](assets/img/break_point.png)
然后刷新页面就可以开始调试了：
![](assets/img/break_point_proceeding.png)

代码会在断点处断住，右边会显示当前 local 作用域的变量，global 作用域的变量，还有调用栈 call stack。
![](assets/img/break_point_control.png)

上面有几个控制执行的按钮，分别是：
![](assets/img/resume_script_execution.png)恢复执行

![](assets/img/step_over_next_function_call.png)单步执行

![](assets/img/step_into_next_function_call.png)进入函数调用

![](assets/img/step_out_of_current_function.png)跳出函数调用

![](assets/img/step.png)代码执行下一步

![](assets/img/deactivate_breakpoint.png)让断点失效

![](assets/img/catch_stop.png)在异常处断住

**可以控制代码的执行，可以看到每一步的调用栈和作用域的变量，那理清代码的逻辑，或者排查代码中的问题不就很容易了么？**

其实调试网页的 JS，除了 Chrome DevTools 外，还有一种更好用的调试方式： VSCode Debugger。

用 VSCode 打开项目目录，创建 .vscode/launch.json 文件：

点击右下角的 Add Configuration(添加配置)... 按钮，选择 Chrome: Launch(Chrome: 启动)
![](assets/img/vscode_launch.png)

把访问的 url 改为开发服务器启动的地址：
```json
{
  "configurations": [
    {
      "name": "Launch Chrome",
      "request": "launch",
      "type": "chrome",
      // "url": "http://localhost:8080",
      "url": "http://localhost:3000",
      "webRoot": "${workspaceFolder}"
    }
  ]
}
```
然后进入 Debug 窗口，点击启动：
![](assets/img/vscode_launch_debug.png)
你会发现它启动了浏览器，并打开了这个 url：
![](assets/img/vscode_launch_debug_run.png)

在代码打个断点，然后点击![](assets/img/reboot.png)刷新：
![](assets/img/vscode_debug_break_point.png)

代码会执行到断点处断住，本地和全局作用域的变量，调用栈等都会展示在左边：
![](assets/img/vscode_debug_break_point_run.png)

上面的控制按钮分别对应恢复执行、单步执行、进入函数调用、跳出函数调用，这个和 Chrome DevTools 一样：

还多了刷新和停止的按钮。

那异常断点的按钮呢？
![](assets/img/vscode_debug_break_point_run_error_stop.png)

可以在被 catch 的异常处断住，也可以在没有被 catch 的异常处断住。

看起来和 Chrome DevTools 里调试差不多呀，在 VSCode Debugger 里调试有啥好处么？

好处是不用切换工具呀，之前是调试在 Chrome DevTools，写代码在 VSCode，而现在写代码和调试都可以在 VSCode 里，可以边调试边写代码。

比如我想访问 this 的某个属性，可以在 Debug Console 里输入 this 看下它的值，然后再来写代码：
![](assets/img/vscode_debug_this.png)

如果你用了 TypeScript 可能会有属性名的提示、属性值类型的提示，但并不知道属性的值是啥。

而边调试边写代码，能直接知道属性值是什么，有哪些函数可以调用。

> 边调试边写代码是推荐的写代码方式。

知道了怎么用，再来思考下：为什么 Chrome DevTools 和 VSCode Debugger 都可以调试网页呢？

这是因为调试协议是一样的，都是 CDP。Chrome DevTools 可以对接 CDP 来调试网页，VSCode Debugger 也可以。只不过 VSCode Debugger 会多一层 Debug Adapter Protocol 的转换。
![](assets/img/vscode_and_chrome_debug.png)
这也是为什么两个调试工具的功能大同小异。

### 总结
Chrome DevTools 和 VSCode Debugger 都能调试网页的 JS，可以打断点，单步执行，可以看到本地和全局作用域的变量，还有函数调用栈。

但更推荐使用 VSCode Debugger 来调试，这样写代码和调试都用同一个工具，不用切换，而且还可以边调试边写代码。

这两个原理都是对接了 Chrome DevTools Protocol，用自己的 UI 来做展示和交互。

## VSCode Chrome Debugger配置详解

### launch/attach
创建 Chrome Debug 配置有两种方式：launch 和 attach：

它们只是 request 的配置不同：
```json
{
  "configurations": [
    {
      "name": "Attach to Chrome",
      "port": 9222,
      "request": "attach",
      "type": "chrome",
      "webRoot": "${workspaceFolder}"
    },
    {
      "name": "Launch Chrome",
      "request": "launch",
      "type": "chrome",
      // "url": "http://localhost:8080",
      "url": "http://localhost:3000",
      "webRoot": "${workspaceFolder}"
    }
  ]
}
```
我们知道，调试就是把浏览器跑起来，访问目标网页，这时候会有一个 ws 的调试服务，我们用 frontend 的 ws 客户端连接上这个 ws 服务，就可以进行调试了。

![](assets/img/chrome_devtools_principle.png)

VSCode 的 Debugger 会多一层适配器协议的转换，但是原理差不多。

launch 的意思是把 url 对应的网页跑起来，指定调试端口，然后 frontend 自动 attach 到这个端口。

但如果你已经有一个在调试模式跑的浏览器了，那直接连接上就行，这时候就直接 attach。

比如我们手动把 Chrome 跑起来，指定调试端口 remote-debugging-port 为 9222，指定用户数据保存目录 user-data-dir 为你自己创建一个目录。

在命令行执行下面的命令：
```bash
# macos
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --remote-debugging-port=9222 --user-data-dir=你自己创建的某个目录

# window
# 步骤：
# chrome图标右键属性-找到目标路径-复制目录
# 我的电脑-右键属性-高级系统设置-环境变量-找到变量Path-新建-填入环境变量目录(注意是目录)
# 打开cmd-输入chrome.exe即可打开
chrome --remote-debugging-port=9222 --user-data-dir=D:\test
```

Chrome 跑起来之后，你可以打开几个网页，比如百度、掘金，然后你访问 localhost:9222/json，这时候你就会发现所有的 ws 服务的地址了：
![](assets/img/localhost9222json.png)
为什么每个页面有单独的 ws 服务呢？

这个很正常呀，每个页面的调试都是独立的，自然就需要单独的 ws 服务。

然后你创建一个 attach 的 Chrome Debug 配置：
```json
{
  "configurations": [
    {
      "name": "Attach to Chrome",
      "port": 9222,
      "request": "attach",
      "type": "chrome",
      "webRoot": "${workspaceFolder}"
    }
  ]
}
```
点击启动，就会看到 VSCode Debugger 和每一个页面的 ws 调试服务建立起了链接：
![](assets/img/vscode_debugger_ws_console.png)
比如访问(localhost:3000)之前的 React 项目，就可以进行调试了：
![](assets/img/vscode_debugger_ws_console_localhost3000.png)

可以多个页面一起调试，每个页面都有独立的调试上下文。

### userDataDir
不知道你有没有注意到刚才手动启动 Chrome 的时候，除了指定调试端口 remote-debugging-port 外，还指定了用户数据目录 user-data-dir。

为什么要指定这个呢？

user data dir 是保存用户数据的地方，比如你的浏览记录、cookies、插件、书签、网站的数据等等，在 macOS 下是保存在这个位置：
```bash
~/Library/Application\ Support/Google/Chrome
```
比如你打开 Default/Bookmarks 看一下，是不是都是你保存的书签？
```bash
open ~/Library/Application\ Support/Google/Chrome/Default/Bookmarks
```
![](assets/img/macos_default_bookmarks.png)

**windows**

你还可以删掉 Default/Cookies，之后再访问之前登陆过的网站试一下，是不是都需要登录了？

这就是用户数据目录的作用。

那为什么启动 Chrome 要手动指定这个呢？都用默认的不行么？

用户数据目录有个特点，就是只能被一个 Chrome 实例所访问，如果你之前启动了 Chrome 用了这个默认的 user data dir，那就不能再启动一个 Chrome 实例用它了。

如果用户数据目录已经跑了一个 Chrome 实例，再跑一个候会报这样的错误：

macos
![](assets/img/unable_to_attach_to_browser.png)

windows
![](assets/img/unable_to_attach_to_browser_windows.png)

> 如果指定了位置可以开启多个
![](assets/img/unable_to_attach_to_browser_more.png)

所以用调试模式启动 Chrome 的时候，需要单独指定一下 user data dir 的位置。或者你也把之前的 Chrome 实例关掉，这样才能用默认的。

launch 的配置项里也有 userDataDir 的配置：
![](assets/img/launch_userdatadir.png)

- **默认是 true**，代表创建一个临时目录来保存用户数据。
  - 把 userDataDir 设置为 true 就每次都需要登录了：
- 也可以设置为 false，使用默认 user data dir 启动 chrome。
  - 这样的好处就是登录状态、历史记录啥的都有：

你也可以指定一个自定义的路径，这样用户数据就会保存在那个目录下：
```json
{
  "configurations": [
  {
    "name": "Launch Chrome",
    "request": "launch",
    "type": "chrome",
    "url": "http://localhost:8080",
    "userDataDir": "../../react-debug/test", // 指定
    "webRoot": "${workspaceFolder}"
  }
  ]
}
```
更重要的是，你安装的 React DevTools、Vue DevTools 插件都是在默认用户数据目录的，要是用临时数据目录跑调试，那这些不都没了？

比如你 userDataDir 设置为 true 的时候，React DevTools 插件是没有的，需要再安装：
![](assets/img/no_react_devtools.png)
userDataDir 设置为 false 的时候，安装过的插件都可以直接用：
![](assets/img/userdatadir_false.png)

但是除了调试用之外，平时也会用到 Chrome 呀，同一个 user data dir 只能跑一个 Chrome 实例的话，那不就冲突了？

这个问题可以用下面的配置解决：

### runtimeExecutable
调试网页的 JS，需要先把 Chrome 跑起来，默认跑的是 Google Chrome，其实它还有另外一个版本 Canary：

![](assets/img/google_chrome_canary.png)

这是给开发者用的每日构建版，能够快速体验新特性，但是不稳定。

而 Google Chrome 是给普通用户用的，比较稳定。

这俩是独立的，相互之间没影响，可以都用同一个 user data dir 来启动。

你可以在官网[官网](https://www.google.com/intl/zh-CN/chrome/canary/)把 canary 下载下来。

然后指定 runtimeExecutable 为 canary，使用默认的用户数据目录启动：
```json
{
  "configurations": [
    {
      "name": "Launch Chrome",
      "request": "launch",
      "type": "chrome",
      "runtimeExecutable": "canary",
      "url": "http://localhost:3000",
      "userDataDir": false,
      "webRoot": "${workspaceFolder}"
    }
  ]
}
```
这样你就可以调试用 canary，平时用 chrome 了，两者都有各自的默认数据目录。

> 注意，一定要先安装了 canary，才能指定 canary run

当然，runtimeExecutable 还可以指定用别的浏览器跑：
![](assets/img/runtime_executable_other.png)

- 可以是 stable，也就是稳定的 Google Chrome，
- 或者 canary，也就是每日构建版的 Google Chrome Canary，
- 还可以是 custom，然后用 CHROME_PATH 环境变量指定浏览器的地址。

不过常用的还是 Chrome 和 Canary。

### runtimeArgs

启动 Chrome 的时候，可以指定启动参数，比如每次打开网页都默认调起 Chrome DevTools，就可以加一个 --auto-open-devtools-for-tabs 的启动参数：
```json
{
  "configurations": [
    {
      "name": "Launch Chrome",
      "request": "launch",
      "type": "chrome",
      "runtimeExecutable": "canary",
      "runtimeArgs": ["--auto-open-devtools-for-tabs"],
      "url": "http://localhost:3000",
      "userDataDir": false,
      "webRoot": "${workspaceFolder}"
    }
  ]
}
```
效果就是这样的：
![](assets/img/canary_auto_open_devtools.png)

想要无痕模式启动，也就是不加载插件，没有登录状态，就可以加一个 --incognito 的启动参数：
```json
{
  "configurations": [
    {
      "name": "Launch Chrome",
      "request": "launch",
      "type": "chrome",
      "runtimeExecutable": "canary",
      "runtimeArgs": ["--incognito"],
      "url": "http://localhost:3000",
      "userDataDir": false,
      "webRoot": "${workspaceFolder}"
    }
  ]
}
```
调试用的浏览器就会以无痕模式启动了
![](assets/img/canary_auto_incognito.png)

> 其实设置的 userDataDir 就是指定了 --user-data-dir 的启动参数。

## sourceMapPathOverrides
代码是经过编译打包然后在浏览器运行的，比如这样：
![](assets/img/devtools_sources_bundle.png)

却可以直接调试源码，这是通过 sourcemap 做到的。

调试工具都支持 sourcemap，并且是默认开启的：
![](assets/img/source_mapped_from.png)

当然也可以关掉:
Chrome DevTools 里这么关（macos: command(win: ctrl) + shift + p）：
然后输入sourcemap
![](assets/img/disabled_javascript_sourcemap.png)

VSCode Debugger 这么关：
```json
{
  "configurations": [
    {
      "name": "Launch Chrome",
      "request": "launch",
      "type": "chrome",
      "runtimeExecutable": "canary",
      "url": "http://localhost:3000",
      "webRoot": "${workspaceFolder}",
      "sourceMaps": false, // this
    }
  ]
}
```
这样调试的就是编译后的代码了：

![](assets/img/vscode_debugger_bundle.png)

在开启 sourcemap 的情况下，用 Chrome DevTools 可以看到，源文件的路径是 /static/js/bundle.js
![](assets/img/local3000_static_js_bundle.png)

被 sourcemap 到了 D:\front-end\conosle\react-debug\src\App.js
![](assets/img/d_front-end_console_react-debug_src_app.png)

而在 VSCode 里，这个路径是有对应的文件的，所以就会打开对应文件的编辑器，这样就可以边调试边修改代码。

但有的时候，sourcemap 到的文件路径在本地里找不到，这时候代码就只读了，因为没有地方保存：

![](assets/img/sourcemap_vue_readonly.png)

这种情况就需要对 sourcemap 到的路径再做一次映射：

![](assets/img/sourcemap_path_overrides.png)

通过 sourceMapPathOverrides 这个配置项。

默认有这么三个配置：
```json
{
  "configurations": [
    {
      "name": "Launch Chrome",
      "request": "launch",
      "type": "chrome",
      "runtimeExecutable": "canary",
      "runtimeArgs": ["--incognito"],
      "url": "http://localhost:3000",
      "userDataDir": false,
      "webRoot": "${workspaceFolder}",
      "sourceMapPathOverrides": { // this
        "meteor://💻app/*": "${workspaceFolder}/*",
        "webpack:///./~/*": "${workspaceFolder}/node_modules/*",
        "webpack://?:*/*": "${workspaceFolder}/*"
      }
    }
  ]
}
```
分别是把 meteor、webpack 开头的 path 映射到了本地的目录下。

其中 ?:* 代表匹配任意字符，但不映射，而 * 是用于匹配字符并映射的。

比如最后一个 webpack://?:*/* 到 ${workspaceFolder}/* 的映射，就是把 webpack:// 开头，后面接任意字符 + / 然后是任意字符的路径映射到了本地的项目目录。（workspaceFolder 是一个内置变量，代表项目根目录）

把调试的文件 sourcemap 到的路径映射到本地的文件，这样调试的代码就不再只读了：

### file
除了启动开发服务器然后连上 url 调试之外，也可以直接指定某个文件，VSCode Debugger 会启动静态服务器提供服务：
```json
{
  "configurations": [
    {
      "name": "Launch Chrome",
      "request": "launch",
      "type": "chrome",
      "runtimeExecutable": "canary",
      "userDataDir": false,
      "webRoot": "${workspaceFolder}",
      "file": "${workspaceFolder}/index.html" // 指定某个文件
    }
  ]
}
```
index.html(放在项目根(/)目录下) 的内容如下：
![](assets/img/index_html.png)
打了个断点，然后启动调试：
![](assets/img/vscode_debugger_index_html.png)
这样就可以直接调试静态网页了。

同样，要修改调试的内容需要把 url 映射到本地文件才行，所以有这样一个 pathMapping 的配置：
```json
{
  "configurations": [
    {
      "name": "Launch Chrome",
      "request": "launch",
      "type": "chrome",
      "runtimeExecutable": "canary",
      "runtimeArgs": ["--incognito"],
      "file": "${workspaceFolder}/index.html", // 指定某个文件
      "userDataDir": false,
      "webRoot": "${workspaceFolder}",
      "pathMapping": {
        "/static/js/": "${workspaceFolder}/src/"
      }
    }
  ]
}
```
webRoot 其实就相当于把 / 的 url 映射到了 ${workspaceFolder}/。
这些配置倒是很少用，一般我们还是启动 dev server，再调试某个 url 更多一些。

### 总结
- launch：调试模式启动浏览器，访问某个 url，然后连上进行调试
- attach：连接某个已经在调试模式启动的 url 进行调试
- userDataDir： user data dir 是保存用户数据的地方，比如浏览历史、cookie 等，一个数据目录只能跑一个 chrome，所以默认会创建临时用户数据目录，想用默认的目录可以把这个配置设为 false
- runtimeExecutable：切换调试用的浏览器，可以是 stable、canary 或者自定义的
- runtimeArgs：启动浏览器的时候传递的启动参数
- sourceMapPathOverrides：对 sourcemap 到的文件路径做一次映射，映射到 VSCode - workspace 下的文件，这样调试的文件就可以修改了
- file：可以直接指定某个文件，然后启动调试


## sourcemap的原理和作用
### 什么是 sourcemap
> sourcemap 是关联编译后的代码和源码的，通过一个个行列号的映射。

比如编译后代码的第 3 行第 4 列，对应着源码里的第 8 行第 5 列这种，这叫做一个 mapping。
```js
{
  version : 3,
  file: "out.js",
  sourceRoot : "",
  sources: ["foo.js", "bar.js"],
  names: ["a", "b"],
  mappings: "AAgBC,SAAQ,CAAEA;AAAEA",
  sourcesContent: ['const a = 1; console.log(a)', 'const b = 2; console.log(b)']
}
```
- version：sourcemap 的版本，一般为 3
- file：编译后的文件名
- sourceRoot：源码根目录
- names：转换前的变量名
- sources：源码文件名
- sourcesContent：每个 sources 对应的源码的内容
- mappings：一个个位置映射

为什么 sources 可以有多个呢？

因为可能编译产物是多个源文件合并的，比如打包，一个 bundle.js 就对应了 n 个 sources 源文件。

重点是 mappings 部分：

mappings 部分是通过`分号;` 和`逗号 ,` 分隔的：
```js
mappings:"AAAAA,BBBBB;CCCCC"
```
一个分号就代表一行，这样就免去了行的映射；然后每一行可能有多个位置的映射，用` , `分隔。

那具体的每一个 mapping 都是什么呢？

比如 AAAAA 一共五位，分别有不同的含义：
- 转换后代码的第几列（行数通过分号 ; 来确定）
- 转换前的哪个源码文件，保存在 sources 里的，这里通过下标索引
- 转换前的源码的第几行
- 转换前的源码的第几列
- 转换前的源码的哪个变量名，保存在 names 里的，这里通过下标索引

然后经过编码之后，就成了 AAAAA 这种，这种编码方式叫做 VLQ 编码。

sourcemap 的格式还是很容易理解的，就是一一映射编译后代码的位置和源码的位置。

各种调试工具一般都支持 sourcemap 的解析，只要在文件末尾加上这样一行：
```js
//# sourceMappingURL=/path/to/source.js.map
```
运行时就会关联到源码：
![](assets/img/sourcemap_run.png)

除了调试的时候会使用 sourcemap，线上报错定位源码也需要用到：

开发时会使用 sourcemap 来调试，但是生产可不会，但是线上报错的时候确实也需要定位到源码，这种情况一般都是单独上传 sourcemap 到错误收集平台。

比如 sentry 就提供了一个 [@sentry/webpack-plugin](https://www.npmjs.com/package/@sentry/webpack-plugin) 支持在打包完成后把 sourcemap 自动上传到 sentry 后台，然后把本地 sourcemap 删掉。还提供了 [@sentry/cli](https://www.npmjs.com/package/@sentry/cli) 让用户可以手动上传。

平时我们至少在这两个场景（**开发时调试源码，生产时定位错误的源码位置**）下会用到 sourcemap。

sourcemap 只是位置的映射，可以用在任何代码上，比如 JS、TS、CSS 等，而且 TS 的类型也支持 sourcemap：
```js
// tsconfig.json
{
  "compilerOptions": {
    "outDir": "dist",
    "declaration": true, // 指定了 declaration 会生成 d.ts 的声明文件
    "declarationMap": true // 指定了 declarationMap 来生成 sourcemap：
  },
  "include": ["src/**/*.ts"],
}
```
操作步骤：
1. 安装
```bash
npm init -y
npm i -D typescript @type/typescript
tsc --init #生成tsconfig
```
修改tsconfig.json配置如上,新建文件src/index.ts
```ts
interface Person {
  name: string;
  age: number;
}
const person: Person = {
  name: 'ming',
  age: 11
}
```
运行看结果：
```bash
tsc
```

这样在 VSCode 里我们就可以直接点击某个类型来跳转到源码里对应的地方了。

这也算 sourcemap 应用的另一个场景，用于**生成的类型和源码中定义的关联**。

### sourcemap 的生成
编译工具在生成代码的时候也会生成 sourcemap：
![](assets/img/sourcemap_create.png)

其实 sourcemap 就是由一个个位置的映射组成的，关键就是要知道源码的哪个位置对应到了编译后代码的哪个位置：

通过 [astexplorer.net](https://astexplorer.net/#/gist/19042bfa06784d0e1b2dcb2ecd3559d5/50898c658d8129dbe520cc515af169331082036b) 可以看到，AST 中保留了源码中的位置，这是 parser 在 parse 源码的时候记录的。

![](assets/img/ast_explorer.png)

然后进行 AST 的各种转换之后会打印成目标代码，打印的时候是一行行一列列的拼接字符串，这时候就有了目标代码中的位置。
```js
export function ConditionalExpression(node: Object) {
  this.print(node.test, node);
  this.space();
  this.token("?");
  this.space();
  this.print(node.consequent, node);
  this.space();
  this.token(":");
  this.space();
  this.print(node.alternate, node);
}
```
这两个位置一关联，那不就是一个 mapping 么？

![](assets/img/sourcemap_correlation.png)

这样就生成了 sourcemap。

当然 sourcemap 有对应的格式和编码，自己生成还是挺麻烦的，我们会用 [source-map](https://www.npmjs.com/package/source-map) 这个包：

source-map 可以用于生成和解析 sourcemap，它暴露了 SourceMapConsumer、SourceMapGenerator、SourceNode 3个类，分别用于消费 sourcemap、生成 sourcemap、创建源码节点。

生成 sourcemap 的流程是：
1. 创建一个 SourceMapGenerator 对象
2. 通过 addMapping 方法添加一个映射
3. 通过 toString 转为 sourcemap 字符串

```js
const { SourceMapGenerator } = require('source-map');

const map = new SourceMapGenerator({
    file: "source-mapped.js"
});
  
map.addMapping({
    generated: {
        line: 10,
        column: 35
    },
    source: "foo.js",
    original: {
        line: 33,
        column: 2
    },
    name: "christopher"
});
  
console.log(map.toString());
```
操作：
```bash
npm init -y
npm i -D source-map
```
新建一个`index.js`文件添加上面代码

![](assets/img/source-map_test.png)

消费 sourcemap 用 SourceMapConsumer 的 api。

可以调用 originalPositionFor 和 generatedPositionFor 分别用目标代码位置查源码位置和用源码位置查目标代码位置

还可以通过 eachMapping 遍历所有 mapping，对每个进行处理。

```js
const { SourceMapConsumer } = require('source-map');

const rawSourceMap = {
    version: 3,
    file: "min.js",
    names: ["bar", "baz", "n"],
    sources: ["one.js", "two.js"],
    sourceRoot: "http://example.com/www/js/",
    mappings: "CAAC,IAAI,IAAM,SAAUA,GAClB,OAAOC,IAAID;CCDb,IAAI,IAAM,SAAUE,GAClB,OAAOA"
};

(async function() {
    await SourceMapConsumer.with(rawSourceMap, null, consumer => {
        // 目标代码位置查询源码位置
        consumer.originalPositionFor({
            line: 2,
            column: 28
        })
        // { source: 'http://example.com/www/js/two.js',
        //   line: 2,
        //   column: 10,
        //   name: 'n' }
    
        // 源码位置查询目标代码位置
        consumer.generatedPositionFor({
            source: "http://example.com/www/js/two.js",
            line: 2,
            column: 10
        })
        // { line: 2, column: 28 }
    
        // 遍历 mapping
        consumer.eachMapping(function(m) {
            console.log(m);
        });    
    });
})();
```

在上一个项目添加`index2.js`,代码如上

![](assets/img/source-map_test2.png)

知道了位置从哪里来，知道了怎么用 source-map 的包生成 sourcemap，那就知道了平时我们用的 sourcemap 是怎么来的了。

更详细的介绍可以看 source-map 这个包的[文档](https://www.npmjs.com/package/source-map#consuming-a-source-map)

### 总结
sourcemap，它是通过一个个行列号的映射来关联编译后的代码和源码的。
- 调试的时候会使用 sourcemap，这样可以直接在源码打断点调试。
- 线上报错的时候会使用 sourcemap 来映射到源码，我们会把 sourcemap 单独上传 sentry 等错误收集平台。
- 生成的类型也可以通过 sourcemap 关联到对应的源码中的定义

它的生成可以通过 source-map 包的 api，而 mapping 的位置来源可能是源码 parse 后的 AST 中的位置信息和打印代码时计算出的位置信息的关联。

理解了 sourcemap 的作用，就知道为什么调试离不开 sourcemap 了。

> [JavaScript Source Map 详解 —— 阮一峰](https://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html)

## webpack的sourcemap配置
webpack 对 sourcemap 做了很多封装。

webpack 的 sourcemap 配置是比较麻烦的，比如这两个配置的区别：
- eval-nosources-cheap-module-source-map
- hidden-source-map
是不是分不清楚？你把配置写错的时候，webpack 会提示你一个正则：
![](assets/img/webpack_sourcemap_hint.png)
`^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$`

### eval
eval 的 api 是动态执行 JS 代码的。比如：
```js
eval(`function add(a, b) {
  return a + b;
}
console.log(add(1, 2));`);
// 3
```
有个问题，eval 的代码打不了断点。

浏览器支持了这样一种特性，只要在 eval 代码的最后加上 `//# sourceURL=xxx`，那就会以 xxx 为名字把这段代码加到 sources 里。那不就可以打断点了么？
```js
eval(`function add(a, b) {
  return a + b;
}
console.log(add(1, 2));
//# sourceURL=ming.js`);
// 3
```

**错误操作**
- 打开浏览器控制台，选择Console(控制台)
- 输入上述代码
- 运行后出错的话
  - eval()、Function()等函数会从字符串中“解析”脚本代码，必须在内容安全策略中添加信任字符串来源的脚本的策略指令，该来源的脚本才可以正常运行。
```bash
VM74:1 Uncaught EvalError: Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of script in the following Content Security Policy directive: "script-src 'self' blob: filesystem:".
    at <anonymous>:1:1
```
[参考文章](https://blog.csdn.net/gao_zhennan/article/details/126006827)

**正确操作**
> 需要在无安全策略下才可以执行，即开发环境下
```html
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    console.log(window);
  </script>
</body>
</html>
```
访问localhost:3000，执行以后，会发现 sources 多了`ming.js`的文件：

![](assets/img/eval_sourcemap.png)

它是可以打断点的，比如在 add 里打个断点，然后再切换到console执行 eval。

![](assets/img/eval_sroucemap_breakpoint.png)

除了指定 source 文件外，还可以进一步指定 sourcemap 来映射到源码：
```js
eval(`function add(a, b) {
  return a + b;
}
console.log(add(1, 2));
//# sourceURL=ming.js
//# sourceMappingURL=XXX
`);
// 3
```
这样，动态 eval 的代码也能关联到源码，并且能打断点了！

webpack 就利用了 eval 这个特性来优化的 sourcemap 生成的性能，比如你可以指定 devtool 为 eval：
```js
module.exports = {
  entry: './src/index.js',
  devtool: 'eval', // 特性
  mode: 'development',
  // ...
}
```
生成的代码就是每个模块都被 eval 包裹的，并且有 sourceUrl 来指定文件名：

![](assets/img/webpack_sroucemap_eval.png)

这样有啥好处呢？

快呀，因为只要指定个文件名就行，不用生成 sourcemap。sourcemap 的生成还是很慢的，要一个个 mapping 的处理，做编码之类的。

每个模块的代码都被 eval 包裹，那么执行的时候就会在 sources 里生成对应的文件，这样就可以打断点了：

不过这样只是把每个模块的代码分了出去，并没有做源码的关联，如果相关联源码，可以再开启 sourcemap：
```js
module.exports = {
  entry: './src/index.js',
  devtool: 'eval-source-map', // 特性
  mode: 'development',
  // ...
}
```
你会发现生成的代码也是用 eval 包裹的，但除了 sourceUrl 外，还有 sourceMappingUrl：
```js
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom/client */ \"./node_modules/react-dom/client.js\");\n\n\nfunction Aaa() {\n  debugger;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, \"111\");\n}\nconst container = document.getElementById('root');\nconst root = react_dom_client__WEBPACK_IMPORTED_MODULE_1__.createRoot(container);\nroot.render( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Aaa));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUEwQjtBQUNjO0FBRXhDLFNBQVNFLEdBQUdBLENBQUEsRUFBRztFQUNYO0VBQ0Esb0JBQU9GLDBEQUFBLGNBQUssS0FBUSxDQUFDO0FBQ3pCO0FBRUEsTUFBTUksU0FBUyxHQUFHQyxRQUFRLENBQUNDLGNBQWMsQ0FBQyxNQUFNLENBQUM7QUFFakQsTUFBTUMsSUFBSSxHQUFHTix3REFBbUIsQ0FBQ0csU0FBUyxDQUFDO0FBQzNDRyxJQUFJLENBQUNFLE1BQU0sZUFBQ1QsMERBQW1CLENBQUNFLEdBQUcsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicGFjay10ZXN0Ly4vc3JjL2luZGV4LmpzP2I2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20vY2xpZW50JztcblxuZnVuY3Rpb24gQWFhKCkge1xuICAgIGRlYnVnZ2VyO1xuICAgIHJldHVybiA8ZGl2PjExMTwvZGl2PlxufVxuXG5jb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpO1xuXG5jb25zdCByb290ID0gUmVhY3RET00uY3JlYXRlUm9vdChjb250YWluZXIpO1xucm9vdC5yZW5kZXIoUmVhY3QuY3JlYXRlRWxlbWVudChBYWEpKTsiXSwibmFtZXMiOlsiUmVhY3QiLCJSZWFjdERPTSIsIkFhYSIsImNyZWF0ZUVsZW1lbnQiLCJjb250YWluZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwicm9vdCIsImNyZWF0ZVJvb3QiLCJyZW5kZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n");
```
再运行的时候除了 eval 的代码会生成文件放在 sources 外，还会做 sourcemap 的映射：

![](assets/img/webpack_sroucemap_eval-srouce-map.png)

webpack 的 sourcemap 的配置就利用了浏览器对 eval 代码的调试支持。

所以为什么这个配置项不叫 sourcemap 而叫 devtool 呢？

因为不只是 sourcemap 呀，eval 的方式也行。


### source-map
source-map 的配置是生成独立的 sourcemap 文件：

```js
module.exports = {
  entry: './src/index.js',
  devtool: 'source-map', // 特性
  mode: 'development',
  // ...
}
```