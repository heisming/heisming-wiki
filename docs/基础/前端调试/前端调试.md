# 前端调试
以下是主要内容：
1. 用 VSCode Debugger 调试网页的 JS、
2. 用 VSCode Debugger 调试 Node.js、
3. 用 Chrome DevTools 调试网页
4. 调试工具的原理。

可以给调试下个定义：
> 代码在某个平台运行（浏览器、Node.js、Electron、小程序等任何能执行 JS 代码的平台），把运行时的状态（调用栈、执行上下文，或者 DOM 的结构，React 组件的状态等）通过某种方式（一般是通过基于 WebSocket 的调试协议）暴露出来，传递给开发工具做 UI 的展示和交互，辅助开发者排查问题、梳理流程、了解代码运行状态等，这个就是调试。

## 原理
### Chrome DevTools 原理
Chrome DevTools 分为两部分，backend 和 frontend：
- backend 和 Chrome 集成，负责把 Chrome 的网页运行时状态通过调试协议暴露出来。
- frontend 是独立的，负责对接调试协议，做 UI 的展示和交互。

两者之间的调试协议叫做 Chrome DevTools Protocol，简称 CDP。

传输协议数据的方式叫做信道（message channel），有很多种，比如 Chrome DevTools 嵌入在 Chrome 里时，两者通过全局的函数通信；当 Chrome DevTools 远程调试某个目标的代码时，两者通过 WebSocket 通信。

> frontend、backend、调试协议（CDP）、信道，这是 Chrome DevTools 的 4 个组成部分。

![](assets/img/chrome_devtools_principle.png)
[Chrome DevTools原理](./assets/drowio/chrome_devtools_principle.drawio ':include :type=code')

backend 可以是 Chromium，也可以是 Node.js 或者 V8，这些 JS 的运行时都支持 Chrome DevTools Protocol。

这就是 Chrome DevTools 的调试原理。

### VSCode Debugger 原理
和 Chrome DevTools 差不多，也是分为 frontend、backend、调试协议这几部分，只不过它多了一层适配器协议。
![](assets/img/vscode_debugger_principle1.png)
[VSCode Debugger原理](./assets/drowio/VSCodeDebuggerProtocol.drawio ':include :type=code')

为了能直接用 Chrome DevTools 调试 Node.js 代码，Node.js 6 以上就使用 Chrome DevTools Protocol 作为调试协议了，所以 VSCode Debugger 要调试 Node.js 也是通过这个协议。

但是中间多了一层适配器协议 Debug Adapter Protocol，这是为什么呢？
  因为 VSCode 不是 JS 专用编辑器呀，它可能用来调试 Python 代码、Rust 代码等等，自然不能和某一种语言的调试协议深度耦合，所以多了一个适配器层。
![](assets/img/vscode_debugger_principle2.png)
[VSCode Debugger原理](./assets/drowio/VSCodeDebuggerAdapter.drawio.drawio ':include :type=code')

这样 VSCode Debugger 就可以用同一套 UI 和逻辑来调试各种语言的代码，只要对接不同的 Debug Adapter 做协议转换即可。

还有另一个好处，就是别的编辑器也可以用这个 Debug Adapter Protocol 来实现调试，这样就可以直接复用 VSCode 的各种语言的 Debug Adapter 了。

> VSCode Debugger 的 UI 的部分算是 frontend，而调试的目标语言算是 backend 部分，中间也是通过 WebSocket 传递调试协议。

### Vue/React DevTools
以 Chrome 插件（Chrome Extension）的形式存在的，要搞懂它们的原理就得了解 Chrome 插件的机制。

Chrome 插件中可以访问网页的 DOM 的部分叫做 Content Script，随页面启动而生效，可以写一些操作 DOM 的逻辑。还有一部分是后台运行的，叫做 Background，浏览器启动就生效了，生命周期比较长，可以做一些常驻的逻辑。
![](assets/img/content_script.png)
如果是扩展 DevTools 的 Chrome 插件，那还有一部分 DevTools Page，是在 DevTools 里显示的页面：
![](assets/img/devTools_page.png)
- Content Script 部分可以操作 DOM，可以监听 DOM Event。
- Backgroud 部分可以访问 extension api，可以和 Content Script 还有 DevTools Page 通信。
- DevTools Page 部分可以访问 devtools api，可以向当前 window 注入 JS 执行。

Vue DevTools 和 React DevTools 就是基于Chrome插件架构来实现的调试功能。

看 [Vue DevTools 的源码目录](https://github.com/vuejs/devtools/tree/main/packages)会发现，它也是分为 backend 和 frontend 的
![](assets/img/vue_devtools_source_code.png)

那 backend 运行在哪，frontend 运行在哪，两者怎么通信呢？
- DevTools Page 是可以在页面 eval JS 的，那就可以注入 backend 的代码。
- backend 的代码可以拿到 Vue 组件的信息，通过 window message 的方式传递给 Background。
- Background 可以和 DevTools Page 通信，从而实现消息转发。
- DevTools Page 根据拿到的数据，渲染组件的信息，实现交互功能。
![](assets/img/devTools_page_progress.png)
DevTools Page 部分渲染出的界面是这样的：
![](assets/img/vue_devtools_res.png)
React DevTools 也是类似的，都是通过 backend 拿到组件信息，然后传递给 DevTools Page 做渲染和交互。
![](assets/img/react_developer_tools.png)

不过 React DevTools 还有独立的 Electron 应用，可以用于 React Native 的调试。
![](assets/img/react_developer_tools_res.png)
这种自定义调试工具也是用的 Chrome DevTools Protocol 协议么？
明显不是，CDP 协议用来调试 DOM、JS 等挺不错的，但是不好扩展，如果有别的需求，一般都是自定义调试协议。

都有 backend 部分负责拿到运行时的信息，有 frontend 部分负责渲染和交互，也有调试协议用来规定不同数据的格式，还有不同的信道，比如 WebSocket 、Chrome 插件的 background 转发等。

> frontend、backend、调试协议、信道，这是调试工具的四要素。

不过，不同的调试工具都会有不同的设计，比如 VSCode Debugger 为了跨语言复用，多了一层 Debugger Adapter，React DevTools 有独立的 electron 应用，用自定义调试协议，可以调试 React Native 代码。

## 调试网页的JS
以 React 项目为例，用 create-react-app 创建一个 react 项目：
```bash
$ yarn create react-app test-react-debug
```
进入项目目录，执行 `yarn start`。

它会启动一个开发服务，然后浏览器访问 localhost:3000：
![](assets/img/localhost3000.png)
打开 Chrome DevTools，在 Sources 面板找到 src/index.js，打上个断点：
![](assets/img/break_point.png)
然后刷新页面就可以开始调试了：
![](assets/img/break_point_proceeding.png)

代码会在断点处断住，右边会显示当前 local 作用域的变量，global 作用域的变量，还有调用栈 call stack。
![](assets/img/break_point_control.png)

上面有几个控制执行的按钮，分别是：
![](assets/img/resume_script_execution.png)恢复执行

![](assets/img/step_over_next_function_call.png)单步执行

![](assets/img/step_into_next_function_call.png)进入函数调用

![](assets/img/step_out_of_current_function.png)跳出函数调用

![](assets/img/step.png)代码执行下一步

![](assets/img/deactivate_breakpoint.png)让断点失效

![](assets/img/catch_stop.png)在异常处断住

**可以控制代码的执行，可以看到每一步的调用栈和作用域的变量，那理清代码的逻辑，或者排查代码中的问题不就很容易了么？**

其实调试网页的 JS，除了 Chrome DevTools 外，还有一种更好用的调试方式： VSCode Debugger。

用 VSCode 打开项目目录，创建 .vscode/launch.json 文件：

点击右下角的 Add Configuration(添加配置)... 按钮，选择 Chrome: Launch(Chrome: 启动)
![](assets/img/vscode_launch.png)

把访问的 url 改为开发服务器启动的地址：
```json
{
  "configurations": [
    {
      "name": "Launch Chrome",
      "request": "launch",
      "type": "chrome",
      // "url": "http://localhost:8080",
      "url": "http://localhost:3000",
      "webRoot": "${workspaceFolder}"
    }
  ]
}
```
然后进入 Debug 窗口，点击启动：
![](assets/img/vscode_launch_debug.png)
你会发现它启动了浏览器，并打开了这个 url：
![](assets/img/vscode_launch_debug_run.png)

在代码打个断点，然后点击![](assets/img/reboot.png)刷新：
![](assets/img/vscode_debug_break_point.png)

代码会执行到断点处断住，本地和全局作用域的变量，调用栈等都会展示在左边：
![](assets/img/vscode_debug_break_point_run.png)

上面的控制按钮分别对应恢复执行、单步执行、进入函数调用、跳出函数调用，这个和 Chrome DevTools 一样：

还多了刷新和停止的按钮。

那异常断点的按钮呢？
![](assets/img/vscode_debug_break_point_run_error_stop.png)

可以在被 catch 的异常处断住，也可以在没有被 catch 的异常处断住。

看起来和 Chrome DevTools 里调试差不多呀，在 VSCode Debugger 里调试有啥好处么？

好处是不用切换工具呀，之前是调试在 Chrome DevTools，写代码在 VSCode，而现在写代码和调试都可以在 VSCode 里，可以边调试边写代码。

比如我想访问 this 的某个属性，可以在 Debug Console 里输入 this 看下它的值，然后再来写代码：
![](assets/img/vscode_debug_this.png)

如果你用了 TypeScript 可能会有属性名的提示、属性值类型的提示，但并不知道属性的值是啥。

而边调试边写代码，能直接知道属性值是什么，有哪些函数可以调用。

> 边调试边写代码是推荐的写代码方式。

知道了怎么用，再来思考下：为什么 Chrome DevTools 和 VSCode Debugger 都可以调试网页呢？

这是因为调试协议是一样的，都是 CDP。Chrome DevTools 可以对接 CDP 来调试网页，VSCode Debugger 也可以。只不过 VSCode Debugger 会多一层 Debug Adapter Protocol 的转换。
![](assets/img/vscode_and_chrome_debug.png)
这也是为什么两个调试工具的功能大同小异。

#### 总结
Chrome DevTools 和 VSCode Debugger 都能调试网页的 JS，可以打断点，单步执行，可以看到本地和全局作用域的变量，还有函数调用栈。

但更推荐使用 VSCode Debugger 来调试，这样写代码和调试都用同一个工具，不用切换，而且还可以边调试边写代码。

这俩原理都是对接了 Chrome DevTools Protocol，用自己的 UI 来做展示和交互。