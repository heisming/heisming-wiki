# 网络和通讯-登录方案

## 1、session

![](D:\front-end\study\MarkDown\网络与通讯\img\session.png)

```js
const router = require('koa-router')()
const { register, login } = require('../controller/user')
const { SuccessModel, ErrorModel } = require('../res-modul/index')

router.prefix('/api/user')

// 登录
router.post('/login', async function(ctx, next){
  const { username, password } = ctx.request.body
  // 调用数据库，新建用户
  const res = await login(username, password)
  if (res) {
    // 登录成功,保存到session中
    ctx.session.userInfo = { username }
    
    ctx.body = new SuccessModel()
  } else {
    // 登录失败
    ctx.body = new ErrorModel(-999, '登录验证失败')
  }
})

module.exports = router
```

/middleware/loginCheck.js

```js
/**
 * @description 登录验证中间件
 * @author heisming
 */
const { ErrorModel } = require('../res-modul/index')

module.exports = async (ctx, next) => {
  const session = ctx.session
  if (session && session.userInfo) {
    await next()
    return
  }
  ctx.body = new ErrorModel(-100, '登录验证失败')
}
```



使用校验中间件order.js

```js
/**
 * @description 订单操作
 * @author heisming
 */
 const router = require('koa-router')()
 const loginCheck = require('../middleware/loginCheck')
 const { createOrder, queryOrderList} = require('../controller/order')
 const { SuccessModel, ErrorModel } = require('../res-modul/index')
 
 router.prefix('/api/user/order')
 
 // 创建订单逻辑
 router.post('/', loginCheck, async function(ctx, next) {
    const newOrderData = ctx.request.body
    const userInfo = ctx.session.userInfo
    try {
      const newOrder = await createOrder(userInfo.username, newOrderData)
      ctx.body = new SuccessModel(newOrder)
    } catch (error) {
      console.error(error)
      ctx.body = new ErrorModel(-555, '创建订单失败，请重试！')
    }
 })

 // 查询某个用户下的订单
 router.get('/', loginCheck, async function(ctx, next) {
   const userInfo = ctx.session.userInfo
   const orderList = await queryOrderList(userInfo.username)
   ctx.body = new SuccessModel(orderList)
 })
 
 module.exports = router
```



### font-end

```js
const instance = axios.create({
  // baseURL: 'https://www.fastmock.site/mock/bd313a49d28178805e59403af06d1c82/jingdong',
  baseURL: 'http://localhost:3000',
  withCredentials: true, // 允许跨域
  timeout: 5000
})
```





## 2、jwt

### 2.1、Token

Token 本质是字符串，用于请求时附带在请求头中，校验请求是否合法及判断用户身份

#### 2.2、Token 与 Session、Cookie 的区别

- Session 保存在**服务端**，用于客户端与服务端连接时，**临时**保存用户信息，当用户释放连接后，Session 将被释放；
- Cookie 保存在**客户端**，当客户端发起请求时，Cookie 会附带在 `http header` 中，提供给服务端辨识用户身份；
- Token 请求时提供，用于**校验用户是否具备访问接口的权限**。



#### 2.3、Token 的用途

Token 的用途主要有三点：

- 拦截无效请求，降低服务器处理压力；
- 实现第三方 `API` 授权，无需每次都输入用户名密码鉴权；
- 身份校验，防止 `CSRF` 攻击。



### 2.2、JWT 简析

`JSON Web Token（JWT）`是非常流行的跨域身份验证解决方案。

![](https://www.youbaobao.xyz/admin-docs/assets/img/jwt.2b8365ae.png)



#### JWT 构成

下面是一串 `JWT` 字符串：

```sh
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.EJzdDeNLOQhy-2WmXuK1B49xF17Tk0pja1tCPp81YjY
```

它将被解析为以下三部分：



##### HEADER: ALGORITHM & TOKEN TYPE

`JWT` 头部分是一个描述 `JWT` 元数据的 `JSON` 对象：

- `alg`：表示加密算法，`HS256` 是 `HMAC SHA256` 的缩写
- `typ`：token 类型

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```



##### PAYLOAD: DATA

`JWT` 数据部分，payload 是 `JWT` 的主体内容部分，也是一个 `JSON` 字符串，包含需要传递的数据，注意 payload 部分**不要存储隐私数据**，防止信息泄露

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```



#### VERIFY SIGNATURE

- `JWT` 签名部分是对上面两部分数据加密后生成的字符串，通过 `header-alg` 指定的算法生成加密字符串，以确保数据不会被篡改。
- 生成签名时需要使用密钥（即下方示例中的 `abcdefg`），密钥只保存在服务端，不能向用户公开，它是一个字符串，我们可以自由指定。

- 生成签名时需要根据 header 中指定的签名算法，并根据下方的公式，即将 header 和 payload 的数据通过 `base64`加密后用 `.` 进行连接，然后通过密钥进行 

`SHA256` 加密，由于加入了密钥，所以生成的字符串将无法被破译和篡改，只有在**服务端**才能还原

```js
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  abcdefg
)
```

我们可以在 https://jwt.io/ 调试 `JWT `字符串



### 2.3、Demo

> https://jwchan.cn/_posts/backend/node/koa_token.html

#### node

```sh
npm i --save jsonwebtoken
```

```js
module.exports = {
   // jwt的密钥
   PRIVATE_KEY: 'HEISMING',
   // 有效小时，保密性要求高的业务可以设置为 1-2 小时：
   JWT_EXPIRED: 60 * 60 * 5
}
```

```js
const router = require('koa-router')()
// 引入jwt
const jwt = require('jsonwebtoken')
const { PRIVATE_KEY, JWT_EXPIRED, CODE_ERROR } = require('../../utils/constant')
const { login } = require('../../controller/user')
const { SuccessModel, ErrorModel } = require('../../res-modul/index')
// const { md5 } = require('../../utils/jwt')

router.prefix('/user/login')

router.post('/', async function(ctx, next) {
  let { username, password } = ctx.request.body
  // 数据库密码存储先不做MD5加密
  // password = md5(`${password}${PWD_SALT}`)

  // 为什么login().then的写法就没法返回数据? 404
  const user = await login(username, password)
  console.log('user=>', user)

  if(!user || user.length === 0) {
    ctx.body = new ErrorModel(CODE_ERROR, '登录失败,请检查用户名或密码')
  } else {
    // 生成token
    const token = jwt.sign(
      { username },
      PRIVATE_KEY,
      { expiresIn: JWT_EXPIRED }
    )
    ctx.body = new SuccessModel({ token })
  }

})

module.exports = router
```

`app.js`

```js
const Koa = require('koa')
const app = new Koa()

const koajwt = require('koa-jwt')
const { PRIVATE_KEY } = require('./utils/constant')
const { Result } = require('./res-modul')

// 处理token失效
app.use(function (ctx, next) {
  return next().catch((err) => {
    if (err.status === 401) {
      ctx.status = 401;
      new Result('token失效，请重新登录').jwtError(ctx)
    } else {
      const msg = (err && err.message || '系统错误')
      new Result(msg).fail(ctx)
    }
  });
});

// jwt
app.use(koajwt({
  secret: PRIVATE_KEY,
}).unless({ // 白名单
  custom : ctx => {
    if(jwtUnless.checkIsNonTokenApi(ctx)){
      return true
    } else {
      return false
    }
  }
}))

module.exports = app
```

`jwt_unless.js`

```js
/**
 * @description 用于判断客户端当前请求接口是否需要jwt验证
 * @author HEISMING
 */

// 定义不需要jwt验证的接口数组
const nonTokenApiArr = ['/', '/user/login']

// 定义不需要jwt验证的接口正则数组
const nonTokenApiRegArr = [
  /^\/news\/front\/\w/
]

// 判断请求api是否在数组里
const isNonTokenApi = path => {
  return nonTokenApiArr.includes(path)
}

// 判断请求api是否在正则数组里
const isNonTokenRegApi = path => {
  return nonTokenApiRegArr.some(p => {
    return (typeof p === 'string' && p === path) ||
    (p instanceof RegExp && p.exec(path))
  })
}

// 判断当前请求api是否不需要jwt验证
const checkIsNonTokenApi = ctx => {
  if((isNonTokenApi(ctx.path) || isNonTokenRegApi(ctx.path)) && ctx.method == 'GET'){
    return true
  }else{
    //特殊post接口，不需要验证jwt
    if(ctx.path == '/user/login' || ctx.path == 'user/register'){
        return true
    }
    return false
  }
}

module.exports = {
  nonTokenApiArr,
  nonTokenApiRegArr,
  isNonTokenApi,
  isNonTokenRegApi,
  checkIsNonTokenApi
}
```

`Result.js`

```js
const {
  CODE_ERROR, CODE_SUCCESS, CODE_TOKEN_EXPIRED
} = require('../utils/constant')

class Result {
  constructor(data, msg = "操作成功", options){
    this.data = null
    if(arguments.length === 0) {
      this.msg = '操作成功'
    } else if (arguments.length === 1) {
      this.msg = data
    } else {
      this.data = data 
      this.msg = msg
      if (options) {
        this.options = options
      }
    }
  }
  
  createResult() {
    if(!this.errno) {
      this.errno = CODE_SUCCESS
    }
    let base = {
      errno: this.errno,
      msg: this.msg
    }
    if(this.options) {
      base = { ...base, ...this.options}
    }
    return base
  }

  toJson(ctx) {
    ctx.body = this.createResult()
  }

  // 成功
  success() {
    this.errno = CODE_SUCCESS
    this.toJson(ctx)
  }
  // 失败
  fail() {
    this.errno = CODE_ERROR
    this.toJson(ctx)

  }
  // 鉴权错误
  jwtError(ctx) {
    this.errno = CODE_TOKEN_EXPIRED
    this.toJson(ctx)
  }

}

module.exports = Result
```

/utils/constant.js

```js
module.exports = {
   // 是否开启debug
   debug: true,
   // 是否开启开发模式
   dev: true,
   // jwt的密钥
   PRIVATE_KEY: 'HEISMING',
   // 有效秒数，保密性要求高的业务可以设置为 1-2 小时：
   JWT_EXPIRED: 60 * 60,
   // 失败错误码
   CODE_ERROR: -1,
   // 成功错误码
   CODE_SUCCESS: 0,
   // token失效错误码
   CODE_TOKEN_EXPIRED: -999
}
```



#### front-end

1、可以存在store中，做路由拦截，没有就直接退出登录

2、可以存在cookie中，做接口权限校验，token失效就不能访问

```js
import axios from 'axios'
import { message, Modal } from 'antd'
const { confirm } = Modal

import { getToken, removeToken } from './auth'

const dev = true

const services = axios.create({
  baseURL: dev ? 'http://localhost:3001/' : 'http://www.whpallet.com:3001/',
  withCredentials: true, // 允许跨域
  timeout: 5000
})

// 请求的拦截器
services.interceptors.request.use(
  config => {
    if(getToken()) {
      // 请求的时候带上token
      config.headers['Authorization'] = `Bearer ${getToken()}`
    }
    return config
  },
  err => {
    return Promise.reject(err)
  }
)

// 响应拦截器
services.interceptors.response.use(
  response => {
    const res = response.data
    console.log(res);
    // 失败的场景
    if(res.errno !== 0) {
      message.error(res.message || '请求失败')
    
      // 判断 token 失效的场景
      if(res.errno === -999) {
        confirm({
          title: '',
          content: 'Token 失效，请重新登录',
          onOk() {
            // to login page
            
          },
          onCancel() {}
        })
      }
      return Promise.reject(new Error(res.message || '请求失败'))
    } else {
      return response
    }
  },
  err => {
    console.log('res.err', {err});
    const { msg, errno } = err.response.data
    if(errno === -999) {
      // rest token
      removeToken()
      confirm({
        title: '',
        content: 'Token 失效，请重新登录',
        onOk() {
          // to login page

        },
        onCancel() {}
      })
      
    }
    return err
  }
)

// get
export const get = (url: string, params ={}) => {
   return new Promise((resolve, reject) => {
      services.get(url, { params }).then(response => {
        resolve(response.data)
      }),
      err => {
        reject(err)
      }
   })
}

// post
export const post = (url: string, data = {}) => {
  return new Promise((resolve, reject) => {
    services.post(url, data, {
      headers: {
        'Content-Type': 'application/json'
      }
    }).then(response => {
      resolve(response.data)
    }), err => {
      reject(err)
    }
  })
}

// export const patch = (url, data = {}) => {
//   return new Promise((resolve, reject) => {
//     services.patch(url, data, {
//       headers: {
//         'Content-Type': 'application/json'
//       }
//     }).then(response => {
//       resolve(response.data)
//     }, err => {
//       reject(err)
//     })
//   })
// }

export default services
```









## 3、两者的区别