# 函数👍👍👍👍👍

## 函数的定义与调用
### 函数的定义
#### 函数声明
```js
// 函数声明式
function sum(num1, num2) {
   return num1 + num2;
}
```

#### 函数表达式
```js
// 函数表达式
var sum = function (num1, num2) {
   return num1 + num2;
};
```
这个函数表达式没有名称，属于匿名函数表达式。
使用函数声明和匿名函数表达式定义的函数，在进行函数调用时，都只需要使用函数名，传入对应的实际参数（后文简称为实参）即可，示例如下。
```js
console.log(sum(1, 3)); // 4
```
需要注意的是，函数表达式也可以定义具有名称的函数，函数名称即跟在function关键字后的值。
```js
// 具有函数名的函数表达式
var sum = function foo(num1, num2) {
   return num1 + num2;
};
```
其中foo是函数名称，它实际是**函数内部的一个局部变量，在函数外部是无法直接调用**的，示例如下。
```js
console.log(foo(1, 3)); // ReferenceError: foo is not defined
```

#### Function()构造函数
使用new操作符，调用Function构造函数，传入对应的参数，也可以定义一个函数。
```js
// 其中的参数，除了最后一个参数是执行的函数体，其他参数都是函数的形参。
var add = new Function("a", "b", "return a + b");
```

> 相比于函数声明和函数表达式这两种方式，Function()构造函数的使用比较少，主要有以下两个原因。
> - 第一个原因是Function()构造函数每次执行时，都会解析函数主体，并创建一个新的函数对象，所以当在一个循环或者频繁执行的函数中调用Function()构造函数时，效率是非常低的。
> - 第二个原因是使用Function()构造函数创建的函数，并不遵循典型的作用域，它将一直**作为顶级函数执行**。所以在一个函数A内部调用Function()构造函数时，其中的函数体并**不能访问到函数A中的局部变量，而只能访问到全局变量**。

```js
var y = 'global'; // 全局变量
function constructFunction() {
  var y = 'local'; // 局部变量
  return new Function('return y'); // 无法获取局部变量的值
}
console.log(constructFunction()()); // global
```

#### 函数表达式的应用场景
##### 函数递归
通过函数表达式可以定义具有名称的函数，它作为函数内部的一个局部变量，指向函数自身，我们可以利用这一点很好实现递归的功能。
```js
// 斐波那契数列问题
// 通过函数声明实现
function fibonacci(num) {
  if (num === 1 || number === 2) {
    return 1;
  }
  return fibonacci(num - 2) + fibonacci(number - 1);
}
// 通过函数表达式实现
var fibonacci = function(num) {
  if (num === 1 || number === 2) {
    return 1;
  }
  return fibonacci(num - 2) + fibonacci(number - 1);
}
```

##### 代码模块化
在ES6以前，JavaScript中是没有**块级作用域**的，但是我们可以通过函数表达式来间接地实现模块化，将特定的模块代码封装在一个函数中，只对外暴露接口，使用者也不用关心具体细节，这样做可以很好地避免全局环境的污染。
```js
// 立即执行的匿名函数表达式
var person = (function() {
  var _name = "";
  return {
    getName: function() {
      return _name;
    },
    setName: function(newName) {
      _name = newName;
    }
  };
}());
person.setName('ming');
person.getName();
```
返回的是一个对象，只需要调用getName()函数和setName()函数，而不用关心person私有的_name属性。

#### 函数声明与函数表达式的区别
> JavaScript解释器在处理两者时却不一样

##### 函数名称
- 在使用函数声明时，是必须设置函数名称的，这个函数名称**相当于一个变量**，以后函数的调用也会通过这个变量进行。

- 而对于函数表达式来说，**函数名称是可选的**，我们可以定义一个匿名函数表达式，并赋给一个变量，然后通过这个变量进行函数的调用。

```js
// 函数声明，函数名称sum必须设置
function sum(num1, num2) {
  return num1 + num2;
}
// 没有函数名称的匿名函数表达式
var sum = function(num1, num2) {
  return num1 + num2;
}
// 具名函数名的函数表达式，其中foo为函数名称
var sum = function foo(num1, num2) {
  return num1 + num2;
}
```
##### 函数提升
- 对于**函数声明，存在函数提升**，所以即使函数的调用在函数的声明之前，仍然可以正常执行。
- 对于**函数表达式，不存在函数提升**，所以在函数定义之前，不能对其进行调用，否则会抛出异常。
```js
console.log(add(1, 2)); // 3
console.log(sub(5, 3)); // Uncaught TypeError: sub is not a function
// 函数声明
function add(a1, a2) {
  return a1 + a2;
}
// 函数表达式
var sub = function(a1, a2) {
  return a1 - a2;
}
``` 

### 函数的调用
#### 函数调用模式
函数调用模式是通过函数声明或者函数表达式的方式定义函数，然后直接通过函数名调用的模式。
```js
// 函数声明
function add(a1, a2) {
  return a1 + a2;
}
// 函数表达式
var sub = function(a1, a2) {
  return a1 - a2;
}
add(1, 3);
sub(4, 1);
```

#### 方法调用模式👍
方法调用模式会优先定义一个对象obj，然后在对象内部定义值为函数的属性property，通过对象obj.property()来进行函数的调用。
```js
// 定义对象
var obj = {
  name: 'ming',
  // 定义getName属性，值为一个函数
  getName: function() {
    return this.name;
  }
}
obj.getName(); // 通过对象进行调用
obj['getName'](); // 函数还可以通过中括号来调用，即对象名['函数名']。
```
**如果在某个方法中返回的是函数对象本身this**，那么可以利用链式调用原理进行连续的函数调用。
```js
var obj2 = {
  name: 'ming',
  getName: function() {
    console.log(this.name);
  },
  setName: function(name) {
    this.name = name;
    return this; // 在函数内部返回函数对象本身
  }
};
obj2.setName('ming').getName(); // 链式函数调用
```
#### 构造器调用模式
构造器调用模式会定义一个函数，在函数中定义实例属性，在原型上定义函数，然后通过new操作符生成函数的实例，再通过实例调用原型上定义的函数。
```js
// 定义函数对象
function Person(name) {
  this.name = name;
}
// 原型上定义函数
Person.prototype.getName = function() {
  return this.name;
}
// 通过new操作符生成实例
var p = new Person('ming');
// 通过实例进行函数的调用
p.getName();
```
#### call()函数、apply()函数调用模式👍👍👍
通过call()函数或者apply()函数可以**改变函数执行的主体**，使得某些不具有特定函数的对象可以直接调用该特定函数。
```js
function sum(num1, num2) {
  return num1 + num2;
}
var person = {};
// 通过call函数与apply函数调用sum
sum.call(person, 1, 2);
sum.apply(person, [2, 3]);
```
通过call()函数与apply()函数，使得没有sum()函数的person对象也可以直接调用sum()函数

#### 匿名函数调用模式
一种是通过函数表达式定义函数，并赋给变量，通过变量进行调用。
```js
// 通过函数表达式定义匿名函数，并赋给变量sum
var sum = function(num1, num2) {
  return num1 + num2;
}
// 通过sum函数进行匿名函数调用
sum(1, 2);
```
另一种是使用小括号()将匿名函数括起来，然后在后面使用小括号()，传递对应的参数，进行调用。
```js
(function (num1, num2) {
  return num1 + num2;
})(1, 2);
```
使用小括号括住的函数声明实际上是一个函数表达式，紧随其后的小括号表示会立即调用这个函数。
```js
function (num1, num2) {
  return num1 + num2;
}(1, 2); // Uncaught SyntaxError: Unexpected token (
```
因为JavaScript解释器在解析语句时，会将function关键字当作函数声明的开始，函数的声明是需要有函数名称的，而上面的代码却并没有函数名称，所以会抛出语法异常。
```js
// 写上呢
function sum(num1, num2) {
  console.log(num1 + num2);
}(1, 2); // 2
```
实际上，在函数声明后增加的小括号相当于一个分组操作符，两部分内容是完全独立的，并不会起到立即执行的作用，与下列语句等价。
```js
// 函数声明
function sum(num1, num2) {
   console.log(num1 + num2);
}
// (逗号)表达式
(1, 2); // 2
```
如何才可以呢？
```js
var sum = function(num1, num2) {
  return num1 + num2;
}(1, 2);
console.log(sum); // 3
// 这部分表示的是函数立即执行。
function(num1, num2) {
  return num1 + num2;
}(1, 2);
```
```js
// 实名立即调用函数
(function sum(num1, num2) {
   console.log(num1 + num2);
}(1, 2));
```

### 自执行函数
> 自执行函数即函数定义和函数调用的行为先后连续产生。
它需要以一个函数表达式的身份进行函数调用，
匿名函数调用也属于自执行函数的一种。
```js
function (x) {
  alert(x);
}(5); // Uncaught SyntaxError: Unexpected token (

var aa = function(x) {
  console.log(x);
}(1); // 1

true && function (x) {
  console.log(x);
}(2); // 2

0, function(x) {
  console.log(x);
}(3); // 3

!function(x) {
  console.log(x);
}(4); // 4

~function(x) {
  console.log(x);
}(5); // 5

-function(x) {
  console.log(x);
}(6); // 6

+function(x) {
  console.log(x);
}(7); // 7

new function() {
  console.log(8); // 8
};

new function(x) {
  console.log(x); 
}(9); // 9
```

## 函数参数
### 形参和实参
- 形参全称为形式参数，是在定义函数名称与函数体时使用的参数，目的是用来接收调用该函数时传入的参数。
- 实参全称为实际参数，是在调用时传递给函数的参数，实参可以是常量、变量、表达式、函数等类型。

#### 区别
1. 形参出现在函数的定义中，只能在函数体内使用，一旦离开该函数则不能使用；实参出现在主调函数中，进入被调函数后，实参也将不能被访问。
```js
function fn1() {
  var param = 'hello';
  fn2(param);
  console.log(arg); // 在主调函数中不能访问到形参arg，会抛出异常
}
function fn2(arg) {
  console.log(arg); // 在函数体内能访问到形参arg，输出'hello'
  console.log(params); // 在函数体内不能访问到实参param, 会抛出异常。
}
fn1();
```

2. 在**强类型语言**中，定义的形参和实参在数量、数据类型和顺序上要保持严格一致，否则会抛出“类型不匹配”的异常
3. 在函数调用过程中，数据传输是单向的，即只能把实参的值传递给形参，而不能把形参的值反向传递给实参。因此在函数执行时，形参的值可能会发生变化，但不会影响到实参中的值。
```js
var arg = 1;
function fn(param) {
  param = 2;
}
fn(arg);
console.log(arg); // 1，实参的值不变
```
4. 当实参是基本数据类型的值时，实际是将实参的值复制一份传递给形参，在函数运行结束时形参被释放，而实参中的值不会变化。当实参是引用类型的值时，实际是将实参的内存地址传递给形参，即实参和形参都指向相同的内存地址，此时形参可以修改实参的值，但是不能修改实参的内存地址。🚩
```js
var arg = { name: 'ming' };
function fn(param) {
  param.name = 'heisming'; // 改变实参的值
  param = {}; // 改变形参的地址
}
fn(arg);
console.log(arg); // { name: 'heisming' }
```
JavaScript是一门弱类型的语言，函数参数在遵循上述规则的基础上，还具有以下几个特性。
- 函数可以不用定义形参，可以在函数体中通过arguments对象获取传递的实参并进行处理。
- 在函数定义了形参的情况下，传递的实参与形参的个数并不需要相同，实参与形参会从前到后匹配，未匹配到的形参被当作undefined处理。
- 实参并不需要与形参的数据类型一致，因为形参的数据类型只有在执行期间才能确定，并且还存在隐式数据类型的转换。

### arguments对象的实质
> arguments对象是所有函数都具有的一个内置局部变量，表示的是函数实际接收的参数，是一个类数组结构(因为它除了具有length属性外，不具有数组的一些常用方法。)。
#### 函数外部无法访问
arguments对象存在于函数级作用域中，一个函数无法直接获取另一个函数的arguments对象。
```js
console.log(type arguments); // undefined
function foo() {
  console.log(arguments.length); // 3
  function foo2() {
    console.log(arguments.length); // 0
  }   
  foo2();
}
foo(1, 2, 3);
```
#### 可通过索引访问
arguments对象是一个类数组结构，可以通过索引访问，每一项表示对应传递的实参值，如果该项索引值不存在，则会返回“undefined”。
```js
function sum(num1, num2) {
   console.log(arguments[0]);  // 3
   console.log(arguments[1]);  // 4
   console.log(arguments[2]);  // undefined
}
sum(3, 4);
```
#### 由实参决定
> arguments对象的值由实参决定，而不是由定义的形参决定，形参与arguments对象占用独立的内存空间。

arguments对象与形参之间的关系，可以总结为以下几点。
- arguments对象的length属性在函数调用的时候就已经确定，不会随着函数的处理而改变。
- 指定的形参在传递实参的情况下，arguments对象与形参值相同，并且可以相互改变。
- 指定的形参在未传递实参的情况下，arguments对象对应索引值返回“undefined”。
- 指定的形参在未传递实参的情况下，arguments对象与形参值不能相互改变。
```js
function foo(a, b, c) {
  console.log(arguments.length); // 2
  arguments[0] = 11;
  console.log(a); // 1
  b = 12;
  console.log(arguments[1]); // 12
  arguments[2] = 3;
  console.log(c); // undefined
  c = 13;
  console.log(arguments[2]); // 3
  console.log(arguments.length); // 2
}
foo(1, 2);
```
#### 特殊的arguments.callee属性👍👍👍👍👍
表示的是当前正在执行的函数，在比较时是严格相等的。
```js
function foo() {
  console.log(arguments.callee === foo); // true
}
foo();
```
通过arguments.callee属性获取到函数对象后，可以直接传递参数重新进行函数的调用，这个属性在匿名的递归函数中非常有用。
```js
function create() {
  return function(n) {
    if (n <= 1) {
      return 1;
    }
    return n * arguments.callee(n - 1);
  }
}
var result = create()(5); // return 120 (5 * 4 * 3 * 2 * 1)
```
不推荐广泛使用arguments.callee属性，其中有一个主要原因是使用arguments.callee属性后会改变函数内部的this值。
```js
var sillyFunction = function (recursed) {
  if(!recursed) {
    console.log(this); // Window {}
    return arguments.callee(true);
  }
  console.log(this); // Arguments {}
}
sillyFunction();
```
如果需要在函数内部进行递归调用，推荐使用函数声明或者使用函数表达式，给函数一个明确的函数名。
#### arguments对象的应用
##### 实参的个数判断
```js
function f(x, y, z) {
   // 检查传递的参数个数是否正确
   if (arguments.length !== 3) {
       throw new Error("期望传递的参数个数为3，实际传递个数为" + arguments.length);
   }
   // ...do something
}
f(1, 2); // Uncaught Error: 期望传递的参数个数为3，实际传递个数为2
```
##### 任意个数的参数处理
定义一个函数，该函数只会特定处理传递的前几个参数，对于后面的参数不论传递多少个都会统一处理，这种场景下我们可以使用arguments对象。
```js
function joinStr(seperator) {
  // arguments对象是一个类数组结构，可以通过call函数间接调用slice函数，得到一个数组
  var strArr = Array.prototype.slice.call(arguments, 1);
  // strArr数组直接调用join函数
  return strArr.join(seperator);
}
joinStr('-', 'orange', 'apple', 'banana');
joinStr(',', 'orange', 'apple', 'banana');
```
##### 模拟函数重载
在函数名相同的情况下，通过函数形参的不同参数类型或者不同参数个数来定义不同的函数。

在JavaScript中是没有函数重载的，主要有以下几点原因。
- JavaScript是一门弱类型的语言，变量只有在使用时才能确定数据类型，通过形参是无法确定数据类型的。
- 无法通过函数的参数个数来指定调用不同的函数，函数的参数个数是在函数调用时才确定下来的。
- 使用函数声明定义的具有相同名称的函数，后者会覆盖前者。
```js
function sum(num1, num2) {
  return num1 + num2;
}
function sum(num1, num2, num3) {
  return num1 + num2 + num3;
}
sum(1, 2); // 1 + 2 + undefined = NaN
sum(1, 2, 3); // 6
```
使用arguments对象处理传递的参数。
```js
// 通用的求和函数
function sum() {
  // 通过call函数间接调用数组的slice函数得到函数参数的数组
  var arr = Array.prototype.slice.call(arguments);
  // 调用数组的reduce函数进行多个值的求和
  return arr.reduce(function (pre, cur) {
    return pre + cur;
  }, 0)
}
sum(1, 2); // 3
sum(1, 2, 3); // 6
sum(1, 2, 3, 4); // 10
```
## 构造函数
当我们创建对象的实例时，通常会使用到构造函数，例如对象和数组的实例化可以通过相应的构造函数Object()和Array()完成。

构造函数与普通函数在语法的定义上没有任何区别，主要的区别体现在以下3点。
- 构造函数的函数名的第一个字母通常会大写。
- 在函数体内部使用this关键字，表示要生成的对象实例，构造函数并不会显式地返回任何值，而是默认返回“this”。
```js
function Person(name) {
  this.name = name;
}
var p = new Person('ming');
console.log(p); // Person { name: "ming" }
```
- 作为构造函数调用时，必须与new操作符配合使用。
一个函数只有在配合new操作符调用时才能当作一个构造函数，如果不使用new操作符，则只是一个普通函数。
```js
// 一个函数在当作构造函数使用时，能通过new操作符创建对象的实例，并通过实例调用对应的函数。
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayName = function() {
    alert(this.name);
  };
}
var person = new Person('ming', 22);
person.sayName(); // 'ming'
// 一个函数在当作普通函数使用时，函数内部的this会指向window。
Person('ming', 12)
window.sayName(); // ming
```
构造函数在执行创造对象实例时会执行以下4步。
- 通过new操作符创建一个新的对象，在内存中创建一个新的地址。
- 为构造函数中的this确定指向。
- 执行构造函数代码，为实例添加属性。
- 返回这个新创建的对象。

以前面生成person实例的代码为例。
第一步：为person实例在内存中创建一个新的地址。
第二步：确定person实例的this指向，指向person本身。
第三步：为person实例添加name、age和sayName属性，其中sayName属性值是一个函数。
第四步：返回这个person实例。

缺点：即对函数的处理。
在构造函数中为this添加了一个sayName属性，它的值为一个函数，这样在每次创建一个新的实例时，都会给实例新增一个sayName属性，而且不同实例中的sayName属性是不同的。
```js
var person1 = new Person();
var person2 = new Person();
console.log(person1.sayName === person2.sayName); // false
```
> 设置全局访问函数会污染作用域，使用原型即可解决。
## 变量提升与函数提升
一个函数体内，变量在定义之前就可以被访问到，而不会抛出异常。
```js
function fn() {
  console.log(a); // undefined
  var a = 1;
}
```
函数也有类似的表现，函数在定义之前就可以被调用，而不会抛出异常。
```js
fn();
function fn() {
  console.log('out'); // out
}
```
### 作用域
在JavaScript中，一个变量的定义与调用都是会在一个固定的范围中的，这个范围我们称之为作用域。
作用域可以分为全局作用域、函数作用域和块级作用域(ES6：let/const)。
- 全局作用域：如果变量定义在全局环境中，那么在任何位置都可以访问到这个变量；
- 函数作用域：如果变量定义在函数内部，那么只能在函数内部访问到这个变量；
- 块级作用域：如果变量定义在一个代码块中，那么只能在代码块中访问到这个变量。
```js
// 全局作用域内的变量a
var a = 'global variable';
function foo() {
  // 函数作用域内的变量b
  var b = 'function variable';
  console.log(a); // global variable
  console.log(b); // function variable
}
// 块级作用域内的变量c
{
  let c = 'block variable';
  console.log(c); // block variable
}
console.log(c); // Uncaught ReferenceError: c is not defined
```
在函数内部**使用var定义的变量**
#### 代码1
```js
var v = 'Hello World';
(function() {
  console.log(v); // Hello World
})();
```
#### 代码2
```js
var v = 'Hello World';
(function() {
  // var v;
  console.log(v); // undefined
  var v = 'Hello JM'; // v = 'Hello JM'
})();
```
### 变量提升
变量提升（必须是通过var关键字）是将变量的声明提升到函数顶部的位置，而**变量的赋值并不会被提升**。
```js
(function () {
  console.log(v); // Uncaught ReferenceError: v is not defined
  v = 'Hello JM';
})
```
#### [代码1的执行过程](#代码1)
在全局对象window上定义一个变量v，并赋值为Hello World。然后定义一个立即执行函数，这个立即执行函数的作用域为window。在函数内部引用变量v，然后会顺着作用域寻找，最终会在window上找到这个变量v，因此输出“Hello World”。
#### [代码2的执行过程](#代码2)
出现了变量提升，在立即执行函数的内部，变量v的定义会提升到函数顶部，实际执行过程的代码如下所示。
```js
var v = 'Hello World';
(function () {
  var v;   // 变量的声明得到提升  
  console.log(v);
  v = 'Hello JavaScript';  // 变量的赋值并未提升
})();
```
### 函数提升
使用函数声明方式定义的函数也会出现提升。
```js
foo(); // foo()函数被提升至作用域顶部
function foo() {
  console.log('I am come from foo');
}
// 相当于
function foo() {
   console.log("我来自 foo");
}
foo();  // 我来自 foo
```
> 需要注意的是函数提升会将整个函数体一起进行提升，包括里面的执行逻辑。
> 而对于函数表达式，是不会进行函数提升的。
```js
foo();  // Uncaught TypeError: foo is not a function
var foo = function () {
  console.log('我自来 foo');
};
```
两者同时使用时的情况
```js
show(); // hello
var show;
// 函数声明，会被提升
function show() {
  console.log('hello');
}
// 函数表达式，不会被提升
show = function() {
  console.log('world');
}
```
### 变量提升与函数提升的应用
#### 关于函数提升
```js
function foo() {
  function bar() {
    return 3;
  }
  return bar();
}
function bar() {
  return 8;
}
console.log(foo()); // 3

function foo() {
  function bar() {
    return 3;
  }
  return bar();
  function bar() {
    return 8;
  }
}
console.log(foo()); // 8
```
由于变量提升的存在，两段代码都会被提升至foo()函数的顶部，而且后一个函数会覆盖前一个bar()函数，因此最后输出值为“8”。
#### 变量提升和函数提升同时使用
```js
var a = true;
foo(); // 函数提升正常调用
function foo() {
  if (a) {
    var a = 10;
  }
  console.log(a); // undefined
}
// 执行过程
var a;
a = true;
function foo() {
  var a;
  if (a) {
    a = 10;
  }
  console.log(a); // undefined
}
foo();
```
#### 变量提升和函数提升优先级👍👍👍
```js
function fn() {
  console.log(typeof foo); // function
  // 变量提升
  var foo = 'variable';
  // 函数提升
  function foo() {
    return 'function';
  }
  console.log(typeof foo); // string
}
fn();
```
**变量提升的优先级要比函数提升的优先级高**，因此实际执行过程可以改写为以下代码段。
```js
function fn() {
  // 变量提升至函数顶部
  var foo;
  // 函数提升，但是优先级低，出现在变量声明后面，则foo是一个函数
  function foo() {
    return 'function';
  }
  console.log(typeof foo); // function
  foo = 'variable';
  console.log(typeof foo); // string
}
```
#### 变量提升和函数提升整体应用👍👍👍
```js
function foo() {
  var a = 1;
  function b() {
    a = 10;
    return;
    function a() {} // 变量a的函数声明，则会进行提升
  }
  b();
  console.log(a); // 1
}
foo();
```
整体执行过程可以改写为以下代码段。
```js
function foo() {
  // 变量a的提升
  var a;
  // 函数声明b的提升
  function b() {
    // 内部的函数声明a的提升
    function a() {}
    a = 10;
    return;
  }
  a = 1;
  b();
  console.log(a); // 1
}
foo();
```
> `以上知识点没啥卵用`，无论变量还是函数，都做到先声明后使用。
```js
// 定义变量
var name = 'Scott';
// 先定义函数
var sayHello = function(guest) {
   console.log(name, 'says hello to', guest);
};
// 预先定义将要使用到的变量
var i;
var guest;
var guests = ['John', 'Tom', 'Jack'];
for (i = 0; i < guests.length; i++) {
   // 使用变量
   guest = guests[i];
   // 使用预先定义的sayHello()函数
  sayHello(guest);
}
```
ES6
```js
const name = 'Scott';
let sayHello = function(guest) {
   console.log(name, 'says hello to', guest);
};

let guests = ['John', 'Tom', 'Jack'];

for (let i = 0; i < guests.length; i++) {
   let guest = guests[i];
   sayHello(guest);
}
```
## 闭包
在正常情况下，如果定义了一个函数，就会产生一个函数作用域，在函数体中的局部变量会在这个函数作用域中使用。一旦函数执行完成，函数所占空间就会被回收，存在于函数体中的局部变量同样会被回收，回收后将不能被访问到。
期望在函数执行完成后，函数中的局部变量仍然可以被访问到，这能不能实现呢？
### 执行上下文环境👍👍👍👍👍
JavaScript每段代码的执行都会存在于一个执行上下文环境中，而任何一个执行上下文环境都会存在于整体的执行上下文环境中。根据栈先进后出的特点，全局环境产生的执行上下文环境会最先压入栈中，存在于栈底。当新的函数进行调用时，会产生的新的执行上下文环境，也会压入栈中。当函数调用完成后，这个上下文环境及其中的数据都会被销毁，并弹出栈，从而进入之前的执行上下文环境中。

处于活跃状态的执行上下文环境只能同时有一个：
全局上下文环境  === 压栈 ===> 函数上下文环境or全局上下文环境 === 出栈（销毁） ===> 全局上下文环境
```js
1  var a = 10;    // 1.进入全局执行上下文环境
2  var fn = function (x) {
3      var c = 10;
4      console.log(c + x);
5  };
6  var bar = function (y) {
7      var b = 5;
8      fn(y + b);  // 3.进入fn()函数执行上下文环境
9  };
10 bar(20);  // 2.进入bar()函数执行上下文环境
```
从第1行代码开始，进入全局执行上下文环境，此时执行上下文环境中只存在全局执行上下文环境。
```js
     执行上下文环境
|                     |
|                     |
|                     |
|   全局执行上下文环境  |  <---- 活跃状态的上下文环境
 ____________________
```
当代码执行到第10行时，调用bar()函数，进入bar()函数执行上下文环境中。
```js
    执行上下文环境
|                        |
|                        |
|  bar()函数执行上下文环境 |   <---- 活跃状态的上下文环境
|    全局执行上下文环境    |
 ______________________
```
执行到第8行时，调用fn()函数，进入fn()函数执行上下文环境中。
```js
     执行上下文环境
|                        |
|   fn函数执行上下文环境   |   <---- 活跃状态的上下文环境
|   bar函数执行上下文环境  |
|    全局执行上下文环境    |
 ______________________
```
进入fn()函数中，执行完第5行代码后，fn()函数执行上下文环境将会被销毁，从而弹出栈。
```js
     执行上下文环境
|                        |
|                        |
|   bar函数执行上下文环境  |   <---- 活跃状态的上下文环境
|    全局执行上下文环境    |
 ______________________
```
fn()函数执行上下文环境被销毁后，回到bar()函数执行上下文环境中，执行完第9行代码后，bar()函数执行上下文环境也将被销毁，从而弹出栈
```js
     执行上下文环境
|                     |
|                     |
|                     |
|   全局执行上下文环境  |  <---- 活跃状态的上下文环境
 ____________________
```
最后全局上下文环境执行完毕，栈被清空，流程执行结束。
像上面这种代码执行完毕，执行上下文环境就会被销毁的场景，是一种比较理想的情况。
有另外一种情况，虽然代码执行完毕，但执行上下文环境却被无法干净地销毁，这就是我们要讲到的闭包。

> 个人理解有点像--(-(-(-)-)-)-->洋葱圈模型。

### 闭包的概念
> 官方通用的解释：一个拥有许多变量和绑定了这些变量执行上下文环境的表达式，通常是一个函数。

闭包有两个很明显的特点。
- 函数拥有的外部变量的引用，在函数返回时，该变量仍然处于活跃状态。
- 闭包作为一个函数返回时，其执行上下文环境不会被销毁，仍处于执行上下文环境中。

在JavaScript中存在一种内部函数，即函数声明和函数表达式可以位于另一个函数的函数体内，在内部函数中可以访问外部函数声明的变量，当这个内部函数在包含它们的外部函数之外被调用时，就会形成闭包。
```js
1  function fn() {
2      var max = 10;
3      return function bar(x) 
4          if (x > max) {
5              console.log(x);
6          }
7      };
8  }
9  var f1 = fn();
10 f1(11);  // 11
```
代码开始执行后，生成全局上下文环境，并将其压入栈中。
```js
    执行上下文环境
|                    |
|                    |
|                    |
|  全局执行上下文环境  |  <---- 活跃状态的上下文环境
 ____________________
```
代码执行到第9行时，进入fn()函数中，生成fn()函数执行上下文环境，并将其压入栈中。
```js
     执行上下文环境
|                       |
|                       |
|  fn函数执行上下文环境   |   <---- 活跃状态的上下文环境
|   全局执行上下文环境    |
 ______________________
```
fn()函数返回一个bar()函数，并将其赋给变量f1。

当代码执行到第10行时，调用f1()函数，注意此时是一个关键的节点，因为f1()函数中包含了对max变量的引用，而max变量是存在于外部函数fn()中的，此时fn()函数执行上下文环境并不会被直接销毁，依然存在于执行上下文环境中。
```js
      执行上下文环境
|                         |
|   bar函数执行上下文环境   |   <---- 活跃状态的上下文环境
|   fn函数执行上下文环境    |   
|   全局执行上下文环境      |
 ___________________________
```
等到第10行代码执行结束后，bar()函数执行完毕，bar()函数执行上下文环境才会被销毁，同时因为max变量引用会被释放，fn()函数执行上下文环境也一同被销毁。
最后全局上下文环境执行完毕，栈被清空，流程执行结束。
> 从分析就可以看出闭包所存在的最大的一个问题就是消耗内存，如果闭包使用越来越多，内存消耗将越来越大。
### 闭包的用途
> 写出一些更加简洁优雅的代码，并且能在某些方面提升代码的执行效率。
#### 结果缓存
假如有一个处理很耗时的函数对象，每次调用都会消耗很长时间。
可以将其处理结果在内存中缓存起来。这样在执行代码时，如果内存中有，则直接返回；如果内存中没有，则调用函数进行计算，更新缓存并返回结果。
因为闭包不会释放外部变量的引用，所以能将外部变量值缓存在内存中。
```js
var cachedBox = (function () {
  // 缓存的容器
  var cache = {};
  return {
    searchBox: function (id) {
      // 如果在内存中，则直接返回
      if (id in cache) {
        return '查找的结果为：' + cache[id];
      }
      // 经过一段很耗时的dealFn()函数处理
      var result = dealFn(id);
      // 更新缓存的结果
      cache[id] = result;
      // 返回计算的结果
      return '查找的结果为：' + result;
    }
  };
})();

// 很耗时的函数
function dealFn(id) {
  console.log('耗时操作');
  return id;
}
console.log(cachedBox.searchBox(1)); // 耗时操作 查找的结果为：1
console.log(cachedBox.searchBox(1)); // 查找的结果为：1
```
在上面的代码中，末尾两次调用searchBox(1)()函数，在第一次调用时，id为1的值并未在缓存对象cache中，因为会执行很耗时的函数，输出的结果为“1”。

而第二次执行searchBox(1)函数时，由于第一次已经将结果更新到cache对象中，并且该对象引用并未被回收，因此会直接从内存的cache对象中读取，直接返回“1”，最后输出的结果为“1”。
#### 封装
在JavaScript中提倡的模块化思想是希望将具有一定特征的属性封装到一起，只需要对外暴露对应的函数，并不关心内部逻辑的实现。
```js
var stack = (function () {
  // 使用数组模仿栈的实现
  var arr = [];
  // 栈
  return {
    // 只对外暴露出表示入栈和出栈的push()函数和pop()函数，以及表示栈长度的size()函数。
    push: function (value) {
      arr.push(value);
    },
    pop: function () {
      return arr.pop();
    },
    size: function () {
      return arr.length;
    }
  };
})();
stack.push('abc');
stack.push('def');
console.log(stack.size()); // 2
stack.pop();
console.log(stack.size()); // 1
```
上面的代码中存在一个立即执行函数，在函数内部会产生一个执行上下文环境，最后返回一个表示栈的对象并赋给stack变量。在匿名函数执行完毕后，其执行上下文环境并不会被销毁，因为在对象的push()、pop()、size()等函数中包含了对arr变量的引用，arr变量会继续存在于内存中，所以后面几次对stack变量的操作会使stack变量的长度产生变化。
##### ul中有若干个li，每次单击li，输出li的索引值
```html
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
</ul>
<script>
  var list = document.getElementsByTagName('ul')[0].children;
  for (var i = 0; i < list.length; i++) {
    list[i].onclick = function () {
      console.log(i); // 5
    }
  }
// 因为在我们单击li，触发li的click事件之前，for循环已经执行结束了，而for循环束的条件就是最后一次i++执行完毕，此时i的值为5，所以每次单击li后返回的都是“5”。
</script>
```
使用闭包解决
```js
var list = document.getElementsByTagName('ul')[0].children;
for (var i = 0; i < list.length; i++) {
  (function(index) {
    list[index].onclick = function () {
      console.log(index); // 1 ~ 5
    };
  })(i);
}
// 在每一轮的for循环中，我们将索引值i传入一个匿名立即执行函数中，在该匿名函数中存在对外部变量lis的引用，因此会形成一个闭包。而闭包中的变量index，即外部传入的i值会继续存在于内存中，所以当单击li时，就会输出对应的索引index值。
```
##### 定时器问题
```js
var arr = ['one', 'two', 'three'];
for (var i = 0; i < arr.length; i++) {
  setTimeout(function (){
    console.log(arr[i]); // undefined
  }, i * 1000); // 1000
}
```
setTimeout()函数与for循环在调用时会产生两个独立执行上下文环境，当setTimeout()函数内部的函数执行时，for循环已经执行结束，而for循环结束的条件是最后一次i++执行完毕，此时i的值为3，所以实际上setTimeout()函数每次执行时，都会输出arr[3]的值。而因为arr数组最大索引值为2，所以会间隔一秒输出“undefined”。
```js
// 使用闭包
var arr = ['one', 'two', 'three'];
for (var i = 0; i < arr.length; i++) {
  (function(index){
    setTimeout(function (){
      console.log(arr[index]); // one two three
    }, index * 1000); // 0 1000 2000 
  })(i);
}
```
通过立即执行函数将索引i作为参数传入，在立即函数执行完成后，由于setTimeout()函数中有对arr变量的引用，其执行上下文环境不会被销毁，因此对应的i值都会存在内存中。所以每次执行setTimeout()函数时，i都会是数组对应的索引值0、1、2，从而间隔一秒输出“one”“two”“three”。
##### 作用域链问题
```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```
