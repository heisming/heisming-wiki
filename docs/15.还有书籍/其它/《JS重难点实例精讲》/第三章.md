# 函数👍👍👍👍👍

## 函数的定义与调用
### 函数的定义
#### 函数声明
```js
// 函数声明式
function sum(num1, num2) {
   return num1 + num2;
}
```

#### 函数表达式
```js
// 函数表达式
var sum = function (num1, num2) {
   return num1 + num2;
};
```
这个函数表达式没有名称，属于匿名函数表达式。
使用函数声明和匿名函数表达式定义的函数，在进行函数调用时，都只需要使用函数名，传入对应的实际参数（后文简称为实参）即可，示例如下。
```js
console.log(sum(1, 3)); // 4
```
需要注意的是，函数表达式也可以定义具有名称的函数，函数名称即跟在function关键字后的值。
```js
// 具有函数名的函数表达式
var sum = function foo(num1, num2) {
   return num1 + num2;
};
```
其中foo是函数名称，它实际是**函数内部的一个局部变量，在函数外部是无法直接调用**的，示例如下。
```js
console.log(foo(1, 3)); // ReferenceError: foo is not defined
```

#### Function()构造函数
使用new操作符，调用Function构造函数，传入对应的参数，也可以定义一个函数。
```js
// 其中的参数，除了最后一个参数是执行的函数体，其他参数都是函数的形参。
var add = new Function("a", "b", "return a + b");
```

> 相比于函数声明和函数表达式这两种方式，Function()构造函数的使用比较少，主要有以下两个原因。
> - 第一个原因是Function()构造函数每次执行时，都会解析函数主体，并创建一个新的函数对象，所以当在一个循环或者频繁执行的函数中调用Function()构造函数时，效率是非常低的。
> - 第二个原因是使用Function()构造函数创建的函数，并不遵循典型的作用域，它将一直**作为顶级函数执行**。所以在一个函数A内部调用Function()构造函数时，其中的函数体并**不能访问到函数A中的局部变量，而只能访问到全局变量**。

```js
var y = 'global'; // 全局变量
function constructFunction() {
  var y = 'local'; // 局部变量
  return new Function('return y'); // 无法获取局部变量的值
}
console.log(constructFunction()()); // global
```

#### 函数表达式的应用场景
##### 函数递归
通过函数表达式可以定义具有名称的函数，它作为函数内部的一个局部变量，指向函数自身，我们可以利用这一点很好实现递归的功能。
```js
// 斐波那契数列问题
// 通过函数声明实现
function fibonacci(num) {
  if (num === 1 || number === 2) {
    return 1;
  }
  return fibonacci(num - 2) + fibonacci(number - 1);
}
// 通过函数表达式实现
var fibonacci = function(num) {
  if (num === 1 || number === 2) {
    return 1;
  }
  return fibonacci(num - 2) + fibonacci(number - 1);
}
```

##### 代码模块化
在ES6以前，JavaScript中是没有**块级作用域**的，但是我们可以通过函数表达式来间接地实现模块化，将特定的模块代码封装在一个函数中，只对外暴露接口，使用者也不用关心具体细节，这样做可以很好地避免全局环境的污染。
```js
// 立即执行的匿名函数表达式
var person = (function() {
  var _name = "";
  return {
    getName: function() {
      return _name;
    },
    setName: function(newName) {
      _name = newName;
    }
  };
}());
person.setName('ming');
person.getName();
```
返回的是一个对象，只需要调用getName()函数和setName()函数，而不用关心person私有的_name属性。

#### 函数声明与函数表达式的区别
> JavaScript解释器在处理两者时却不一样

##### 函数名称
- 在使用函数声明时，是必须设置函数名称的，这个函数名称**相当于一个变量**，以后函数的调用也会通过这个变量进行。

- 而对于函数表达式来说，**函数名称是可选的**，我们可以定义一个匿名函数表达式，并赋给一个变量，然后通过这个变量进行函数的调用。

```js
// 函数声明，函数名称sum必须设置
function sum(num1, num2) {
  return num1 + num2;
}
// 没有函数名称的匿名函数表达式
var sum = function(num1, num2) {
  return num1 + num2;
}
// 具名函数名的函数表达式，其中foo为函数名称
var sum = function foo(num1, num2) {
  return num1 + num2;
}
```
##### 函数提升
- 对于**函数声明，存在函数提升**，所以即使函数的调用在函数的声明之前，仍然可以正常执行。
- 对于**函数表达式，不存在函数提升**，所以在函数定义之前，不能对其进行调用，否则会抛出异常。
```js
console.log(add(1, 2)); // 3
console.log(sub(5, 3)); // Uncaught TypeError: sub is not a function
// 函数声明
function add(a1, a2) {
  return a1 + a2;
}
// 函数表达式
var sub = function(a1, a2) {
  return a1 - a2;
}
``` 

### 函数的调用
#### 函数调用模式
函数调用模式是通过函数声明或者函数表达式的方式定义函数，然后直接通过函数名调用的模式。
```js
// 函数声明
function add(a1, a2) {
  return a1 + a2;
}
// 函数表达式
var sub = function(a1, a2) {
  return a1 - a2;
}
add(1, 3);
sub(4, 1);
```

#### 方法调用模式👍
方法调用模式会优先定义一个对象obj，然后在对象内部定义值为函数的属性property，通过对象obj.property()来进行函数的调用。
```js
// 定义对象
var obj = {
  name: 'ming',
  // 定义getName属性，值为一个函数
  getName: function() {
    return this.name;
  }
}
obj.getName(); // 通过对象进行调用
obj['getName'](); // 函数还可以通过中括号来调用，即对象名['函数名']。
```
**如果在某个方法中返回的是函数对象本身this**，那么可以利用链式调用原理进行连续的函数调用。
```js
var obj2 = {
  name: 'ming',
  getName: function() {
    console.log(this.name);
  },
  setName: function(name) {
    this.name = name;
    return this; // 在函数内部返回函数对象本身
  }
};
obj2.setName('ming').getName(); // 链式函数调用
```
#### 构造器调用模式
构造器调用模式会定义一个函数，在函数中定义实例属性，在原型上定义函数，然后通过new操作符生成函数的实例，再通过实例调用原型上定义的函数。
```js
// 定义函数对象
function Person(name) {
  this.name = name;
}
// 原型上定义函数
Person.prototype.getName = function() {
  return this.name;
}
// 通过new操作符生成实例
var p = new Person('ming');
// 通过实例进行函数的调用
p.getName();
```
#### call()函数、apply()函数调用模式👍👍👍
通过call()函数或者apply()函数可以**改变函数执行的主体**，使得某些不具有特定函数的对象可以直接调用该特定函数。
```js
function sum(num1, num2) {
  return num1 + num2;
}
var person = {};
// 通过call函数与apply函数调用sum
sum.call(person, 1, 2);
sum.apply(person, [2, 3]);
```
通过call()函数与apply()函数，使得没有sum()函数的person对象也可以直接调用sum()函数

#### 匿名函数调用模式
一种是通过函数表达式定义函数，并赋给变量，通过变量进行调用。
```js
// 通过函数表达式定义匿名函数，并赋给变量sum
var sum = function(num1, num2) {
  return num1 + num2;
}
// 通过sum函数进行匿名函数调用
sum(1, 2);
```
另一种是使用小括号()将匿名函数括起来，然后在后面使用小括号()，传递对应的参数，进行调用。
```js
(function (num1, num2) {
  return num1 + num2;
})(1, 2);
```
使用小括号括住的函数声明实际上是一个函数表达式，紧随其后的小括号表示会立即调用这个函数。
```js
function (num1, num2) {
  return num1 + num2;
}(1, 2); // Uncaught SyntaxError: Unexpected token (
```
因为JavaScript解释器在解析语句时，会将function关键字当作函数声明的开始，函数的声明是需要有函数名称的，而上面的代码却并没有函数名称，所以会抛出语法异常。
```js
// 写上呢
function sum(num1, num2) {
  console.log(num1 + num2);
}(1, 2); // 2
```
实际上，在函数声明后增加的小括号相当于一个分组操作符，两部分内容是完全独立的，并不会起到立即执行的作用，与下列语句等价。
```js
// 函数声明
function sum(num1, num2) {
   console.log(num1 + num2);
}
// (逗号)表达式
(1, 2); // 2
```
如何才可以呢？
```js
var sum = function(num1, num2) {
  return num1 + num2;
}(1, 2);
console.log(sum); // 3
// 这部分表示的是函数立即执行。
function(num1, num2) {
  return num1 + num2;
}(1, 2);
```
```js
// 实名立即调用函数
(function sum(num1, num2) {
   console.log(num1 + num2);
}(1, 2));
```

### 自执行函数
> 自执行函数即函数定义和函数调用的行为先后连续产生。
它需要以一个函数表达式的身份进行函数调用，
匿名函数调用也属于自执行函数的一种。
```js
function (x) {
  alert(x);
}(5); // Uncaught SyntaxError: Unexpected token (

var aa = function(x) {
  console.log(x);
}(1); // 1

true && function (x) {
  console.log(x);
}(2); // 2

0, function(x) {
  console.log(x);
}(3); // 3

!function(x) {
  console.log(x);
}(4); // 4

~function(x) {
  console.log(x);
}(5); // 5

-function(x) {
  console.log(x);
}(6); // 6

+function(x) {
  console.log(x);
}(7); // 7

new function() {
  console.log(8); // 8
};

new function(x) {
  console.log(x); 
}(9); // 9
```

## 函数参数

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```
