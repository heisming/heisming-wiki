# 引用数据类型
常用的引用数据类型包括Object类型、Array类型、Date类型、RegExp类型、Math类型、Function类型以及基本数据类型的包装类型，如Number类型、String类型、Boolean类型等。

引用数据类型有不同于基本数据类型的特点，具体如下所示
- 引用数据类型的实例需要通过new操作符生成，有的是显式调用，有的是隐式调用。
- 引用数据类型的值是可变的，基本数据类型的值是不可变的。
- 引用数据类型==变量赋值传递的是内存地址==。
- 引用数据类型的比较是对内存地址的比较，而基本数据类型的比较是对值的比较。

## Object
> Object类型使用的频率高是因为其对于**数据存储**和**传输**是非常理想的选择

由于引用数据类型的实例都需要通过new操作符来生成，因此我们需要先了解new操作符的相关知识。

new操作符在执行过程中会改变this的指向。
```js
function Cat(name, age) {
  console.log(this)  // Cat {}
  this.name = name; // Cat.name = name;
  this.age = age; // Cat.age = age;
}
console.log(new Cat('miaomiao', 18)); // Cat { name: 'miaomiao', age: 18 }
```
换个说法
```js
function Cat(name,age){
   var Cat = {};
   Cat.name = name;
   Cat.age = age;
}
console.log(new Cat('miaomiao',18));  // Cat {}
```
输出结果中并未包含name和age属性，这是为什么呢？

因为在JavaScript中，如果函数没有return值，则默认return this。
-
上面代码中的this实际是一个Cat空对象，name和age属性只是被添加到了临时变量Cat中。*为了能让输出结果包含name和age属性*，我们将临时变量Cat进行return就可以了。
```js
function Cat(name, age) {
  var Cat = {};
  Cat.name = name;
  Cat.age = age;
  return Cat; // 返回一个普通对象而已 
}
console.log(new Cat('miaomiao', 8)) // { name: "miaomiao", age: 18 }
```

### this与new操作符之间有什么关系呢？
```js
// 从表面上看这行代码的主要作用是创建一个Cat对象的实例，并将这个实例值赋予cat变量，cat变量就会包含Cat对象的属性和函数。
var cat = new Cat();

// 其实，new操作符做了3件事情
var cat = {} //  1.创建了一个空对象。
// 2. 将空对象的隐式原型属性指向Cat对象的显示原型属性
cat.__proto__ = Cat.prototype; 
Cat.call(cat); // 3. 将Cat()函数中的this指向cat变量
// 于是cat变量就是Cat对象的一个实例。
```

自定义一个类似new功能的函数
```js
function Cat(name, age) {
  this.name = name;
  this.age = age;
}
function New() {
  var obj = {};
  var res = Cat.apply(obj, arguments);
  // console.log(res);
  return typeof res === 'object' ? res : obj;
}
console.log(New('mimi', 18)); // Object { name: 'mimi', age: 18 }
// Cat.apply(obj, arguments)调用后Cat对象中的this就指向了obj对象，这样obj对象就具有了name和age属性。
```
因此，不仅要关注new操作符的函数本身，也要关注它的原型属性。

再次改动
```js
function Cat(name, age) {
  this.name = name;
  this.age = age;
}

Cat.prototype.sayHi = function() {
  console.log('hi');
};

function New() {
  var obj = {};
  var res = Cat.apply(obj, arguments);
  return typeof res === 'object' ? res : obj;
}

console.log(New('mimi', 18).sayHi()) // Uncaught TypeError: New(...).sayHi is not a function
```
New函数指向了obj,而sayHi函数是Cat显式原型上的方法。

修改后：在New函数中增加原型指向即可。
```js
obj.__proto__ = Cat.prototype;
```

### 实例函数
实例函数是指函数的调用是基于Object类型的实例的。
```js
var obj = new Object();
```
所有实例函数的调用都是基于obj这个实例。

#### hasOwnProperty(propertyName)函数
该函数的作用是判断对象自身是否拥有指定名称的实例属性，此函数==不会检查实例对象原型链上的属性==。
```js
var o = new Object();
o.name = 'custom attribution';
console.log(o.hasOwnProperty('name')); // true
console.log(o.hasOwnProperty('toString')); // false

var Student = function (name) {
  this.name = name;
}
Student.prototype.sayHello = function () {
  alert('Hello,' + this.name);
}
Student.prototype.age = 0;
var st = new Student('xiaoming');
console.log(st.hasOwnProperty('name')); // true
console.log(st.hasOwnProperty('sayHello')); // false
console.log(st.hasOwnProperty('age')); // false
```
#### propertyIsEnumerable(propertyName)函数
该函数的作用是判断指定名称的属性是否为实例属性并且是否是可枚举的，如果是原型链上的属性或者不可枚举都将返回“false”。
```js
var array = [1, 2, 3];
array.name = 'Array';
console.log(array.propertyIsEnumerable('name')); // true：实例属性
console.log(array.propertyIsEnumerable('join')); // false：继承属性
console.log(array.propertyIsEnumerable('length')); // false：继承属性
console.log(array.propertyIsEnumerable('toString')); // false：继承属性

var Student = function (name) {
  this.name = name;
}
Student.prototype.sayHello = function () {
  alert('Hello', this.name);
}

var a = new Student('tom');
console.log(a.propertyIsEnumerable('name')); // true：实例属性
console.log(a.propertyIsEnumerable('age')); // false：无此属性
console.log(a.propertyIsEnumerable('sayHello')); // false：原型属性

// 设置name属性为不可枚举的
Object.defineProperty(a, 'name', {
  enumerable: false
})
console.log(a.propertyIsEnumerable('name')) // false
```

#### [hasOwn](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn)
> Object.hasOwn() 旨在取代 Object.prototype.hasOwnProperty()。


### 静态函数
> 静态函数指的是方法的调用基于Object类型自身，不需要通过Object类型的实例。

#### Object.create()
创建并返回一个指定原型和指定属性的对象
```js
// 
Object.create(prototype, propertyDescriptor)。
```
prototype属性为对象的原型，可以为null。若为null，则对象的原型为undefined。属性描述符的格式如下所示。
##### propertyDescriptor
属性描述符
```js
propertyName: {
   value: '', // 设置此属性的值
   writable: true, // 设置此属性是否可写入；默认为false：只读
   enumerable: true, // 设置此属性是否可枚举；默认为false：不可枚举
   configurable: true // 设置此属性是否可配置，如是否可以修改属性的特性及是否可以删除属性；默认为false
}
```
举例
```js
// 建立一个自定义对象，设置name和age属性
var obj = Object.create(null, {
  name: {
    value: 'tom',
    writable: true,
    enumerable: true,
    configurable: true
  },
  age: {
    value: 22
  }
})
console.log(obj.name); // tom
console.log(obj.age); // 22
obj.age = 26;
console.log(obj.age); // 22 : age属性的writable默认为false

for(var p in obj) {
  console.log(p); // name : 只输出name属性：age属性的enumerable默认为false,不能通过for...in枚举
}
```
使用polyfill实现
```js
Object.create = function (proto, propertiesObject) {
  // 省去中间很多判断
  function F() {}
  F.prototype = proto;
  return new F();
}
```
在create()函数中，首先声明一个函数为F()函数，然后将F()函数的prototype属性指向传入的proto参数，通过new操作符生成F()函数的实例。

假如`var f = new F()`，`f.__proto__ === F.prototype`。实际上生成的对象实例会把属性继承到其`__proto__`属性上。

验证
```js
var test = Object.create({ x: 123, y: 345 });
console.log(test); // {}, 实际生成的对象为 一个空对象
console.log(test.x); // 123
console.log(test.__proto__.x); // 123
console.log(test.__proto__.x === test.x); // true
```
可以通过其__proto__属性访问到x属性。

#### Object.defineProperties()
> 添加或修改对象的属性值
```js
Object.defineProperties(obj, propertyDescriptor)
```
[propertyDescriptor同Object.create](#propertyDescriptor)，例如，给一个空对象{}添加name和age属性，其代码如下所示。
```js
var obj = {};
Object.defineProperties(obj, {
  name: {
    value: 'tom',
    enumerable: true
  },
  age: {
    value: 22,
    enumerable: true
  }
})
for(var p in obj) {
  console.log(p); // name age 
}
// age属性的writable默认为false,只读
obj.age = 23;
console.log(obj.age); // 22  
```
##### 同object.create区别？

#### Object.getOwnPropertyNames()
> 获取对象的所有实例属性和函数，不包含原型链继承的属性和函数，数据格式为数组
```js
function Person(name, age, gender) {
  this.name = name;
  this.age = age;
  this.gender = gender;
  this.getName = function () {
    return this.name;
  }
}
Person.prototype.eat = function() {
  return 'eat food';
}
var p = new Person();
console.log(Object.getOwnPropertyNames(p));// ["name", "age", "gender", "getName"] 
```

#### Object.keys()
> 获取对象可枚举的实例属性，不包含原型链继承的属性，数据格式为数组。
> keys()函数区别于getOwnPropertyNames()函数的地方在于，keys()函数只获取**可枚举类型**的属性。
```js
var obj = {
  name: 'tom', 
  age: 22, 
  sayHello() { alert('Hello' + this.name)};
}
// (1) getOwnPropertyName()函数与keys()函数返回的内容都相同
// ['name', 'age', 'sayHello']: 返回对象的所有实例成员
console.log(Object.getOwnPropertyNames(obj));
// ['name', 'age', 'sayHello']: 返回对象的所有可枚举成员
console.log(Object.key(obj));

// 设置对象的name属性不可枚举
Object.defineProperty(obj, 'name', { enumerable: false });

// (2) keys()函数，只包含可枚举成员
// ['name', 'age', 'sayHello']: 返回对象的所有实例成员
console.log(Object.getOwnPropertyNames(obj));
// ['age', 'sayHello']: 返回对象的所有可枚举成员
console.log(Object.key(obj));
```

## Array
### 判断一个变量是数组还是对象
typeof?
```js
var a = [1, 2, 3];
typeof a; // object
```
所以使用typeof运算符并不能直接判断一个变量是对象还是数组类型。实际上，typeof运算符在判断基本数据类型时会很有用，但是在判断引用数据类型时，却显得很吃力。
#### instanceof 
> 用于通过查找原型链来检测某个变量是否为某个类型数据的实例，使用instanceof运算符可以判断一个变量是数组还是对象。
```js
var a =  [1, 2, 3];
console.log(a instanceof Array);  // true
console.log(a instanceof Object); // true

var b = { name: 'ming' };
console.log(b instanceof Array);  // false
console.log(b instanceof Object); // true
```
数组不仅是Array类型的实例，也是Object类型的实例。
-
在判断一个变量是数组还是对象时，应该先判断数组类型，然后再去判断对象类型。

封装函数
```js
function getDataType(o) {
  if (o instanceof Array) {
    return 'Array';
  } else if (o instanceof Object) {
    return 'Object';
  } else {
    return 'param is not object type';
  }
}
```
虽然使用instanceof运算符可以解决这个问题，但是instanceof运算符存在一定的缺陷

#### 判断构造函数🔆
判断一个变量是否是数组或者对象，从另一个层面讲，就是判断变量的构造函数是Array类型还是Object类型
因为一个对象的实例都是通过构造函数生成的，所以，我们可以直接判断一个变量的constructor属性。
```js
var a = [1, 2, 3];
console.log(a.constructor === Array); // true
console.log(a.constructor === Object); // false

var b = { name: 'ming' };
console.log(b.constructor === Array);  // false
console.log(b.constructor === Object); // true
```
那么一个变量为什么会有constructor属性呢？
每个变量都会有一个**__proto__**属性，表示的是**隐式原型**。一个对象的隐式原型指向的是构造该对象的构造函数的原型
```js
[].__proto__ === [].constructor.prototype; // true
[].__proto__ === Array.prototype; // true
```
使用隐式原型链改写
```js
var a = [1, 2, 3];
console.log(a.__proto__.constructor === Array); // true
console.log(a.__proto__.constructor === Object); // false
```
封装函数
```js
function getDataType(o) {
  var constructor = o.__proto__.constructor || o.constructor;
  if(constructor === Array) {
    return 'Array';
  } else if(constructor === Object){
    return 'Object';
  } else {
    return 'param is not object type';
  }
} 
```
早期的IE浏览器并不支持__proto__属性，因此这并不是一个解决问题的完美方案。

#### toString()
每种引用数据类型都会直接或间接继承自Object类型，因此它们都包含toString()函数。

不同数据类型的toString()函数返回值也不一样，所以通过toString()函数就可以判断一个变量是数组还是对象。

借助call()函数，直接调用Object原型上的toString()函数，把主体设置为需要传入的变量，然后通过返回值进行判断。

```js
var a = [1, 2, 3];
var b = { name: 'ming' };
console.log(Object.prototype.toString.call(a)); // [Object Array]
console.log(Object.prototype.toString.call(b)); // [Object Object]
// 其实任何类型的变量在调用toString()函数时，都会返回不同的结果。
Object.prototype.toString.call(1);  // [object Number]
Object.prototype.toString.call('ming'); // [object String]
var c;
Object.prototype.toString.call(c);  // [object undefined]
```
封装函数
```js
function getDataType(o) {
  var result = Object.prototype.toString.call(o);
  if (result === '[object Array]') {
    return 'Array';
  } else if (result === '[object Object]') {
    return 'Object'
  } else {
    return 'param is not object type';
  }
}
```

#### Array.isArray()💥
在JavaScript 1.8.5版本中，数组增加了一个isArray()静态函数，用于判断变量是否为数组。
```js
// 下面的函数调用都返回“true”
Array.isArray([]);
Array.isArray([1]);
Array.isArray(new Array());
// 鲜为人知的事实：其实 Array.prototype 也是一个数组。
Array.isArray(Array.prototype);
 
// 下面的函数调用都返回“false”
Array.isArray();
Array.isArray({});
Array.isArray(null);
Array.isArray(undefined);
Array.isArray(17);
Array.isArray('Array');
Array.isArray(true);
```
使用Array.isArray()函数只能判断出变量是否为数组，并不能确定是否为对象。


### filter(() => {})
> 用于过滤出满足条件的数据，返回一个新的数组，**不会改变原来的数组**
() => { true(保留) ✅ false(舍弃) ❌ }
如果没有符合条件的值则返回空数组。

#### 找寄数
```js
var filterFn = function (x) {
  return x % 2;
}
var arr = [1, 2, 4, 5, 6, 9, 10 ,15];
var result = arr.filter(filterFn);
console.log(result); // [1. 5, 9, 15]
```

#### 年龄大于18岁的男生
```js
var arrObj = [{
   gender: '男',
   age: 20
}, {
   gender: '女',
   age: 19
}, {
   gender: '男',
   age: 14
}, {
   gender: '男',
   age: 16
}, {
   gender: '女',
   age: 17
}];
var filterFn = function(obj) {
  return obj.gender ==== '男' && obj.age > 18;
}
```

### reduce()🎉🎉🎉
> arr.reduce(callback[, initialValue]);

最主要的作用是做累加处理，即接收一个函数作为累加器，将数组中的每一个元素从左到右依次执行累加器，返回最终的处理结果。

#### 求和
```js
var arr = [1, 2, 3, 4, 5];
var sum = arr.reduce(function (accumulator, currentValue) {
  return accumulator + currentValue;
}, 0);
console.log(sum);
```

#### 统计数组中每个元素出现的次数
```js
var arr = [1, 2, 3, 2, 2, 5, 1];
var res = arr.reduce(function(accumulator, current) {
  // if (current.hasOwnProperty(accumulator)) {❌
  if (accumulator[current]) {
    // current.accumulator += 1;❌
    accumulator[current]++;
  } else {
    // current.accumulator = 1;❌
    accumulator[current] = 1;
  }
  return accumulator;
}, {})
console.log(res);

var res = arr.reduce(function(accumulator, currentValue) {
  accumulator[currentValue] ? 
  accumulator[currentValue]++ :
  accumulator[currentValue] = 1;
  return accumulator;
}, {});
console.log(res);
```

#### 多维度统计数据🧨
美元欧元换算
美元汇率为1:0.1478，人民币：欧元汇率为1:0.1265。通过一定的算法，需要计算出这些人民币值对应的美元是23.792，对应的欧元是20.240。将一组人民币的值分别换算成美元和欧元的等量值。
```js
var reducer = {
  totallnEuros: function(state, item) {
    return state.euros += item.price * 0.1265;
  },
  totallnDollars: function(state, item) {
    return state.dollars += item.price * 0.1487;
  }
}

var manageReducers = function(reducers) {
  return function(state, item) {
    return Object.keys(reducers).reduce(
      function(nextState, key) {
        reducers[key](state, item);
        return state;
      },
      {}
    );
  }
};

var bigTotalPriceReducer = manageReducers(reducers);
var initialState = { euros: 0, dollars: 0 };
var totals = items.reduce(bigTotalPriceReducer, initialState);
console.log(totals);
```

### 最大最小值
#### 通过prototype属性扩展min函数和max函数
```js
// min
Array.prototype.min = function() {
  var ming = this[0];
  var len = this.length;
  for (var i = 1; i < len; i++) {
    if (this[i] < min) {
      min = this[i];
    }
  }
  return min;
}
// max
Array.prototype.max = function() {
  var max = this[0];
  var len = this.length;
  for (var i = 1; i < len; i++) {
    if (this[i] > max) {
      max = this[i];
    }
  }
  return max;
}
var arr1 = [2, 4, 10, 7, 5, 8, 6];
console.log(arr1.min()); // 2
console.log(arr1.max()); // 10
```

#### 借助Math对象的min()和max()函数
```js
Array.max = function(array) {
  return Math.max.apply(Math, array);
}
Array.min = function(array) {
  return Math.min.apply(Math, array);
}
var arr1 = [2, 4, 10, 7, 5, 8, 6];
console.log(arr1.min()); // 2
console.log(arr1.max()); // 10
```

#### 优化上一个
> 将min()函数和max()函数作为Array类型的静态函数，但并不支持链式调用，我们可以利用对象字面量进行简化。
```js
Array.prototype.max = function() {
  return Math.max.apply({}, this);
}
Array.prototype.min = function() {
  return Math.min.apply({}, this);
}
// 与上一个算法不同的是，在验证时因为min()函数和max()函数属于实例方法，所以可以直接通过数组调用。
var arr3 = [2, 4, 10, 7, 5, 8, 6];
console.log(arr3.min());  // 2
console.log(arr3.max());  // 10
```
上面的算法代码中apply()函数传入的第一个值为{}，实际表示当前执行环境的全局对象。第二个参数this指向需要处理的数组。

由于apply()函数的特殊性，我们还可以得到其他几种实现方法。将apply()函数的第一个参数设置为null、undefined或{}都会得到相同的效果。
```js
// 最大值
Array.prototype.max = function() {
   return Math.max.apply(null, this);
 };
// 最小值
Array.prototype.min = function() {
   return Math.min.apply(null, this);
};
```

#### 借助Array类型的reduce()函数
reduce()函数不设置initialValue初始值，将数组的第一个元素直接作为回调函数的第一个参数，依次与后面的值进行比较。当需要找最大值时，每轮累加器返回当前比较中大的值；当需要找最小值时，每轮累加器返回当前比较中小的值。

```js
Array.prototype.max = function () {
  return this.reduce(function (preValue, curValue) {
    return preValue > curValue ? preValue : curValue;
  });
}
Array.prototype.min = function () {
  return this.reduce(function (preValue, curValue) {
    return preValue > curValue ? curValue : preValue;
  });
}

var arr4 = [2,4,10,7,5,8,6];
console.log(arr4.min()); // 2
console.log(arr4.max()); // 10
```

#### 借助Array类型的sort()函数
借助数组原生的sort()函数对数组进行排序，排序完成后首尾元素即是数组的最小、最大元素。

默认的sort()函数在==排序时是按照字母顺序排序的，数字都会按照字符串处理==。

默认排序是将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序。

例如数字11会被当作"11"处理，数字8会被当作"8"处理。
在排序时是按照字符串的每一位进行比较的，因为"1"比"8"要小，所以"11"在排序时要比"8"小。
对于数值类型的数组来说，这显然是不合理的，所以需要我们自定义排序函数。
```js
var sortFn = function(a, b) {
  return a - b;
};
var arr5 = [2, 4, 10, 7, 5, 8, 6];
var sortArr = arr5.sort(sortFn);
// 最小值
console.log(sortArr); // 2
// 最大值
console.log(sortArr[sortArr.length - 1]); // 10
```

#### 借助ES6的扩展运算符
ES6中增加的扩展运算符（...），将数组直接通过Math.min()函数与Math.max()函数的调用，找出数组中的最大值和最小值。
```js
var arr6 = [2, 4, 10, 7, 5, 8 , 6];
console.log(Math.min(...arr6)); // 最小值
console.log(Math.max(...arr6)); // 最大值
```

### 数组遍历的7种方法及兼容性处理（polyfill）
#### for
```js
var arr1 = [11, 22, 33];
for (var i = 0; i < arr1.length; i++) {
  console.log(arr1[i]);
}
// 11 22 33
```

#### forEach
```js
var arr2 = [11, 22, 33];
arr2.forEach(function(element, index, array) {
  console.log(element);
})
// 11 22 33
```
> forEach()函数是在ES5中新添加的，它可能不兼容只支持低版本JS的浏览器，这里我们提供一个polyfill来实现。

通过for循环，在循环中判断this对象，即数组本身是否包含遍历的索引。如果包含则利用call()函数去调用回调函数，传入回调函数所需要的参数。
```js
Array.prototype.forEach = Array.prototype.forEach || function (fn, context) {
  for (var k = 0, length = this.length; k < length; k++) {
    if (typeof fn === 'function' && Object.prototype.hasOwnProperty.call(this, kk)) {
      fn.call(context, this[k], k, this);
    }
  }
};
```

#### map
将一个数组中的每个元素都做平方运算
```js
var arr3 = [1, 2, 3];
var arrayOfSquares = arr3.map(function (element) {
  return element * element;
})
console.log(arrayOfSquares);
```
同forEach()函数一样，map()函数同样需要提供polyfill的处理。

map()函数最终会在运算后得到一个新的数组。只需要事先定义一个数组，在循环中通过call()函数调用回调函数得到返回值，将这个返回值push到数组中，最后返回这个数组即可。
```js
Array.prototype.map = Array.prototype.map || function (fn, context) {
  var arr = [];
  if (typeof fn === 'function') {
    for (var k = 0, length = this.length; k < length; k++) {
      if (typeof fn === 'function' && Object.prototype.hasOwnProperty.call(this, k)) {
        arr.push(fn.call(context, this[k], k, this));
      }
    }
  }
  return arr;
}
```

#### filter
```js
Array.prototype.filter = Array.prototype.filter || function (fn, context) {
  var arr = [];
  if (typeof fn === 'function') {
    for (var k = 0, length = this.length; k < length; k++) {
      if (typeof fn === 'function' && Object.prototype.hasOwnProperty.call(this, k)) {
        fn.call(context, this[k], k, this) && arr.push(this[k]);
      }
    }
  }
  return arr;
}
```

#### some()与every()
- some()函数只要数组中**某个**元素满足条件就返回“true”
- every()函数是数组中**每个**元素都要满足条件时才返回“true”

```js
function isBigEnough(element, index, array) {
  return element > 4;
}

var passed1 = [1,2,3,4].some(isBigEnough); // false
var passed2 = [1,2,3,4, 5].some(isBigEnough); // true

var passed3 = [2,3,4].every(isBigEnough); // false
var passed4 = [5, 6].every(isBigEnough); // true
```
some()函数与every()函数的兼容性处理很类似。
some()函数是对true的判断，如果某个处理返回了“true”，则直接返回“true”，否则返回最后一次迭代的结果。
而every()函数是对false的判断，如果某个处理返回了“false”，则最终返回“false”，否则返回最后一次迭代的结果。
```js
Array.prototype.some = Array.prototype.some || function(fn, context) {
  var passed = false;
  if (typeof fn === 'function' && Object.prototype.hasOwnProperty.call(this, k)) {
    for (var k = 0, length = this.length; k < length; k++) {
      if (passed === true) break;
      passed = !!fn.call(context, this[k], k, this);
    }
  }
  return passed;
}

Array.prototype.every = Array.prototype.every || function(fn, context) {
 var passed = true;
  if (typeof fn === 'function' && Object.prototype.hasOwnProperty.call(this, k)) {
    for (var k = 0, length = this.length; k < length; k++) {
      if (passed === false) break;
      passed = !!fn.call(context, this[k], k, this);
    }
  }
  return passed;
}
```

#### [reduce](#借助Array类型的reduce()函数)
```js
Array.prototype.reduce = Array.prototype.reduce || function(callback, initialValue) {
  var previous = initialValue, k = 0, length = this.length;
  if (typeof initialValue === 'undefined') {
    previous = this[0];
    k = 1;
  }
  if (typeof callback === 'function') {
    for (k; k < length, k++) {
      this.hasOwnProperty(k) && (pervious = callback(previous, this[k], k, this));
    }
  }
  return previous;
}
```

#### find
```js
var value = [1, 5, 10, 15].find(function (element, index, array) { return element > 9; }); // 10
var value2 = [1, 5, 10, 15].find(function (element, index, array) { return element > 92; }); // undefined
```
find()函数和前面其他函数的polyfill实现方法一样，只需修改返回值即可。
```js
Array.prototype.find = Array.prototype.find || function(fn, context) {
  if(typeof fn === 'function') {
    for (var k = 0, length = this.length; k < length; k++) {
      if (fn.call(context, this[k], k, this)) {
        return this[k];
      }
    }
  }
  // 这句是无用
  // return undefined
}
```

### 数组去重的7种算法
#### 遍历数组
在函数内部新建一个数组，对传入的数组进行遍历。如果遍历的值不在新数组中就添加进去，如果已经存在就不做处理。
```js
function arrayUnique(array) {
  var result = [];
  for (var i = 0; i < array.length; i++) {
    if (result.indexOf(array[i]) === -1) {
      result.push(array[i]);
    }
  }
  return result;
}
```

#### 利用对象键值对
新建一个JS对象以及一个新的数组，对传入的数组进行遍历，判断当前遍历的值是否为JS对象的键。如果是，表示该元素已出现过，则不做处理；如果不是，表示该元素第一次出现，则给该JS对象插入该键，同时插入新的数组，最终返回新的数组。
```js
function arrayUnique2(array) {
  var obj = {}, result = [], val, type;
  for (var i = 0; i < array.length; i++) {
    val = array[i];
    if (!obj[val]) {
      obj[val] = 'yes';
      result.push(val);
    }
  }
  return result;
}
```
缺陷算法：会将字符串1和数字1识别为相同的KEY
```js
function arrayUnique2(array) {
  var obj = {}, result = [], val, type;
  for (var i = 0; i < array.length; i++) {
    val = array[i];
    type = typeof val;
    if (!obj[val]) {
      obj[val] = [type];
      result.push(val);
    } else if (obj[val].indexOf(type) < 0) {
      obj[val].push(type);
      result.push(val);
    }
  }
  return result;
}
```
#### 先排序，再去重
```js
function arrayUnique3(array) {
  var result = [array[0]];
  array.sort(function(a, b){ return a - b });
  for (var i = 0; i < array.length; i++) {
    if (array[i] !== result[result.length - 1]) {
      result.push(array[i]);
    }
  }
  return result;
}
```
#### 优先遍历数组
```js
function arrayUnique3(array) {
  var result = [];
  for (var i = 0, l = array.length; i < array.length; i++) {
    for (var j = i + 1; i < l; j++) {
      if (array[i] === array[j]) {
        j = ++i;
      }
    }
    result.push(array[i]);
  }
  return result;
}
```

#### reduce
```js
function arrayUnique5(array) {
  var obj = {}, type;
  return array.reduce(function (preValue, curValue) {
    type = typeof curValue;
    if (!obj[curValue]) {
      obj[curValue] = [type];
      preValue.push(curValue);
    } else if (obj[curValue].indexOf(type) < 0) {
      obj[curValue].push(type);
      preValue.push(curValue);
    }
    return preValue;
  }, [])
}
```

#### 借助ES6的Set数据结构
在ES6中，Set成员唯一，具有自动去重的功能。Array类型增加了一个from()函数，用于将类数组对象转化为数组。
```js
function arrayUnique6(array) {
  return Array.from(new Set(array));
}
```

#### 借助ES6的Map数据结构
```js
function arrayUnique7(array) {
  var map = new Map();
  return array.filter(item => !map.has(item) && map.set(item, 1));
}
```

### 找出数组中出现次数最多的元素
#### 利用键值对
```js
function findMost1(arr) {
  if (!arr.length) return;
  if (arr.length === 1) return 1;
  var res = {};
  for (var i = 0, l = arr.length; i < l; i++) {
    if (!res[arr[i]]) {
      res[arr[i]] = 1;
    } else {
      res[arr[i]]++;
    }
  }
}
var keys = Object.keys(res);
var maxNum = 0, maxEle;
for (var i = 0, l = keys.length; i < l; i++) {
  if (res[keys[i]] > maxNum) {
    maxNum = res[keys[i]];
    maxEle = keys[i];
  }
  return '出现次数最多的元素为：' + maxEle + ', 出现次数为：' + maxNum;
}

var arr1 = [3, 5, 6, 5, 9, 8, 10, 5, 7, 7, 10, 7, 7, 10, 10, 10, 10, 10];
console.log(findMost1(arr1));
```

#### 优化上面
```js
function findMost2(arr) {
  var h = {};
  var maxNum = 0;
  var maxEle = null;
  for (var i = 0; i < arr.length; i++) {
    var a = arr[i];
    h[a] === undefined ? h[a] = 1 : (h[a]++);
    if (h[a] > maxNum) {
      maxEle = a;
      maxNum = h[a];
    }
  }
  return '出现次数最多的元素为：' + maxEle + ', 出现次数为：' + maxNum;
}
var arr2 = [3, 5, 6, 5, 9, 8, 10, 5, 7, 7, 10, 7, 7, 10, 10, 10, 10, 10];
console.log(findMost2(arr2));
```
> 谈谈区别？

#### reduce()函数
```js
function findMost3(arr) {
  var maxEle;
  var maxNum = 1;
  var obj = arr.reduce(function(p, k){
    p[k] ? p[k]++ : p[k] = 1;
    if (p[k] > maxNum) {
      maxEle = k;
      maxNum++;
    }
    return p;
  }, {});
  return '出现次数最多的元素为：' + maxEle + ', 出现次数为：' + obj[maxEle];
}
var arr3 = [3, 5, 6, 5, 9, 8, 10, 5, 7, 7, 10, 7, 7, 10, 10, 10, 10, 10];
console.log(findMost3(arr3));
```
#### 借助ES6与逗号运算符进行上面的代码优化🎇
```js
Array.protocol.getMost4 = function () {
  var obj = this.reduce((p, n) => 
    (p[n]++ || (p[n] = 1), (p.max = p.max >= p[n] ? p.max : p[n]),
    (p.key = p.max > p[n] ? p.key : n), p),    
  {});
  return '出现次数最多的元素为：' + obj.key + ', 出现次数为：' + obj.max;
}
var arr4 = [3, 5, 6, 5, 9, 8, 10, 5, 7, 7, 10, 7, 7, 10, 10, 10, 10, 10];
console.log(arr4.getMost4());
```

## Date
### 日期格式化
日期格式化的主要目的是以对用户友好的形式，将日期、时间等数据展示出来。
例如2018年7月31日12点23分34秒，常见的展示形式为“2018-07-31 12:23:34”，

下面将展示3种实现方法。
#### 基于严格的时间格式解析
```js
/**
  * 方法1
  * @description 对Date的扩展，将 Date 转换为指定格式的String
  *  月(MM)、日(dd)、小时(HH)、分(mm)、秒(ss)固定用两个占位符
  *  年(yyyy)固定用4个占位符
  * @param fmt
  * @example 
  *   (new Date()).format("yyyy-MM-dd HH:mm:ss") // 2018-07-31 20:09:04
  *   (new Date()).format("yyyy-MM-dd") // 2018-07-31 20:08
  * @returns {*}
  */
Date.prototype.format = function(pattern) {
  function zeroize(num) {
    return num < 10 ? "0" + num : num;
  }
  var pattern = pattern;
  var dateObj = {
    "y": this.getFullYear(),
    "M": zeroize(this.getMonth() + 1),
    "d": zeroize(this.getDate()),
    "H": zeroize(this.getHour()),
    "m": zeroize(this.getMinutes()),
    "s": zeroize(this.getSeconds())
  };
  return pattern.replace(/yyyy|MM|dd|HH|mm|ss/g, function(match) {
    switch(match) {
      case "yyyy": 
        return dateObj.y;
      case "MM":
        return dateObj.M;
      case "dd": 
        return dateObj.d;
      case "HH":
        return dateObj.H;
      case "mm":
        return dateObj.m;
      case "ss":
        return dateObj.s;
    }
  })
}
var d = new Date();
console.log(d.format('yyyy-MM-dd HH:mm:ss')); // 2017-11-26 15:50:00
console.log(d.format('yyyy-MM-dd')); // 2017-11-26
console.log(d.format('yyyy-MM-dd HH:mm')); // 2017-11-26 15:50
```

#### 优化上面
```js
/**
  * 方法2
  * @description 对Date的扩展，将 Date 转换为指定格式的String
  *  月(M)、日(d)、小时(H)、分(m)、秒(s)、季度(q) 可以用 1~2 个占位符，
  *  年(y)可以用 1~4 个占位符，毫秒(S)只能用 1 个占位符(是 1~3 位的数字)
  * @param fmt
  * @example    
  * * (new Date()).format("yyyy-MM-dd HH:mm:ss") // 2018-07-31 20:09:04
  *   (new Date()).format("yyyy-M-d H:m")  // 2018-07-31 20:09
  * @returns {*}
  */
Date.prototype.format = function (fmt) {
   var o = {
       "M+": this.getMonth() + 1, //月份
       "d+": this.getDate(), //日
       "H+": this.getHours(), //小时
       "m+": this.getMinutes(), //分
       "s+": this.getSeconds(), //秒
       "q+": Math.ﬂoor((this.getMonth() + 3) / 3), //季度
       "S": this.getMilliseconds() //毫秒
   };
   if (/(y+)/.test(fmt))
     fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
   for (var k in o)
       if (new RegExp("(" + k + ")").test(fmt))
         fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length)));
   return fmt;
};

var d = new Date();
console.log(d.format('yyyy-MM-dd HH:mm:ss.S')); // 2017-11-26 14:46:13.894
console.log(d.format('yyyy-MM-dd')); // 2017-11-26
console.log(d.format('yyyy-MM-dd q HH:mm:ss')); // 2017-11-26 4 14:46:13
```

#### Moment.js
Moment.js有多种不同的安装方法。
```bash
bower install moment --save  # bower
npm install moment --save    # npm
Install-Package Moment.js    # NuGet
spm install moment --save    # spm
meteor add moment:moment     # meteor
```
Moment.js主要通过传递不同的字符串格式来输出对应的时间。
```js
moment().format('MMMM Do YYYY, h:mm:ss a'); // 七月 31日 2018, 10:33:34 晚上
moment().format('dddd');                    // 星期二
moment().format("MMM Do YY");               // 7月 31日 18
moment().format('YYYY [escaped] YYYY');     // 2018 escaped 2018
```

### 日期合法性校验
真实场景如下所述。
假如需要用户输入产品的保质期时，输入的值为2018-09-40，那么将返回“false”，因为9月份不存在40号，它是一个非法的日期数据。

校验日期合法性的主要思想是利用正则表达式，将正则表达式按分组处理，匹配到不同位置的数据后，得到一个数组。利用数组的数据构造一个Date对象，获得Date对象的年、月、日的值，再去与数组中表示年、月、日的值比较。如果都相等的话则为合法的日期，如果不相等的话则为不合法的日期。

例如，给定一个日期值2018-09-40，将年、月、日的值构造成一个新的Date对象，即new Date(2018, 9, 40)，返回的实际Date值是“2019-10-09”。在判断的时候，月份值09!==10，是一个非法的日期值。
```js
function validateDate(str) {
  var reg = /^(\d+)-(\d{1,2})-(\d{1,2})$/;
  var r = str.match(reg);
  if (r == null) return false;
  r[2] = r[2] - 1;
  var d = new Date(r[1], r[2], r[3]);
  if (d.getFullYear() != r[1]) return false;
  if (d.getMonth() != r[2]) return false;
  if (d.getDate() != r[3]) return false;
  return true;
}
console.log(validateDate ('2018-08-20'));  // true
console.log(validateDate ('2018-08-40'));  // false
```

### 日期计算
比较日期大小、计算当前日期前后N天的日期、计算两个日期的时间差。

#### 比较日期大小
真实场景如下所述。
  一个开始时间为2018-07-31 7:30，一个结束时间为2018-08-01 8:30，需要判断开始时间是否在结束之间之前。

日期大小比较的主要思想是在JavaScript中，以斜线（/）作为分隔符的时间类型字符串，可以直接转换为Date类型对象并直接进行比较，即对于“2018-07-31 7:30”与“2018-08-018:30”，可以直接判断出前者比后者要小。

常用的作为时间类型字符串分隔符的有斜线（/）和短横线（-），但是不同的浏览器支持的程度不同，**为了最大化兼容不同浏览器的特性，统一使用斜线作为时间类型字符串的分隔符**。

```js
function CompareDate(dateStr1, dateStr2) {
  var date1 = dateStr1.replace(/-/g, '\/');
  var date2 = dateStr2.replace(/-/g, '\/'); 
  return new Date(date1) > new Date(date2);
}
var dateStr1 = "2018-07-30 7:31";
var dateStr2 = "2018-07-31 7:30";
var dateStr3 = "2018-08-01 17:31";
var dateStr4 = "2018-08-01 17:30";
CompareDate(dateStr1, dateStr2);  // false
CompareDate(dateStr3, dateStr4);  // true
```

#### 计算当前日期前后N天的日期
真实场景如下所述。

  假如知道一个日期为2018-08-01，需要求出该时期前、后3天的日期。前3天日期为2018-07-29，后3天日期为2018-08-04。

获取前后N天的日期的主要思想是对date值的设置，在Date对象的实例函数中提供setDate()函数，用于设置日期值。对返回时间的格式进行处理，月份与日期不够10的补充0，标签字符串如2018-08-01这种格式的字符串。

```js
function GetDateStr(AddDayCount) {
  var dd = new Date();
  dd.setDate(dd.getDate() + AddDayCount); // 获取AddDayCount天后的日期
  var y = dd.getFullYear();
  // 获取当前月份的日期，不足10补0
  var m = (dd.getMonth() + 1) < 10 ? "0" + (dd.getMonth() + 1) : (dd.getMonth() + 1);
  var d= dd.getDate() < 10 ? "0" + dd.getDate() : dd.getDate(); // 获取当前几号，不足10补0
  return y + "-" + m + "-" + d;
}
```
然后通过一系列的情况进行测试，例如半年前、3个月前、昨天、今天、明天、1个月后等。
```js
console.log("半年前：" + GetDateStr(-180)); // 半年前：2018-02-02
console.log("三月前：" + GetDateStr(-90));  // 三月前：2018-05-03
console.log("一月前：" + GetDateStr(-30));  // 一月前：2018-07-02
console.log("昨天：" + GetDateStr(-1));     // 昨天：2018-07-31
console.log("今天：" + GetDateStr(0));      // 今天：2018-08-01
console.log("明天：" + GetDateStr(1));      // 明天：2018-08-02
console.log("后天：" + GetDateStr(2));      // 后天：2018-08-03
console.log("一月后：" + GetDateStr(30));   // 一月后：2018-08-31
console.log("三月后：" + GetDateStr(90));   // 三月后：2018-10-30
console.log("半年后：" + GetDateStr(180));  // 半年后：2019-01-28
```

#### 计算两个日期的时间差
真实场景如下所述。
  给定两个日期值2018-07-30 18:12:34和2018-08-0120:17:30，需要确定这两个时间在不同维度的时间差。例如以天的维度，两者相差2天；以小时的维度，两者相差39小时。

设计的规则是向下取整法。大于1天，不满2天的按照1天处理；大于1小时，不满2小时的按照1小时处理。

```js
function GetDateDiff(startTime, endTime, diffType) {
  // 将yyyy-MM-dd的时间格式转换为yyyy/MM/dd的时间格式
  startTime = startTime.replace(/\-/g, "/");
  endTime = endTime.replace(/\-/g, "/");
  // 将计算间隔类型字符转换为小写
  diffType = diffType.toLowerCase();
  var sTime = new Date(startTime);
  var eTime = new Date(endTime);
  // 作为除数的数字
  var divNum = 1;
  switch (diffType) {
    case "second":
      divNum = 1000;
      break;
    case "minute":
      divNum = 1000 * 60;
      break;
    case "hour":
      divNum = 1000 * 3600;
      break;
    case "day":
      divNum = 1000 * 3600 * 24;
      break;
    default:
      break; 
  }
  return parseInt((eTime.getTime() - sTime.getTime()) / parseInt(divNum));
}
var result1 = GetDateDiﬀ("2018-07-30 18:12:34", '2018-08-01 9:17:30', "day");
var result2 = GetDateDiﬀ("2018-07-29 20:56:34", '2018-08-01 9:17:30', "hour");
console.log("两者时间差为：" + result1 + "天。");
console.log("两者时间差为：" + result2 + "小时。");
```