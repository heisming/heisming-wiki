# 内置组件

## component
动态组件：某些场景中需要动态切换页面部分区域的视图。
用法：component接收一个名为is的属性，is的值在父组件中注册过的组件的名称
```vue
<component :is="view"></component>
```
Demo:
```html
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hi~vue</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.2.37/vue.global.js"></script>
    <style>
      .tabs {
        margin: 0;
        padding: 0;
        list-style: none;
      }
      .per-tab {
        display: inline-block;
        width: 120px;
        line-height: 32px;
        border-left: 1px solid #ccc;
        border-top: 1px solid #ccc;
      }
      .per-tab:last-child {
        border-right: 1px solid #ccc;
      }
      .tab-content {
        height: 240px;
        border: 1px solid #ccc;
      }
    </style>
</head>
<body>
  <div id="app">
    <ul>
      <li class="per-tab" @click="toggleView('Home')">Home</li>
      <li class="per-tab" @click="toggleView('About')">About</li>
    </ul>
    <div class="tab-content">
      <component :is="view"></component>
    </div>
  </div>
</body>
<script type="text/javascript">
  // Home组件
  let Home = {
    template: `<p style="color: #787878;">Hello Home!</p>`
  }
  let About = {
    template: `<p>Hello About!</p>`
  }
  const app = Vue.createApp({
    components: { Home, About },
    data () {
      return {
        view: 'Home',
      }
    },
    methods: {
      toggleView(view) {
        this.view = view
      }
    },
  })
  app.mount('#app')
</script>
</html>
```
上述代码中，定义了Home和About两个组件，并使用了component选项将其注册到Vue实例中。

## slot
数据：通过props选项，组件可以接收多态的数据。
组件接收多态的DOM结构
 - 使用props配合v-html
 - 插槽
在定义多个插槽时，可以使用name属性对其进行区分。如果没有name，Vue会将所有的插槽内容置于默认插槽中。
```html
<div id="app">
 <slot-test>
  <p>使用插槽分发内容</p>
  <h1 slot=header>插槽测试！</h1>
  <p>在组件中，没有指定插槽名称的元素将被置于默认插槽中</p>
  <p slot="none">指定到不存在的插槽中的内容将不会被显示</p>
 </slot-test>
</div>
<script>
  // V2中指定插槽名称来植入元素
  let SlotText = {
    template = `<div>`
      // 具名插槽
      `<slot name="header">相当于占位元素，因此这些文字也不会被渲染</slot>`
      // 默认插槽
      `<slot></slot>`
    `</div>`
  }
  // V3插槽名称必须通过template标签v-slot属性来定义
  <div>
    <template v-slot:header></template> // 相当于占位元素，因此这些文字也不会被渲染
    <template v-slot:default></template> 
  </div>
</script>
```
在上述代码中：为SlotText组件添加了具名插槽header和默认插槽，并在父组件中将DOM分发到不同的插槽中。

作用域插槽

```html
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hi~vue</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.2.37/vue.global.js"></script>
    <style>
      .btn {
        outline: none;
        border: none;
        cursor: pointer;
        padding: 5px 12px;
      }
      .btn-text {
        color: #409eff;
        background-color: transparent;
      }
      .btn-text:hover {
        color: #66b1ff;
      }
      .fly-table {
        width: 400px;
        text-align: left;
        line-height: 42px;
        border: 1px solid #eee;
        user-select: none;
      }
    </style>
</head>
<body>
  <div id="app">
    <h2>Fly Table Component</h2>
    <button class="btn btn-text" title="点击使数组倒序" @click="handleReverse">
    倒序
    </button>
    <fly-table
      :fields="fields"
      :goods="goods">
    <!-- 组件标签包裹着的内容将被分发 -->
    <!-- 思考：是否可以在fly-table组件中直接书写这段代码？ -->
    <template v-slot="{ row, col }">
      <span
      v-if="col.prop !== 'operate'">
        {{ row[col.prop] }}
      </span>
      <button
      class="btn btn-text" v-else @click="handleMarked(row)">
        切换标记
      </button>
    </template>
    </fly-table>
  </div>
</body>
<script type="text/javascript">
  let FlyTable = {
    // 组件接收从父组件传入的数据
    props: {
      fields: {
        type: Array,
        default () {
          return []
        }
      },
      goods: {
        type: Array,
        default () {
          return []
        }
      }
    },
    template: function() {
      return '<table class="fly-table"\n>' +
        '     <tr>\n' +
        '       <th\n' +
        '         v-for="(col, cIndex) in fields"\n' +
        '         :key="cIndex">\n' +
        '       {{ col.label }}\n' +'</th>\n' +
              '</tr>' + 
        '     <tr\n' + 
        '     v-for="(row, rIndex) in goods"\n' + 
        '     :key="rIndex"\n' + 
        '     :style="{ color: row.isMarked ? \'#ea4335\' : \'\'}">\n' +
        '     <td\n' + 
        '     style="border-top: 1px solid #eee"\n' +
        '     v-for="(col, cIndex) in fields"\n' +
        '     :key="cIndex">\n' + 
        // style应写在子组件中，用于接收父组件分发的内容
        ' <slot :row="row" :col="col"></slot>\n' + '</td>\n' +
        ' </tr>\n' + 
        ' </table>'
    }()
  }
  const app = Vue.createApp({
    components: { FlyTable },
    data () {
      return {
        fields : [
          { label: '名称', prop: 'name' },
          { label: '数量', prop: 'quantity' },
          { label: '价格', prop: 'price' },
          { label: '操作', prop: 'operate' },
        ],
        goods : [
          { name : '苹果', quantity: 200, price: 6.8, isMarked: false },
          { name : '西瓜', quantity: 50, price: 4.8, isMarked: false },
          { name : '榴莲', quantity: 100, price: 22.8, isMarked: false },
        ]
      }
    },
    methods: {
      handleReverse () {
        this.goods.reverse()
      },
      handleMarked (row) {
        row.isMarked = !row.isMarked
      }
    },
  })
  app.mount('#app')
</script>
</html>
```
上述代码中：定义了fly-table组件，它接收fields和goods属性，用于动态显示表格数据。
调用fly-table组件时，还提供了倒序数组的而功能并使用v-slot根据数据的不同进行多态的视图渲染。


# keep-alive
一个抽象组件，即它既不渲染任何DOM元素，也不会出现在组件结构树中。可以使用它缓存一些非动态的组件实例（没有或不需要数据变化），以保留组件状态或减少重新渲染的开销。

应出现在组件被移除之后需要再次挂载的地方如使用动态组件时：
```vue
<keep-alive>
  <component :is="view"></component>
</keep-alive>
```
或者使用v-if时：
<keep-alive>
  <one v-if="isOne"></one>
  <two v-else></two>
</keep-alive>

它还可以接收include和exclude两个props属性：
- include字符串或正则表达式。只有匹配的组件会被缓存。
- exclude字符串或正则表达式。任何被匹配的组件将不会被缓存。
当组件在keep-alive内被切换时，它的activated和deactivated这两个生命周期钩子函数将会被执行。

# transition
单节点的过渡
Vue提供了标签为transition的内置组件。在下列情形中，可以给任何元素和组件添加进入/离开时的过渡动画。
- 元素或组件初始渲染时。
- 元素或组件显示/隐藏时（使用v-if/v-show）
- 元素或组件切换时。
Vue允许用户使用CSS和JS来定义过渡效果
使用CSS过渡时，需要预置符合Vue规则的带样式的类名，这些类名用于定义过渡不同阶段时的样式。
- v-enter-from: 定义进入过渡的开始状态。在元素被插入前生效，被插入后的下一帧移除。
- v-enter-active: 定义进入过渡生效时的状态。在整个进入过渡阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以用来定义进入过渡的过程时间、延迟和曲线函数等。
- v-leave-from: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。
- v-leave-active: 定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间、延迟和曲线函数。
- v-leave-to: (v2.1.8+)定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效（此时v-leave被移除），在过渡/动画完成之后移除。

当实例中存在多个不同的动画效果时，可以使用自定义前缀替换v-，如使用slide-enter替换v-enter-from，需要赋予transition元素name属性
```html
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hi~vue</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.2.37/vue.global.js"></script>
    <style>
      /* 在此处声明过渡样式类，从一个状态过渡到另一个状态 */
      .v-enter-from,
      .v-leave-to {
        opacity: 0;
      }
      .v-enter-active,
      .v-leave-active {
        transition-property: opacity; /* 过渡属性 */
        transition-delay: 100ms; /* 延迟 */
        transition-duration: 900ms; /* 过渡时长 */
        transition-timing-function: linear; /* 过渡时长 */
      }
      .rotate-enter-from,
      .rotate-leave-to {
        transform: rotateZ(90deg);
      }
      .rotate-enter-active,
      .rotate-leave-active {
        transform-origin: left;
        transition: transform 1s linear;
      }
    </style>
</head>
<body>
  <div id="app">
    <button @click="isHidden = !isHidden">
      {{ isHidden ? '显示' : '隐藏' }}
    </button>
    <!-- 默认前缀的过渡 -->
    <transition>
      <p v-if="!isHidden">使用默认前缀的过渡</p>
    </transition>
    <!-- 自定义前缀的过渡，transitionName为变量 -->
    <transition :name="transitionName">
      <p v-if="!isHidden">使用rotate前缀的过渡</p>
    </transition>
  </div>
</body>
<script type="text/javascript">
  const app = Vue.createApp({
    data () {
      return {
        isHidden : true,
        transitionName: 'rotate' // 如果在运行时，将transitionName改为V会怎么样？
      }
    },
  })
  app.mount('#app')
</script>
</html>
```
上述代码：定义了两种过渡效果（渐入/渐出、旋转显示/旋转隐藏），使用了默认前缀的类名和自定义前缀的类名。

示意图：
[fly-table DOM](../assets/drawio/transition.drawio ':include :type=code')


animate.css

```bash
npm install animate.css --save
```
or
```html
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
<!-- animated标识要执行动画的元素，bounce标识所要执行的动画效果，此处为弹簧效果 -->
<h1 class="animated bounce">Example</h1>
```
由于这些动画库有着不同的类名规则，无法与Vue默认的类名规则配合使用，因此Vue为其提供了兼容方案，允许用户自定义过渡的类名，这些类名的优先级高于默认的类名：
- enter-from-class
- enter-active-class
- enter-to-class
- leave-from-class
- leave-active-class
- leave-to-class
```html
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hi~vue</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.2.37/vue.global.js"></script>
    <style>
      .inline-block {
        display: inline-block;
      }
      .rotate-enter-active {
        animation: selfRotateIn 1s;
      }
      .rotate-leave-active {
        animation: selfRotateOut 1s;
      }
      /* 命名避免与Animate.css冲突 */
      @keyframes selfRotateIn {
        0% {
          opacity: 0;
          transform: rotateZ(-180deg);
        }
        100% {
          opacity: 1;
          transform: rotateZ(0deg);
        }
      }
      @keyframes selfRotateOut {
        0% {
          opacity: 1;
          transform: rotateZ(0deg);  
        }
        100% {
          opacity: 0;
          transform: rotateZ(180deg);
        }
      }
    </style>
</head>
<body>
  <div id="app">
    <button @click="isHidden = !isHidden">
      {{ isHidden ? '显示' : '隐藏' }}
    </button>
    <!-- 自定义的动画 -->
    <transition name="rotate">
      <span class="inline-block" v-if="!isHidden">自定义的动画</span>
    </transition>
    <!-- animate.css的动画 -->
    <transition 
      :name="custom"
      enter-active-class="animated rotateIn"
      leave-active-class="animated rotateOut">
      <span class="inline-block" v-if="!isHidden">animate.css动画</span>
    </transition>
  </div>
</body>
<script type="text/javascript">
  const app = Vue.createApp({
    data () {
      return {
        isHidden : true,
      }
    },
  })
  app.mount('#app')
</script>
</html>
```

上述代码：模拟了Animate.css的rotateIn和rotateOut。
在开发中，使用进入过渡便可实现初始渲染时的过渡效果。除此之外，Vue提供了专门的初始渲染过渡，需要在transition元素上添加appear属性，只支持自定义类名的过渡和JS过渡
```vue
<transition
  appear
  appear-class="custom-appear-class"
  appear-to-class="custom-appear-to-class"
  appear-active-class="custom-appear-active-class"
>
</transition>
```

Vue的元素重复策略：Vue为了更高效地更新元素，会采用“就近复用”的策略。因此，当我们需要隐藏/显示多个相邻的相同标签的元素时，并不一定所有的元素都会执行过渡，因为部分元素可能被复用了（被复用的元素不会进入/离开）。为了解决这个问题，我们需要赋予元素唯一key值，Vue会对元素进行跟踪。
反之，当元素的key值发生变化时，Vue不会复用原有的元素，而将重建新的元素，根据这一特点，可以通过改变元素的key值来触发过渡动画，这常被用在元素切换时：
```html
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hi~vue</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.2.37/vue.global.js"></script>
    <style>
      .v-enter-from,
      .v-leave-to {
        opacity: 0;
      }
      .v-enter-active,
      .v-leave-active {
        transition: opacity 1s;
      }
    </style>
</head>
<body>
  <div id="app">
    <button @click="isMaster = !isMaster">
      切换身份
    </button>
    <transition>
      <!-- 此处只写了一个p标签 -->
      <p :key="isMaster ? 'master' : 'other'">{{ isMaster ? '大家好' : '东家好！' }}</p>
    </transition>
  </div>
</body>
<script type="text/javascript">
  const app = Vue.createApp({
    data () {
      return {
        isMaster : true,
      }
    },
  })
  app.mount('#app')
</script>
</html>
```
页面初始化只有一个button和一个p标签。当点击“切换身份”按钮时，过渡中的一帧会有两个p标签。
在元素切换时，旧的元素要被隐藏，新的元素（由于key值改变，该元素是新建的）要被显示，两者过渡都需要一定的时间，且Vue默认进入和离开同时发生，因为会出现两个元素同时存在的问题。
为了解决这个问题，Vue提供了以下两种过渡模式：
- in-out: 新元素先出现，之后旧元素隐藏。
- out-in: 旧元素先隐藏，之后新元素出现。
```vue
<transition mode="out-in">
  <!-- 元素 -->
</transition>
```
可以在之前的demo使用了
```vue
    <transition mode="out-in">
      <p :key="isMaster ? 'master' : 'other'">{{ isMaster ? '大家好' : '东家好！' }}</p>
    </transition>
```
在使用out-in过渡模式时，离开过渡完成后，进入过渡才开始执行。同样。也可以在动态切换组件时使用过渡模式以实现平滑的过渡效果。
最后，关于JS过渡：不常见（了解）
```vue
<template>
  <div id="app">
    <button @click="isHidden = !isHidden">
      {{ isHidden ? '显示' : '隐藏' }}
    </button>
    <transition
    :before-enter="handleBeforeEnter"
    :enter="handleEnter"
    :after-enter="handleAfterEnter"
    :enter-cancelled="handleEnterCancelled"
    :before-leave="handleBeforeLeave"
    :leave="handleLeave"
    :after-leave="handleAfterLeave"
    :leave-cancelled="handleLeaveCancelled">
      <!-- 过渡元素 -->
    </transition>
  </div>
</template>
<script>
  const app = Vue.createApp({
    data () {
      return {
        isHidden : true,
      }
    },
    methods: {
      // Vue提供了以下钩子函数，这些钩子函数也可以结合CSS过渡和动画使用
      handleBeforeEnter(el) {},
      handleEnter(el, done) {
        // 当只用JS过渡时，在enter和leave中必须使用done进行回调
        // 否则它们将被同步调用，过渡会立即完成
        done()
      },
      handleAfterEnter(el) {},
      handleEnterCancelled(el) {},
      handleBeforeLeave(el) {},
      handleLeave(el) {},
      handleAfterLeave(el) {},
      handleLeaveCancelled(el) {},
    }
  })
  app.mount('#app')
</script>
```

## transition-group
多节点的(列表)过渡
与transition不同：
- transition-group将以真实元素呈现，通过tag属性定义其元素；
- 过渡模式不可用；
- 内部元素必须提供唯一的key属性（就近复用会导致部分过渡失效）。

```html
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hi~vue</title>
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css"> -->
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.2.37/vue.global.js"></script>
    <style>
      .list-enter-from .list-leave-to {
        opacity: 0;
        transform: translateY(30px);
      }
      .list-enter-active, .list-leave-active {
        transition: all 1s linear;
      }
    </style>
</head>
<body>
  <div id="app">
    <button @click="addNewItem()">添加元素</button>
    <br>
    <transition-group name="list" tag="ul">
      <li v-for="item in list" :key="item">{{ item }}</li>
    </transition-group>
  </div>
</body>
<script type="text/javascript">
  const app = Vue.createApp({
    data () {
      return {
        // list: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        list: [0, 1, 2, 3]
      }
    },
    methods: {
      addNewItem() {
        this.list.push(this.list.length)
      }
    }
  })
  app.mount('#app')
</script>
</html>
```
除了用于实现进出动画之外，transition-group还可以用于改变元素定位的动画，这需要用到v-move特性。v-move动画效果的定义方式与v-enter、v-leave等一致，可以帮助我们平滑地移动列表元素的位置。
```html
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hi~vue</title>
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css"> -->
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.2.37/vue.global.js"></script>
    <style>
      /* v-move */
      .list-move {
        transition: transform 1s;
      }
    </style>
</head>
<body>
  <div id="app">
    <button @click="orderByRandom()">随机顺序</button>
    <br>
    <transition-group name="list" tag="ul">
      <li v-for="item in list" :key="item">{{ item }}</li>
    </transition-group>
  </div>
</body>
<script type="text/javascript">
  const app = Vue.createApp({
    data () {
      return {
        // list: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        list: [0, 1, 2, 3, 4]
      }
    },
    methods: {
      // 随机改变数组元素的位置
      orderByRandom() {
        // 初始化新数组
        let temp = []
        for (let i = 0; i < this.list.length; i++) {
          let num = Math.floor(Math.random() * (this.list.length - 0.001))
          // 随机新元素
          // 当元素不在数组中时，将其加入到数组中
          let index = temp.indexOf(num) 
          while(index !== -1) {
            num = Math.floor(Math.random() * (this.list.length - 0.001))
            index = temp.indexOf(num)
          }
          temp.push(num)
        }
        this.list = temp
      }
    }
  })
  app.mount('#app')
</script>
</html>
```