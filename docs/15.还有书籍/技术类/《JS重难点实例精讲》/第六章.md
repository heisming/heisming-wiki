# Ajax
Ajax是目前最流行的前后端数据交互的方式，通过异步请求就可以在不需要刷新页面的情况下，达到局部刷新的效果。

Ajax并非是一种全新的技术，而是由以下技术组合而成。
- 使用CSS和XHTML做页面呈现。
- 使用DOM进行交互和动态显示。
- 使用XMLHttpRequest对象和服务器进行异步通信。
- 使用JavaScript进行绑定和调用，操作DOM。

在上面涉及的几种技术中，除了XMLHttpRequest外，其余几种都是基于Web标准并得到了广泛使用。

## 基本原理及执行过程
> 通过XMLHttpRequest对象向服务器发送异步请求，获取服务器返回的数据后，利用DOM的操作来更新页面。

[ajax原理](./assets/drowio/ajax.drawio ':include :type=code')

其中最核心的部分就是XMLHttpRequest对象。它是一个JavaScript对象，支持异步请求，可以及时向服务器发送请求和处理响应，并且不阻塞用户，达到不刷新页面的效果。

### XMLHttpRequest对象
XMLHttpRequest对象从创建到销毁存在一个完整的生命周期，在生命周期的每个阶段会调用XMLHttpRequest对象的不同函数，在函数中需要通过XMLHttpRequest对象的特定属性来判断函数执行情况。
#### XMLHttpRequest对象的函数
##### abort()函数
如果请求已经发送，则停止当前请求。
##### getAllResponseHeaders()函数
获取所有HTTP请求的响应头部，作为键值对返回；如果没有收到响应，则返回“null”。
##### getResponseHeader("key")函数
获取指定key的HTTP响应头，如果没有收到响应或者响应中不存在key对应的报头，则返回“null”。
##### open函数
建立对服务器的调用。
```js
open("method","URL",[asyncFlag],["userName"],["password"])
```
- method参数表示请求方式，可以为GET、POST或者PUT。
- URL参数表示请求的路径，可以是相对路径，也可以是绝对路径。
- 后面3个是可选参数，分别表示是否异步、用户名、密码。
  - 其中`asyncFlag = true`表示异步，`asyncFlag = false`表示同步，默认值为true。
##### send(content)函数
向服务器发送请求。
##### setRequestHeader(“key”, “value”)函数
设置请求头中属性为key的值为value。在设置请求头之前需要先调用open()函数，设置的header将随着send()函数一起发送。
#### XMLHttpRequest对象的属性
##### onreadystatechange
状态改变的事件触发器，每个状态改变时都会触发这个事件处理器，通常会调用一个JavaScript函数。
##### readyState
请求的状态，有5个可取的值。
- 0. 未初始化，XMLHttpRequest对象已创建。
- 1. open()函数已调用，send()函数未调用，请求还未发送。
- 2. send()函数已调用，HTTP请求已发送到服务器，未接收到响应。
- 3. 所有响应头接收完成，响应体开始接收但未完成。
- 4. HTTP响应接收完成。
##### responseText
接收的数据文本格式的服务器响应体（不包括响应头）。
##### responseXML
服务器的响应，兼容DOM的XML对象，解析后可得到DOM对象。
##### status
服务器返回的HTTP状态码，用数字表示，如200表示“成功”，404表示“资源未找到”。
##### statusText
HTTP状态码的文本表示，如状态码为200时，对应返回“OK”；状态码为404时，对应返回“Not Found”。

### XMLHttpRequest对象生命周期
由于浏览器的差异性，创建XMLHttpRequest对象时需要使用不同的方法，主要体现在IE浏览器与其他浏览器之间。
#### 创建XMLHttPRequest对象
```js
function createXMLHttp() {
    // code for IE7+, Firefox, Chrome, Opera, Safari
    if (window.XMLHttpRequest) {
        xmlhttp = new XMLHttpRequest();
    }
    // code for IE6, IE5
    if (window.ActiveXObject) {
        try {
            xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
        }
        catch (e) {
            try {
                xmlhttp = new ActiveXObject("msxml2.XMLHTTP");
            }
            catch (ex) { }
        }
    }
}
```
#### 建立连接
当XMLHttPRequest对象创建完毕后，便可以通过open()函数建立连接，它指定了请求的url地址以及通过url传递的参数；数据传输方式，默认值为true，表示采用异步传输方式。
```js
var xhr = createXMLHttp();
xhr.open('post', '/admin/w/saveUser', true);
```
#### 发送请求并传递数据
在使用open()函数建立连接后，便可以使用send()函数发送请求，并传递数据content。由于传递的数据并不是必需的，所以content值可以为空。
```js
var content = { username: 'ming', password: '123456' };
xhr.send(content);
```
#### 处理响应
在XMLHttpRequest对象中有一个很重要的onreadystatechange属性，它表示XMLHttpRequest对象状态改变的事件触发器，每次readyState的取值变化时，属性onreadystatechange对应的函数都会被执行一次。

当readyState的值为4时代表响应接收完成，需要注意的是响应接收完成并不代表请求是成功的，我们需要通过HTTP请求status状态码来判断，当status值为200时代表请求成功。

因此在onreadystatechange()回调函数中，我们需要同时判断readyState和status两个值才能对响应值做正确的处理。
```js
xhr.onreadystatechange = function () {
  // 当readyState为4，且状态码为200时代表请求成功
  if (xhr.readyState === 4 && xhr.status === 200) {
    // 处理响应值
    document.write(xhr.responseText);
  }
}
```
### Ajax的优缺点
#### 优点
- 无刷新更新数据：最大优点是在不需要刷新页面的情况下，能够与服务端保持数据通信，这使得Web应用程序能够快速地响应用户请求，避免不必要的等待时间，提高用户体验。
- 异步通信：Ajax使用异步的方式与服务端通信，能够减少不必要的数据传输，降低网络数据流量，使得响应更加迅速。
- 前后端分离：Ajax可以使得前后端分离开发更加完善，后端专注于接收请求、响应数据，前端专注于页面逻辑的处理。
- 前后端负载均衡：在前后端进行分离开发后，以往由后端处理的数据逻辑，现在也可以交给前端处理，减轻服务端压力。
- 标准化支持：Ajax是一种基于Web标准化并被浏览器广泛支持的技术，不需要下载额外的插件，只需要客户允许JavaScript在浏览器上执行即可。
#### 缺点
- 破坏浏览器的正常后退功能：浏览器有一个很重要的功能是对历史记录的追溯，通过后退按钮可以退到浏览器之前访问过的页面，但是该按钮却没有办法和JavaScript进行很好的合作，从而导致Ajax对浏览器后退机制的破坏。
- 安全性问题：Ajax的逻辑可以将前端安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的链接。同时Ajax也难以避免一些已知的安全性弱点，例如跨域脚本攻击、SQL注入攻击和基于Credentials的安全漏洞等。
- 对搜索引擎支持较弱：浏览器在进行SEO（Search Engine Optimization，搜索引擎优化）时，会屏蔽掉所有的JavaScript代码，而JavaScript是Ajax技术组成中至关重要的一部分，这就导致了SEO对Ajax支持不友好。
- 违背URL唯一资源定位的初衷：由于Ajax请求并不会改变浏览器地址栏的URL，因此对于相同的URL，不同的用户看到的内容可能是不一样的，这就违背了URL定位唯一资源的初衷。

## 使用Nodejs搭建简易服务器
- Nodejs环境，参考版本为v16.14.2。
- 基于Nodejs的Express框架。

### 创建项目
在硬盘上创建一个项目ajaxTest，并放入文件夹中。
```bash
$ mkdir ajaxTest
$ cd ajaxTest
```
### 项目初始化
```bash
npm init -y
```
初始化完成后，会在项目根目录下生成一个package.json文件。

### 安装Express框架与body-parser插件
```js
npm i -D express 
```
在处理post请求时，需要使用body-parser插件，因此也需要提前安装该插件。
```js
npm i -D body-parser
```
### 创建server.js文件
在项目根目录下创建一个server.js文件，文件名可以自定义，用于最后启动服务器。
其中有几点需要注意的地方。
- 在接收post请求传递的数据时，需要使用body-parser插件。
- 通过处理“/”请求可以指定首页。
- 监听的端口号需要唯一，不可与其他应用端口号一样。

```js
// server.js
var express = require('express');
// 接收post请求体数据的插件
var bodyParser = require('body-parser');

var app = express();
app.use(bodyParser());

// 接收“/”请求，指定首页
app.get('/', function (req, res) {
    res.sendFile(_ _dirname + '/index.html');
});

// 处理get请求
app.get('/getUser', function (req, res) {
    console.log(req.query);
});

// 处理post请求
app.post('/saveUser', function (req, res) {
    var responseObj = {
        code: 200,
        message: '执行成功'
    };
    res.write(JSON.stringify(responseObj));
    res.end('end');
});

// 执行监听的端口号
var server = app.listen(3000, function () {});
```
### 编写首页index.html的内容

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

  这是一个简易server的首页，Hello Nodejs

</body>
</html>
```
### 运行server
```bash
 node server.js
```
### 查看运行效果
在浏览器地址栏中输入“http://localhost:3000”即可看到首页内容

在本地成功地启动了一个服务器，对于后文中Ajax请求的处理和响应，都是基于这个server.js去实现的。

## 使用Ajax提交form表单
form表单的默认提交方式会刷新页面，而且会在页面之间进行跳转。如果需要保持当前用户对表单状态的改变，就要在后台控制器和前端页面中传递更多的参数，因此对于前端与后台处理信息交互比较频繁的场景，form表单默认的提交方式并不友好。

为了应对以上的场景，使用Ajax提交form表单是一种很好的解决办法。因为Ajax可以在不刷新页面的情况下提交请求，然后在处理响应时通过JavaScript操作DOM，并展示后台处理的信息。

### 通用处理
在使用Ajax提交form表单时，需要对form表单进行特殊的处理，包括以下几点。
- 将form标签的action属性和method属性去掉。
- 将提交form表单按钮的type="submit"改为type="button"。

```html
<form name="userForm" id="userForm">
  <div class="form-group">
    <label for="username">用户名</label>
    <input type="text" class="form-control" name="username" id="username" />>
  </div>
  <div class="form-group">
    <label for="password">密码</label>
    <input type="password" class="form-control" name="password" id="password" />
  </div>
  <div class="form-group">
    <label for="email">邮箱</label>
    <input type="text" class="form-control" name="email" id="email" />
  </div>
  <div class="text-center">
    <input type="button" class="btn btn-default btn-primary" value="提交" id="submit" />
    <input type="button" class="btn btn-default" value="取消" id="cancel" />
  </div>
</form>
```
这是一段类似于用户注册页面的代码，包含用户名、密码、电话、邮箱等几个输入文本框，通过提交按钮可以将用户输入的信息提交到服务端。

### 使用原生Ajax进行提交
提交form表单包含以下过程：
- 绑定提交按钮事件。
- 创建XMLHttpRequest对象。
- 建立连接。
- 设置请求头。
- 获取数据。
- 发送请求。
- 处理响应。

接下来一步步讲解实现过程。
#### 绑定提交按钮事件
在单击提交按钮时，触发Ajax请求的操作，将整个Ajax操作封装在ajaxSubmitForm()函数里。按钮获取与事件绑定使用原生的JavaScript语法。
```js
var submitBtn = document.getElementById('submit');
submitBtn.addEventListener('click', function() {
  ajaxSubmitForm();
})
```
#### 创建XMLHttpRequest对象
```js
function createXMLHttp() {
    // code for IE7+, Firefox, Chrome, Opera, Safari
    var xmlhttp;
    if (window.XMLHttpRequest) {
        xmlhttp = new XMLHttpRequest();
    }
    // code for IE6, IE5
    if (window.ActiveXObject) {
        try {
            xmlhttp = new ActiveXObject(“Microsoft.XMLHTTP”);
        }
        catch (e) {
            try {
                xmlhttp = new ActiveXObject(“msxml2.XMLHTTP”);
            }
            catch (ex) { }
        }
    }
    return xmlhttp;
}
var xhr = createXMLHttp();
```
#### 建立连接
本实例可以理解为一个用户的注册操作，发送的请求为POST请求，使用异步处理的方式。
```js
xhr.open('post', '/saveUser', true);
```
#### 设置请求头
由于本实例中发送的是POST请求，需要设置数据传输格式，即设置Content-type属性值。可以通过setRequestHeader()函数对其进行设置，将其值设置为比较普遍的JSON数据格式。
```js
xhr.setRequestHeader('Content-type', 'application/json;charset=UTF-8');
```
需要注意的一点是：在设置请求头之前，需要调用XMLHttpRequest实例的open()函数，以保证已经建立连接请求。
#### 获取数据
通过原生的DOM操作方式获取页面填写的数据。
```js
var username = document.getElementById('username').value;
var password = document.getElementById('password').value;
var telphone = document.getElementById('telphone').value;
var email = document.getElementById('email').value;
var content = {
    username: username,
    password: password,
    telphone: telphone,
    email: email
};
```
因为在请求头中设置了数据传输格式为json，所以需要将content对象处理为json字符串。
```js
content = JSON.stringify(content);
```
#### 发送请求
```js
xhr.send(content);
```
#### 处理响应
设置onreadystatechange属性对应的回调函数，在回调函数中进行判断。当响应接收完毕，readyState为4，同时请求状态码status为200时，即表示请求成功，然后就可以编写对应的处理逻辑。
```js
xhr.onreadystatechange = function () {
    // 当readyState为4，且状态码为200时代表请求成功
    if (xhr.readyState === 4 && xhr.status === 200) {
        // 处理响应值
        document.write(xhr.responseText);
    }
}
```
在使用原生Ajax提交form表单内容时，需要考虑浏览器兼容性问题，并且该方式的代码冗余度高，需要经常进行状态的判断，因此这并不是一种很好的处理form表单的方式。

### 使用jQuery处理Ajax请求进行提交
使用jQuery处理Ajax请求，解决了浏览器兼容性的问题，对原生Ajax请求的高度封装也使得代码变得精简。
只需要关注在使用Ajax时需要什么，然后传递对应的参数，处理不同的回调即可。

#### 文件引入
```html
<script src="https://cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
```
#### 页面加载完成，绑定事件
在页面加载完成时，会执行`$(document).ready()`函数，可简写为`$(function() {})`，然后在该函数中绑定提交按钮的事件。
```js
$(function () {
  var submitBtn = $('#submit');
  submitBtn.click(function () {
    ajaxSubmitForm();
  })
})
```

#### 获取传递的数据
```js
var content = {
    username: $('#username').val(),
    password: $('#password').val(),
    telphone: $('#telphone').val(),
    email: $('#email').val()
};
```

#### 使用$.ajax()函数发送请求
需要关注以下这些内容。
- 请求类型。
- 请求url。
- 请求数据类型。
- 传递的数据。
- 响应数据类型。
- 回调函数。
其中的回调函数包括在发送请求之前调用的beforeSend()函数、请求出错的error()函数、请求成功的success()函数、请求完成的complete()函数。

```js
$.ajax({
    // 请求类型
    type: 'POST',
    // 请求URL
    url: '/saveUser',
    // 请求数据类型设置
    contentType: 'application/json;charset=UTF-8',
    // 响应数据类型设置
    dataType: 'json',
    // 传递的参数
    data: JSON.stringify(content),
    // 执行成功的回调函数
    success: function (response) {
        console.log('函数执行成功');
    },
    // 执行完成的回调函数
    complete: function (response) {
        console.log('函数执行完成');
    },
    // 执行失败的回调函数
    error: function () {
        console.log('函数执行失败');
    }
});
```
需要注意的是如果设置了contentType为json数据格式传递，则通过data传递参数时也需要处理为json字符串。
在上面的例子中也可以不用设置contentType，直接通过对象的形式传递，并在服务端接收到的参数是一样的，可以简写为以下形式。
```js
$.ajax({
    // 请求类型
    type: 'POST',
    // 请求URL
    url: '/saveUser',
    // 响应数据类型设置
    dataType: 'json',
    // 传递的参数
   data: content,
    // 执行成功的回调函数
    success: function (response) {
        console.log('函数执行成功');
    },
    // 执行完成的回调函数
    complete: function (response) {
        console.log('函数执行完成');
    },
    // 执行失败的回调函数
    error: function () {
        console.log('函数执行失败');
    }
});
```
上面的写法是不是很完美的一个写法呢？
并不是的，主要问题是在数据的获取上，我们需要写很多的JS语句来获取数据，例如下面的代码。
```js
var username = $('#username').val();
var password = $('#password').val();
```
如果form表单项过多，会写很多冗余的$('#id').val()代码，看起来十分麻烦，那有没有简单的处理方法呢？
使用jQuery的serialize()函数或者serializeArray()函数，序列化form表单进行提交。

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```
