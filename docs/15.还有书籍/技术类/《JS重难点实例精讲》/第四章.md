# 对象
JavaScript虽然是一门弱类型语言，但它同样是一门面向对象的语言，严格来说它是一门基于原型的面向对象的语言。
## 对象的属性和访问方式
### 对象的属性👍👍👍
ECMA-262规范把对象定义为：无序属性的集合，其属性值可以包含基本类型值、对象或者函数等。
通俗点讲，对象是一组键值对的集合，键表示的是属性名称，值表示的是属性的值。
#### 数据属性
具有4个描述其行为的特性，因为这些特性是内部值，所以ECMA-262规范将其放在了两对方括号中。
- `[[Configurable]]`：表示属性能否删除而重新定义，或者是否可以修改为访问器属性，默认值为**true**。
-  `[[Enumerable]]`：表示属性是否可枚举，可枚举的属性能够通过for...in循环返回，默认值为**true**。
-  `[[Writable]]`：表示属性值能否被修改，默认值为**true**。
-  `[[Value]]`：表示属性的真实值，属性的读取和写入均通过此属性完成，默认值为**undefined**。

例如，通过以下代码定义了一个包含name属性的对象person，name属性的`[[Configurable]]`、`[[Enumerable]]`、`[[Writable]]`特性值都为true，`[[Value]]`特性值为'ming'。
```js
var person = {
  name: "ming"
};
```
如果需要修改数据属性默认的特性，则必须使用Object.defineProperty()函数，语法如下。
```js
Object.defineProperty(target, property, {
  configurable: true,
  enumerable: false,
  writable: false,
  value: 'ming'
});
```
- 其中target表示目标对象
- property表示将要修改特性的属性
- 第三个参数是一个描述符对象，描述符对象的属性必须为configurable、enumerable、writable、value，以分别对应4个特性值，可以同时设置其中一个或多个值。

Demo
```js
var person = {
  name: 'ming'
};
// 设置其name属性的writable值为false，表示name属性值无法被修改。
Object.defineProperty(person, 'name', {
  writable: false,
});
person.name = 'mingli';
console.log(person.name); // 'min'
```
#### 访问器属性
访问器属性同样包含4个特性:
- `[[Configurable]]`：表示属性能否删除而重新定义，或者是否可以修改为访问器属性，默认值为**true**。
- `[[Enumerable]]`：表示属性是否可枚举，可枚举的属性能够通过for...in循环返回，默认值为**true**。
- `[[Get]]`：在读取属性值时调用的函数（一般称为getter()函数），负责返回有效的值，默认值为**undefined**。
- `[[Set]]`：在写入属性值时调用的函数（一般称为setter()函数），负责处理数据，默认值为**undefined**。

同样使用Object.defineProperty()函数

getter()函数和setter()函数的存在在一定程度上可以实现对象的私有属性，私有属性不对外暴露。如果想要读取和写入私有属性的值，则需要通过设置额外属性的getter()函数和setter()函数来实现，具体可以看下面的例子。
```js
1  var person = {
2     _age: 10
3  };
4  Object.defineProperty(person, "age", {
5      get: function(){
6          return this._age;
7      },
8      set: function(newValue) {
9          if (newValue > 10) {
10             this._age = newValue;
11             console.log('设置成功');
12     }
13 }
14 });
15 console.log(person.age); // 10
16 person.age = 9; 
17 console.log(person.age); // 10
18 person.age = 19; // “设置成功”
19 console.log(person.age); // 19
```
### 属性的访问方式
对象属性的访问方式有两种，一种是使用点操作符（.），另一种是使用中括号操作符（[]）。
#### 使用“.”来访问属性
```js
ObjectName.propertyName // 语法
```
其中objectName为对象名称，propertyName为属性名称。
例如person.name，表示访问person对象的name属性值。
#### 使用“[]”来访问属性
```js
ObjectName[propertyName] // 语法
```
中objectName为对象名称，propertyName为属性名称。
例如person['name']，表示访问person对象的name属性值。

#### 二者不同之处
第一点，点操作符是**静态**的，只能是一个以属性名称命名的简单描述符，而且无法修改；而中括号操作符是**动态**的，可以传递字符串或者变量，并且支持在运行时修改。
```js
var obj = {};
obj.name = '张三';
var myName = 'name';
console.log(obj.myName); // undefined
console.log(obj[myName]); // 张三
```
第二点，点操作符不能以数字作为属性名，而中括号操作符可以。
```js
var obj = {};
obj.1 = 1; // Unexpected number
obj[2] = 2;
console.log(obj.1); // missing ) after argument list
console.log(obj[2]); // 2
```
第三点，如果属性名中包含会导致语法错误的字符，或者**属性名中含有关键字或者保留字**，可以使用方括号操作符，而不能使用点操作符。
```js
var person = {};
person['first name'] = 'ming';
console.log(person['first name']); // ming
console.log(person.first name); // missing ) after argument list
```
## 创建对象
在JavaScript中，**对象是一系列无序属性的集合**，属性值可以为基本数据类型、对象或者函数，因此对象实际就是一组键值对的组合。
```js
// 对象
var person = {
  // 基本数据类型的属性
  name: 'ming', age: 11,
  // 函数类型的属性
  getName: function () {
    return this.name;
  },
  // 对象类型的属性
  address: {
    name: '北京市',
    code: '100000'
  }
};
```
### 基于Object()构造函数
通过Object对象的构造函数生成一个实例，然后给它增加需要的各种属性。
```js
// Object()构造函数生成实例
var person = new Object();
// 为实例新增各种属性
person.name = 'ming';
person.age = 11;
person.getName = function () {
  return this.name;
}
person.address = {
  name: '北京市',
  code: '100000'
}
```
### 基于对象字面量
对象字面量本身就是一系列键值对的组合，每个属性之间通过逗号分隔。
```js
var person = {
   name: 'kingx',
   age: 11,
   getName: function () {
       return this.name;
   },
   address: {
       name: '北京市',
       code: '100000'
   }
};
```
方法1与方法2在创建对象时都具有相同的优点，即简单、容易理解。但是对象的属性值是通过对象自身进行设置的，如果需要同时创建若干个属性名相同，而只是属性值不同的对象时，则会产生很多的重复代码，造成代码冗余，因此不推荐使用方法1与方法2来批量创建对象。
### 基于工厂方法模式
工厂方法模式是一种比较重要的设计模式，用于创建对象，旨在抽象出创建对象和属性赋值的过程，只对外暴露出需要设置的属性值。
```js
// 工厂方法，对外暴露接收的name、age、address属性值
function createPerson(name, age, address) {
  // 内部通过Object()构造函数生成一个对象，并添加各种属性
  var o = new Object();
  o.name = name;
  o.age = age;
  o.address = address;
  o.getName = function () {
    return this.name;
  }
  return o; // 返回创建的对象
}
var person = createPerson('ming', 11, {
  name: '北京市',
  code: '100000'
});
```
> 使用工厂方法可以减少很多重复的代码，但是**创建的所有实例都是Object类型**，无法更进一步区分具体的类型。
### 基于构造函数模式
构造函数是通过this为对象添加属性的，属性值类型可以为基本类型、对象或者函数，然后通过new操作符创建对象的实例。
```js
function Person(name, age, address) {
  this.name = name;
  this.age = age;
  this.address = address;
  this.getName = function () {
    return this.name;
  }
}
var p = new Person('ming', 11, { name: '北京市', code: '100000' });
console.log(p instanceof Person) // true
```
使用构造函数创建的对象可以确定其所属类型，解决了工厂方法存在的问题。但是使用构造函数创建的对象存在一个问题，即相同实例的函数是不一样的。
```js
var p1 = new Person('ming', 11, { name: '北京市', code: '100000' });
var p2 = new Person('ming', 11, { name: '北京市', code: '100000' });
console.log(p1.getName === p2.getName); // false
```
这就意味着每个实例的函数都会占据一定的内存空间，其实这是没有必要的，会造成资源的浪费，另外函数也没有必要在代码执行前就绑定在对象上。
### 基于原型对象的模式
基于原型对象的模式是将所有的函数和属性都封装在对象的prototype属性上。
```js
// 定义函数
function Person() {}
// 通过prototype属性增加属性和函数
Person.prototype.name = 'ming';
Person.prototype.age = 11;
Person.prototype.address = {
  name: '北京市',
  code: '100000'
}
Person.prototype.getName = function() {
  return this.name;
}
// 生成两个实例
var p1 = new Person();
var p2 = new Person();
console.log(p1.name === p2.name); // true
console.log(p1.getName === p2.getName); // true
```
通过上面的代码可以发现，使用基于原型对象的模式创建的实例，其属性和函数都是相等的，不同的实例会共享原型上的属性和函数，解决了基于构造函数存在的问题。

new Q:因为所有的实例会共享相同的属性，那么改变其中一个实例的属性值，便会引起其他实例的属性值变化
```js
var p1 = new Person();
var p2 = new Person();
console.log(p1.name); // ming
p2.name = 'li';
console.log(p1.name); // li
```
### 构造函数和原型混合的模式
> 构造函数和原型混合的模式是目前最常见的创建自定义类型对象的方式。

构造函数中用于定义实例的属性，原型对象中用于定义实例共享的属性和函数。通过构造函数传递参数，这样每个实例都能拥有自己的属性值，同时实例还能共享函数的引用，最大限度地节省了内存空间。混合模式可谓是集二者之所长。
```js
// 构造函数中定义实例的属性
function Person(name, age, address) {
  this.name = name;
  this.age = age;
  this.address = address;
}
// 原型中添加实例共享的函数
Person.prototype.getName = function () {
  return this.name;
}
// 生成两个实例
var p1 = new Person('ming', 11, { name: '北京市', code: '100000'} );
var p2 = new Person('ming2', 11, { name: '上海市', code: '200000'} );
// 输出实例初始的name属性值
console.log(p1.name); // ming
console.log(p2.name); // ming2
// 改变一个实例的属性值
person.address.name = '广州市';
person.address.code = '510000';
// 不影响另一个实例的属性值
console.log(p2.address.name); // 上海市
// 不同的实例共享相同的函数，英雌在比较时是相等的
console.log(p1.getName === p2.getName); // true
// 改变一个实例的属性，函数仍然能正常执行
p2.name = 'ming3';
console.log(p1.getName()); // ming
console.log(p2.getName()); // ming3
```
### 基于动态原型模式
动态原型模式是将原型对象放在构造函数内部，通过变量进行控制，只在第一次生成实例的时候进行原型的设置。
动态原型的模式相当于懒汉模式，只在生成实例时设置原型对象，但是功能与构造函数和原型混合模式是相同的。
```js
// 动态原型模式
function Person(name, age, address) {
  this.name = name;
  this.age = age;
  this.address = address;
}
// 如果Person对象中_initialized为undefined，则表明还没有为Person的原型对象添加函数
if (typeof Person._initialized === 'undefined') {
  Person.prototype.getName = function () {
    return this.name;
  }
  Person._initialized = true;
}
// 生成两个实例
var p1 = new Person('ming', 11, { name: '北京市', code: '100000' });
var p2 = new Person('ming2', 11, { name: '上海市', code: '200000' });
// 改变其中一个实例的属性
p1.address.name = '广州市';
p1.address.code = '510000';
// 不会影响到另一个实例的属性
console.log(p2.address.name); // 上海市
// 改变一个实例的属性，函数仍能正常执行
p2.name = 'ming3';
console.log(p1.getName()); // ming
console.log(p2.getName()); // ming3
```
## 对象克隆
克隆是指通过一定的程序将某个变量的值复制至另一个变量的过程。根据复制后的变量与原始变量值的影响情况，克隆可以分为浅克隆和深克隆两种方式。
针对不同的数据类型，浅克隆和深克隆会有不同的表现，主要表现于基本数据类型和引用数据类型在内存中存储的值不同。
对于基本数据类型的值，变量存储的是值本身，存放在栈内存的简单数据段中，可以直接进行访问。
对于引用类型的值，变量存储的是值在内存中的地址，地址指向内存中的某个位置。如果有多个变量同时指向同一个内存地址，则其中一个变量对值进行修改时，会影响到其他的变量。
以数组为例来看看实际效果。
```js
var arr1 = [1, 2, 3];
var arr2 = arr1;
arr2[1] = 4;
console.log(arr1); // [1, 4, 3];
console.log(arr2); // [1, 4, 3];
```
将arr1和arr2这两个变量指向同一个数组，对arr2变量值的修改，会导致arr1变量值的变化，最后输出的arr1与arr2变量值都会被修改。
正是由于数据类型的差异性，这会导致它们在浅克隆和深克隆的表现上不同，基本数据类型不管是浅克隆还是深克隆都是对值本身的克隆，对克隆后值的修改不会影响到原始值。
引用数据类型如果执行的是浅克隆，对克隆后值的修改会影响到原始值；如果执行的是深克隆，则克隆的对象和原始对象相互独立，不会彼此影响。
### 浅克隆
浅克隆由于只克隆对象最外层的属性，如果对象存在更深层的属性，则不进行处理，这就会导致克隆对象和原始对象的深层属性仍然指向同一块内存。
#### 简单的引用复制
即遍历对象最外层的所有属性，直接将属性值复制到另一个变量中。
```js
function shallowClone(origin) {
  var result = {};
  // 遍历最外层属性
  for (var key in origin) {
    // 判断是否是对象自身的属性
    if (origin.hasOwnProperty(key)) {
      result[key] = origin[key];
    }
  }
  return result;
}
```
定义一个具有复合属性的对象，并进行测试，具体代码如下。
```js
// 原始对象
var origin = {
   a: 1,
   b: [2, 3, 4],
   c: {
      d: 'name'
   }
};
// 克隆后的对象
var result = shallowClone(origin);
console.log(origin);  // { a: 1, b: [ 2, 3, 4 ], c: { d: 'name' } }
console.log(result);  // { a: 1, b: [ 2, 3, 4 ], c: { d: 'name' } }
// 克隆后的对象的值与原始对象的值相同
```
#### ES6的Object.assign()函数
用于将源对象的可枚举属性复制到目标对象中。
```js
var origin = {
   a: 1,
   b: [2, 3, 4],
   c: {
      d: 'name'
   }
};
// 通过Object.assign()函数克隆对象
var result = Object.assign({}, origin);
console.log(origin);  // { a: 1, b: [ 2, 3, 4 ], c: { d: 'name' } }
console.log(result);  // { a: 1, b: [ 2, 3, 4 ], c: { d: 'name' } }
```
浅克隆实现方案都会存在一个相同的问题，即如果原始对象是引用数据类型的值，则对克隆对象的值的修改会影响到原始对象的值。
```js
// 修改克隆对象的内部属性
result.c.d = 'city';
console.log(origin); // { a: 1, b: [ 2, 3, 4 ], c: { d: 'city' } }
console.log(result); // { a: 1, b: [ 2, 3, 4 ], c: { d: 'city' } }
```
### 深克隆
#### JSON序列化和反序列化👍👍👍
**如果一个对象中的全部属性都是可以序列化的**，那么我们可以先使用JSON.stringify()函数将原始对象序列化为字符串，再使用JSON.parse()函数将字符串反序列化为一个对象，这样得到的对象就是深克隆后的对象。
```js
var origin = {
   a: 1,
   b: [2, 3, 4],
   c: {
       d: 'name'
   }
};
// 先反序列化为字符串，再序列化为对象，得到深克隆后的对象
var result = JSON.parse(JSON.stringify(origin));
console.log(origin); // { a: 1, b: [ 2, 3, 4 ], c: { d: 'name' } }
console.log(result); // { a: 1, b: [ 2, 3, 4 ], c: { d: 'name' } }
```
这种方法能够解决大部分JSON类型对象的深克隆问题，但是对于以下几个问题不能很好地解决。
- 无法实现对函数、RegExp等特殊对象的克隆。
- 对象的constructor会被抛弃，所有的构造函数会指向Object，原型链关系断裂。
- 对象中如果存在循环引用，会抛出异常。

定义一个原始对象，其中一个属性为函数，一个属性为正则表达式对象，一个属性为某个对象的实例。
```js
function Animal(name) {
  this.name = name;
}
var animal = new Animal('dog');
// 原始对象
var origin = {
  // 属性为函数
  a: function () {
    return 'a';
  },
  // 属性为正则表达式对象
  b: new RegExp('\d', 'g'),
  // 属性为某个对象的实例
  c: animal
}
var result = JSON.parse(JSON.stringify(origin));
console.log(origin); // { a: [Function: a], b: /d/g, c: Animal { name: 'dog'}}
console.log(result); // { b: {}, c: { name: 'dog' }}
console.log(origin.c.constructor) // [Function: Animal]
console.log(result.c.constructor) // [Function: Object]
```
从得到的结果中，验证了上述的观点。
- 值为Function类型的a属性丢失。
- b属性应该为一个正则表达式，在克隆后得到的是一个空对象。
- c属性值虽然都是一个具有name属性的对象，但是克隆后对象的c属性值对象的构造函数却不再指向Animal，而是指向Object，构造函数被丢失，导致原型链关系的断裂。

关于循环引用，同样列举一个特定的实例。
定义一个原始对象，为原始对象添加一个属性指向自身，形成循环引用。
```js
var origin = {
   a: 'name'
};
origin.b = origin;
// TypeError: Converting circular structure to JSON
var result = JSON.parse(JSON.stringify(origin));
```
当在调用JSON.stringify(origin)时，就会抛出异常，表示“循环引用的结构无法序列化成JSON字符串”。
#### 自定义实现深克隆
在自定义实现深克隆时，需要针对不同的数据类型做针对性的处理，因此我们会先实现判断数据类型的函数，并将所有函数封装在一个辅助类对象中，这里用“_”表示（类似于underscore类库对外暴露的对象）。
```js
/**
 * 类型判断
 */
(function(_) {
  // 列举可能存在的数据类型
  var types = 'Array Object String Date RegExp Function Boolean Number Null Undefined Symbol Null'.split(' ');
  function type() {
    // 通过调用toString函数，从索引为8时截取字符串，得到数据类型的值
    return Object.prototype.toString.call(this).slice(8, -1);
  }
  for (var i = types.length; i--;) {
    _['is' + types[i]] = (function( self) {
      return function (elem) {
        return type.call(elem) === self;
      }
    })(types[i]);
  }
  return _;
})(_ = {});
```
执行上面的代码后，_ 对象便具有了isArray()函数、isObject()函数等一系列判断数据类型的函数。然后再调用_.isArray(param)函数判断param是否是数组类型、调用_.isObject(param)函数判断param是否是对象类型。
```js
/**
 * 深克隆实现方案
 * @param source 待克隆的对象
 * @returns {*} 返回克隆后的对象
 */
function deepClone(source) {
  // 维护两个存储循环引用的数组
  var parents = [];
  var children = [];
  // 用于获得正则表达式的修饰符, /igm
  function getRegExp(reg) {
    var result = '';
    if (reg.ignoreCase) {
      result += 'i';
    }
    if (reg.global) {
      result += 'g';
    }
    if (reg.multiline) {
      result += 'm';
    }
    return result;
  }
  // 便于递归的_clone函数
  function _clone(parent) {
    if (parent === null) return null;
    if (typeof parent !== 'object') return parent;
    var child, proto;
    // 对数组做特殊处理
    if (_.isArray(parent)) {
      child = [];
    } else if(_.isRegExp(parent)) {
      // 对正则对象做特殊处理
      child = new RegExp(parent.source, getRegExp(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (_.isDate(parent)) {
      // 对Date对象做特殊处理
      child = new Date(parent.getTime());
    } else {
      // 处理对象原型
      proto = Object.getPrototypeOf(parent);
      // 利用Object.create)切换原型链
      child = Object.create(proto);
    }
    // 处理循环引用
    var index = parents.indexOf(parent);
    if (index !== -1) {
      // 如果父数组存在本对象，说明之前已经被引用过，直接返回此对象
      return children[index];
    }
    // 没有引用过，则添加至parents和children数组中
    parents.push(parent);
    children.push(child);
    // 遍历对象属性
    for (var prop in parent) {
      if (parent.hasOwnProperty(prop)) {
        // 递归处理
        child[prop] = _clone(parent[prop]);
      }
    }
    return child;
  }
  return _clone(source);
}
// 首先是使用最基本的JSON格式对象进行测试。
var origin = {
   a: 1,
   b: [2, 3, 4],
   c: {
       d: 'name'
   }
};
var result = deepClone(origin);
console.log(origin); // { a: 1, b: [ 2, 3, 4 ], c: { d: 'name' } }
console.log(result); // { a: 1, b: [ 2, 3, 4 ], c: { d: 'name' } }

// 使用具有Function类型属性、RegExp类型属性、实例属性的对象进行测试。
function Animal(name) {
   this.name = name;
}
var animal = new Animal('tom');
var origin = {
   a: function () {
       return 'a';
   },
   b: new RegExp('\d', 'g'),
   c: animal
};
var result = deepClone(origin);
console.log(origin); // { a: [Function: a], b: /d/g, c: Animal { name: 'tom' } }
console.log(result); // { a: [Function: a], b: /d/g, c: Animal { name: 'tom' } }

// 最后是使用具有循环引用属性的对象进行测试。
var origin = {
   a: 'name'
};
origin.b = origin;
var result = deepClone(origin);
console.log(origin); // { a: 'name', b: [Circular] }
console.log(result); // { a: 'name', b: [Circular] }
```
#### jQuery实现——$.clone()函数和$.extend()
在jQuery中提供了一个$.clone()函数，但是它是用于复制DOM对象的。
真正用于实现克隆的函数是$.extend()，下面来看看对应的源码
```js
jQuery.extend = jQuery.fn.extend = function() {
    // options是一个缓存变量，用来缓存arguments[i]，
    // name是用来接收将要被扩展对象的key，src改变之前target对象上每个key对应的value
    // copy传入对象上每个key对应的value，copyIsArray判定copy是否为一个数组
    // clone深克隆中用来临时存对象或数组的src
    var src, copyIsArray, copy, name, options, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

     // 如果传递的第一个参数为boolean类型，为true代表深克隆，为false代表浅克隆
    if ( typeof target === "boolean" ) {
        deep = target;
        // 如果传递了第一个参数为boolean值，则待克隆的对象为第二个参数
        target = arguments[ i ] || {};
        i++;
    }
    // 如果是简单类型数据
    if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
        target = {};
    }
    // 如果只传递一个参数，那么克隆的是jQuery自身
    if ( i === length ) {
        target = this;
        i--;
    }
    for ( ; i < length; i++ ) {
        // 仅需要处理不是null与undefined类型的数据
        if ( (options = arguments[ i ]) != null ) {
            // 遍历对象的所有属性
            for ( name in options ) {
                src = target[ name ];
                copy = options[ name ];
                // 阻止循环引用
                if ( target === copy ) {
                    continue;
                }

                // 递归处理对象和数组
                if ( deep && copy && ( jQuery.isPlainObject(copy)                   || (copyIsArray = jQuery.isArray(copy)) ) ) {
                    if ( copyIsArray ) {
                        copyIsArray = false;
                        clone = src && jQuery.isArray(src) ? src : [];
                    } else {
                        clone = src && jQuery.isPlainObject(src) ? src : {};
                    }
                    // 将原始值的name属性值赋给target目标对象
                    target[ name ] = jQuery.extend( deep, clone, copy );
                } else if ( copy !== undeﬁned ) {
                  // 对于简单类型，直接赋值
                    target[ name ] = copy;
                }
            }
        }
   }
   // 返回clone后的目标对象
   return target;
};
```
使用$.extend()函数可以实现函数与正则表达式等类型的克隆，还能保持克隆对象的原型链关系，解决了深克隆中存在的3个问题中的前两个，但是却无法解决循环引用的问题。
```js
var origin = {};
origin.d = origin;
var result = $.extend(true, {}, origin); // Uncaught RangeError: Maximum call stack size exceeded
```
## 原型对象
每一个函数在创建时都会被赋予一个prototype属性，它指向函数的原型对象，这个对象可以包含所有实例共享的属性和函数。因此在使用prototype属性后，就可以将实例共享的属性和函数抽离出构造函数，将它们添加在prototype属性中。
### 原型对象、构造函数、实例之间的关系
构造函数的prototype属性会指向它的原型对象，而通过构造函数可以生成具体的实例。
这里就会涉及3个概念，分别是构造函数、原型对象和实例。
- 原型对象、构造函数和实例之间的关系是什么样的？
- 使用原型对象创建了对象的实例后，实例的属性读取顺序是什么样的？
- 假如重写了原型对象，会带来什么样的问题？
```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```
