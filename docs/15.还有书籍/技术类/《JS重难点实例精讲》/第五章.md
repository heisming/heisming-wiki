# DOM与事件
DOM是文档对象模型，全称为Document Object Model。DOM用一个逻辑树来表示一个文档，树的每个分支终点都是一个节点，每个节点都包含着对象。
DOM提供了对文档结构化的表述，通过绑定不同的事件可以改变文档的结构、样式和内容，从而能实现“动态”的页面。
## DOM选择器
### 传统原生JavaScript选择器
为了能更直观地看到DOM选择器的效果，我们编写了一个HTML页面，然后通过DOM选择器定位元素，改变对应的展示内容。

HTML页面中主要是定义一系列的ul-li标签，然后通过DOM选择器定位li后并操作它们，初始代码如下所示。
```html
<ul>
    <li>节点1.1</li>
    <li>节点1.2</li>
    <li>节点1.3</li>
    <li>节点1.4</li>
    <li>节点1.5</li>
    <li>节点1.6</li>
    <li>节点1.7</li>
</ul>
<ul>
    <li>节点2.1</li>
    <li>节点2.2</li>
    <li>节点2.3</li>
    <li>节点2.4</li>
    <li>节点2.5</li>
    <li>节点2.6</li>
    <li>节点2.7</li>
</ul>
```
#### 通过id定位
```html
<!-- id唯一 -->
<ul>
    <li id="one">节点1.1</li>
    <li id="one">节点1.2</li>
    <li>节点1.3</li>
    <li>节点1.4</li>
</ul>
```
当具有相同id的元素时，除了第一个元素能被匹配到外，其他元素都会被忽略。
```js
document.getElementById('one').innerText; // 节点1.1
```
#### 通过class定位
> getElementsByClassName()函数，通过类名定位元素，返回由匹配到的元素构成的HTMLCollection对象，它是一个类数组结构。
```html
<li class="one">节点1.2</li>
<li class="one">节点1.3</li>
```
```js
document.getElementsByClassName('one');
// 返回值为一个HTMLCollection对象，里面包含匹配到的两个li元素值。
HTMLCollection(2) [li.one, li.one]
 - 0: li.one
 - 1: li.one
 - length: 2
 - __proto__:  HTMLCollection
```
#### 通过name属性定位
> getElementsByName()函数，通过元素的name属性进行定位，返回由匹配到的元素构成的NodeList对象，它是一个类数组结构。
```html
<ul>
    <li id="one">节点1.1</li>
    <li name="node">节点1.4</li>
    <li name="node">节点1.5</li>
</ul>
<ul>
    <li name="node">节点2.1</li>
    <li>节点2.2</li>
</ul>
```

```js
document.getElementsByName('node');
// 返回的值为一个NodeList对象，里面包含匹配到的name属性为“node”的元素。
NodeList(3) [li, li, li]
 - 0: li
 - 1: li
 - 2: li
 - length: 3
 -  __proto__:  NodeList
```
#### 通过标签名定位
> getElementsByTagName()函数，通过标签名定位元素，返回由匹配到的元素构成的HTMLCollection对象。
```js
// 通过标签名获取页面上的两个ul元素。
document.getElementsByTagName('ul');
// 返回值为一个HTMLCollection对象，里面包含匹配到的两个ul元素值。
HTMLCollection(2) [ul, ul]
- 0: ul
- 1: ul
- length: 2
- __proto__: HTMLCollection
```
### 新型的querySelector选择器和querySelectorAll选择器
使用传统的id、name、class等选择器来查找元素时，只能调用document具有的函数，在查找特定元素的子元素时不太方便。
#### querySelector选择器
> querySelector选择器返回的是在基准元素下，选择器匹配到的元素集合中的第一个元素。

语法如下所示。
```js
element = baseElement.querySelector(selectors);
```
其中，
- baseElement是基准元素，返回的元素必须是匹配到的基准元素的第一个子元素。该基准元素可以为Document，也可以为基本的Element。
- selectors是一个标准的CSS选择器，而且必须是合法的选择器，否则会引起语法错误。
- 返回值为匹配到的第一个子元素。匹配的过程中不仅仅针对基准元素的后代元素，实际上会遍历整个文档结构，包括基准元素和它的后代元素以外的元素。实际处理过程是首先创建一个匹配元素的初始列表，然后判断每个元素是否为基准元素的后代元素，第一个属于基准元素的后代元素将会被返回。
```html
<div>
  <h5>Original content</h5>
  <span>outside span</span>
  <p class="content">
    inside paragraph
    <span>inside span</span>
    inside paragraph
  </p>
</div>
```

```js
// 获取p元素的第一个span元素。
document.querySelector('p span').innerText; // inside span
// 获取class为content的元素的第一个span元素。
document.querySelector('.content span').innerText; // inside span
// 获取第一个span或者h5元素。
document.querySelector('h5, span').innerText // Original content
```
然后通过以下这段代码来验证上述返回值的匹配过程。
```js
var baseElement = document.querySelector("p");
console.log(baseElement.querySelector("div span").innerText); // inside span
```
第一行代码获取的基准元素为p元素，第二行代码中的选择器为“div span”。虽然在p元素中没有div元素，却依旧能匹配到span元素。这是因为在匹配过程会优先找出div元素下span元素的集合，然后判断span元素是否属于p元素的子元素，最后返回第一个匹配到的span元素值。

#### querySelectorAll选择器
> querySelectorAll选择器与querySelector选择器类似，区别在于querySelectorAll选择器会返回基准元素下匹配到的所有子元素的集合。

语法如下所示。
```js
elementList = baseElement.querySelectorAll(selectors);
// 它同样包含基准元素与选择器，返回值是一个NodeList的集合。
```

```html
<div>
    <h5>Original content</h5>
    <span>outside span</span>
    <p class="content">
        inside paragraph
        <span>inside span</span>
        inside paragraph
    </p>
</div>
```

```js
// 获取所有的span元素。
document.querySelectorAll('span');
// 其返回值如下所示。
NodeList(2) [span, span]
 - 0: span
 - 1: span
 - length: 2
 - __proto__:  NodeList
```
querySelectorAll选择器匹配过程与querySelector选择器一样，优先获取所有匹配元素的集合，然后判断每个元素是否属于基准元素。如果属于则返回结果，最终返回一个NodeList对象。

理解querySelectorAll选择器匹配元素的过程。
```html
<div id="my-id">
    <img id="inside">
    <div class="lonely"></div>
    <div class="outer">
        <div class="inner"></div>
    </div>
</div>
<script>
    var firstArr = document.querySelectorAll('#my-id div div');
        var secondArr = document.querySelector('#my-id').querySelectorAll('div div');
    console.log(firstArr);
    console.log(secondArr);
</script>
```
上面代码的主要目的是找出在id为“my-id”元素的子div中子div元素的集合。分别使用两种写法获取到了firstArr和secondArr两个值。
提问：firstArr和secondArr返回的NodeList值是否是一样的？答案：不一样。实际上它们输出的结果如下所示。
```js
firstArr   NodeList [div.inner]
        - 0: div.inner
        - length: 1
        - __proto__: NodeList
secondArr  NodeList(3) [div.lonely, div.outer, div.inner]
        - 0: div.lonely
        - 1: div.outer
        - 2: div.inner
        - length: 3
        - __proto__: NodeList
```
可以看出firstArr表示的NodeList对象的长度为1，而secondArr表示的NodeList对象的长度为3，为什么呢？

针对firstArr，querySelectorAll选择器的调用方是document，则基准元素为document；执行CSS选择器，匹配到的元素只有一个，如下代码所示。
```html
<div class="inner"></div>
```
该元素属于document中的子元素，最终返回结果如下所示。
```js
NodeList [div.inner]
```

针对secondArr，先通过querySelector选择器确定基准元素是id为“my-id”的元素，然后执行CSS选择器，选择器的内容是匹配div元素中的子div元素。
HTML代码对应的文档结构内，有3个元素是匹配的。
- id为“my-id”的div元素的第一个子节点。`<div class="lonely"></div>`
- id为“my-id”的div元素的第二个子节点。 `<div class="outer">...</div>`
- class为“outer”的div元素的第一个子节点。`<div class="inner"></div>`

紧接着判断这3个匹配的元素是否为基准元素的子元素，发现它们都是处于基准元素内部的，最终这3个值构成一个NodeList集合返回。
```js
NodeList(3) [div.lonely, div.outer, div.inner]
```
##### 特例👍👍👍
> 一个页面是不允许有相同id的元素的。如果出现了相同的id，则无法通过getElementById()函数获取到除第一个元素以外的元素。对于querySelectorAll选择器来说却是一个特例。将id选择器传入querySelectorAll选择器中后，可以通过id获取多个匹配的元素，然后通过索引获取特定的值。
```html
<div>
    <p id="first">文本1</p>
    <p id="first">文本2</p>
    <p id="first">文本3</p>
    <p id="first">文本4</p>
</div>
<script>
    console.log(document.querySelectorAll('#first').length);  // 4
    console.log(document.querySelectorAll('#first')[3].innerText); // 文本4
</script>
```
> 虽然querySelectorAll选择器也可以处理出现相同id的情况，按照HTML编写的规范，**绝对不允许**一个页面出现相同id的元素。
### HTMLCollection对象与NodeList对象
不同的DOM选择器，它们的返回值有些是NodeList对象，有些是HTMLCollection对象。那么它们有什么区别呢？

下面这段代码，主要是对children属性和childNodes属性的调用。
```html
<div id="main">
    <p class="first">first</p>
    <p class="second">second<span>content</span></p>
</div>
<script>
    var main = document.getElementById("main");
    console.log(main.children);
    console.log(main.childNodes);
</script>
```
得到的结果如下所示。
```js
HTMLCollection(2) [p.first, p.second]
 - 0: p.first
 - 1: p.second
 - length: 2
 -  __proto__:  HTMLCollection
NodeList(5) [text, p.first, text, p.second, text]
 - 0: text
 - 1: p.first
 - 2: text
 - 3: p.second
 - 4: text
 - length: 5
 -  __proto__:  NodeList
```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```
