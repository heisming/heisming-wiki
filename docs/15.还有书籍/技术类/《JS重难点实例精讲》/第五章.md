# DOM与事件
DOM是文档对象模型，全称为Document Object Model。DOM用一个逻辑树来表示一个文档，树的每个分支终点都是一个节点，每个节点都包含着对象。
DOM提供了对文档结构化的表述，通过绑定不同的事件可以改变文档的结构、样式和内容，从而能实现“动态”的页面。
## DOM选择器
### 传统原生JavaScript选择器
为了能更直观地看到DOM选择器的效果，我们编写了一个HTML页面，然后通过DOM选择器定位元素，改变对应的展示内容。

HTML页面中主要是定义一系列的ul-li标签，然后通过DOM选择器定位li后并操作它们，初始代码如下所示。
```html
<ul>
    <li>节点1.1</li>
    <li>节点1.2</li>
    <li>节点1.3</li>
    <li>节点1.4</li>
    <li>节点1.5</li>
    <li>节点1.6</li>
    <li>节点1.7</li>
</ul>
<ul>
    <li>节点2.1</li>
    <li>节点2.2</li>
    <li>节点2.3</li>
    <li>节点2.4</li>
    <li>节点2.5</li>
    <li>节点2.6</li>
    <li>节点2.7</li>
</ul>
```
#### 通过id定位
```html
<!-- id唯一 -->
<ul>
    <li id="one">节点1.1</li>
    <li id="one">节点1.2</li>
    <li>节点1.3</li>
    <li>节点1.4</li>
</ul>
```
当具有相同id的元素时，除了第一个元素能被匹配到外，其他元素都会被忽略。
```js
document.getElementById('one').innerText; // 节点1.1
```
#### 通过class定位
> getElementsByClassName()函数，通过类名定位元素，返回由匹配到的元素构成的HTMLCollection对象，它是一个类数组结构。
```html
<li class="one">节点1.2</li>
<li class="one">节点1.3</li>
```
```js
document.getElementsByClassName('one');
// 返回值为一个HTMLCollection对象，里面包含匹配到的两个li元素值。
HTMLCollection(2) [li.one, li.one]
 - 0: li.one
 - 1: li.one
 - length: 2
 - __proto__:  HTMLCollection
```
#### 通过name属性定位
> getElementsByName()函数，通过元素的name属性进行定位，返回由匹配到的元素构成的NodeList对象，它是一个类数组结构。
```html
<ul>
    <li id="one">节点1.1</li>
    <li name="node">节点1.4</li>
    <li name="node">节点1.5</li>
</ul>
<ul>
    <li name="node">节点2.1</li>
    <li>节点2.2</li>
</ul>
```

```js
document.getElementsByName('node');
// 返回的值为一个NodeList对象，里面包含匹配到的name属性为“node”的元素。
NodeList(3) [li, li, li]
 - 0: li
 - 1: li
 - 2: li
 - length: 3
 -  __proto__:  NodeList
```
#### 通过标签名定位
> getElementsByTagName()函数，通过标签名定位元素，返回由匹配到的元素构成的HTMLCollection对象。
```js
// 通过标签名获取页面上的两个ul元素。
document.getElementsByTagName('ul');
// 返回值为一个HTMLCollection对象，里面包含匹配到的两个ul元素值。
HTMLCollection(2) [ul, ul]
- 0: ul
- 1: ul
- length: 2
- __proto__: HTMLCollection
```
### 新型的querySelector选择器和querySelectorAll选择器
使用传统的id、name、class等选择器来查找元素时，只能调用document具有的函数，在查找特定元素的子元素时不太方便。
#### querySelector选择器
> querySelector选择器返回的是在基准元素下，选择器匹配到的元素集合中的第一个元素。

语法如下所示。
```js
element = baseElement.querySelector(selectors);
```
其中，
- baseElement是基准元素，返回的元素必须是匹配到的基准元素的第一个子元素。该基准元素可以为Document，也可以为基本的Element。
- selectors是一个标准的CSS选择器，而且必须是合法的选择器，否则会引起语法错误。
- 返回值为匹配到的第一个子元素。匹配的过程中不仅仅针对基准元素的后代元素，实际上会遍历整个文档结构，包括基准元素和它的后代元素以外的元素。实际处理过程是首先创建一个匹配元素的初始列表，然后判断每个元素是否为基准元素的后代元素，第一个属于基准元素的后代元素将会被返回。
```html
<div>
  <h5>Original content</h5>
  <span>outside span</span>
  <p class="content">
    inside paragraph
    <span>inside span</span>
    inside paragraph
  </p>
</div>
```

```js
// 获取p元素的第一个span元素。
document.querySelector('p span').innerText; // inside span
// 获取class为content的元素的第一个span元素。
document.querySelector('.content span').innerText; // inside span
// 获取第一个span或者h5元素。
document.querySelector('h5, span').innerText // Original content
```
然后通过以下这段代码来验证上述返回值的匹配过程。
```js
var baseElement = document.querySelector("p");
console.log(baseElement.querySelector("div span").innerText); // inside span
```
第一行代码获取的基准元素为p元素，第二行代码中的选择器为“div span”。虽然在p元素中没有div元素，却依旧能匹配到span元素。这是因为在匹配过程会优先找出div元素下span元素的集合，然后判断span元素是否属于p元素的子元素，最后返回第一个匹配到的span元素值。

#### querySelectorAll选择器
> querySelectorAll选择器与querySelector选择器类似，区别在于querySelectorAll选择器会返回基准元素下匹配到的所有子元素的集合。

语法如下所示。
```js
elementList = baseElement.querySelectorAll(selectors);
// 它同样包含基准元素与选择器，返回值是一个NodeList的集合。
```

```html
<div>
    <h5>Original content</h5>
    <span>outside span</span>
    <p class="content">
        inside paragraph
        <span>inside span</span>
        inside paragraph
    </p>
</div>
```

```js
// 获取所有的span元素。
document.querySelectorAll('span');
// 其返回值如下所示。
NodeList(2) [span, span]
 - 0: span
 - 1: span
 - length: 2
 - __proto__:  NodeList
```
querySelectorAll选择器匹配过程与querySelector选择器一样，优先获取所有匹配元素的集合，然后判断每个元素是否属于基准元素。如果属于则返回结果，最终返回一个NodeList对象。

理解querySelectorAll选择器匹配元素的过程。
```html
<div id="my-id">
    <img id="inside">
    <div class="lonely"></div>
    <div class="outer">
        <div class="inner"></div>
    </div>
</div>
<script>
    var firstArr = document.querySelectorAll('#my-id div div');
        var secondArr = document.querySelector('#my-id').querySelectorAll('div div');
    console.log(firstArr);
    console.log(secondArr);
</script>
```
上面代码的主要目的是找出在id为“my-id”元素的子div中子div元素的集合。分别使用两种写法获取到了firstArr和secondArr两个值。
提问：firstArr和secondArr返回的NodeList值是否是一样的？答案：不一样。实际上它们输出的结果如下所示。
```js
firstArr   NodeList [div.inner]
        - 0: div.inner
        - length: 1
        - __proto__: NodeList
secondArr  NodeList(3) [div.lonely, div.outer, div.inner]
        - 0: div.lonely
        - 1: div.outer
        - 2: div.inner
        - length: 3
        - __proto__: NodeList
```
可以看出firstArr表示的NodeList对象的长度为1，而secondArr表示的NodeList对象的长度为3，为什么呢？

针对firstArr，querySelectorAll选择器的调用方是document，则基准元素为document；执行CSS选择器，匹配到的元素只有一个，如下代码所示。
```html
<div class="inner"></div>
```
该元素属于document中的子元素，最终返回结果如下所示。
```js
NodeList [div.inner]
```

针对secondArr，先通过querySelector选择器确定基准元素是id为“my-id”的元素，然后执行CSS选择器，选择器的内容是匹配div元素中的子div元素。
HTML代码对应的文档结构内，有3个元素是匹配的。
- id为“my-id”的div元素的第一个子节点。`<div class="lonely"></div>`
- id为“my-id”的div元素的第二个子节点。 `<div class="outer">...</div>`
- class为“outer”的div元素的第一个子节点。`<div class="inner"></div>`

紧接着判断这3个匹配的元素是否为基准元素的子元素，发现它们都是处于基准元素内部的，最终这3个值构成一个NodeList集合返回。
```js
NodeList(3) [div.lonely, div.outer, div.inner]
```
##### 特例👍👍👍
> 一个页面是不允许有相同id的元素的。如果出现了相同的id，则无法通过getElementById()函数获取到除第一个元素以外的元素。对于querySelectorAll选择器来说却是一个特例。将id选择器传入querySelectorAll选择器中后，可以通过id获取多个匹配的元素，然后通过索引获取特定的值。
```html
<div>
    <p id="first">文本1</p>
    <p id="first">文本2</p>
    <p id="first">文本3</p>
    <p id="first">文本4</p>
</div>
<script>
    console.log(document.querySelectorAll('#first').length);  // 4
    console.log(document.querySelectorAll('#first')[3].innerText); // 文本4
</script>
```
> 虽然querySelectorAll选择器也可以处理出现相同id的情况，按照HTML编写的规范，**绝对不允许**一个页面出现相同id的元素。
## HTMLCollection对象与NodeList对象
不同的DOM选择器，它们的返回值有些是NodeList对象，有些是HTMLCollection对象。那么它们有什么区别呢？

下面这段代码，主要是对children属性和childNodes属性的调用。
```html
<div id="main">
    <p class="first">first</p>
    <p class="second">second<span>content</span></p>
</div>
<script>
    var main = document.getElementById("main");
    console.log(main.children);
    console.log(main.childNodes);
</script>
```
得到的结果如下所示。
```js
HTMLCollection(2) [p.first, p.second]
 - 0: p.first
 - 1: p.second
 - length: 2
 -  __proto__:  HTMLCollection
NodeList(5) [text, p.first, text, p.second, text]
 - 0: text
 - 1: p.first
 - 2: text
 - 3: p.second
 - 4: text
 - length: 5
 -  __proto__:  NodeList
```
### HTMLCollection对象
HTMLCollection对象具有length属性，返回集合的长度，可以通过item()函数和namedItem()函数来访问特定的元素。
#### item()函数
可以调用item()函数，通过序号来获取特定的某个节点，超过索引则返回“null”。
```html
<div id="main">
    <p class="first">first</p>
    <p class="second">second</p>
    <p class="third">third</p>
    <p class="four">four</p>
</div>
<script>
    var main = document.getElementById("main").children;
    console.log(main.item(0)); // <p class="first">first</p>
    console.log(main.item(2)); // <p class="third">third</p>
</script>
```
#### namedItem()函数
用来返回一个节点。
首先通过id属性去匹配，然后如果没有匹配到则使用name属性匹配，如果还没有匹配到则返回“null”。当出现重复的id或者name属性时，只返回匹配到的第一个值。
```html
<form id="main">
    <input type="text" id="username">
    <input type="text" name="username">
    <input type="text" name="password">
</form>
<script>
    var main = document.getElementById("main").children;
    console.log(main.namedItem('username')); // <input type="text" id="username">
</script>
```
### NodeList对象
> NodeList对象也具有length属性，返回集合的长度，也同样具有item()函数，通过索引定位子元素的位置。同HTMLCollection。

### HTMLCollection对象和NodeList对象的实时性
> 两者并不是历史文档状态的静态快照，而是具有**实时性**的。对DOM树新增或者删除一个相关节点，都会立刻反映在HTMLCollection对象与NodeList对象中。

HTMLCollection对象与NodeList对象都只是类数组结构，并不能直接调用数组的函数。
而通过call()函数和apply()函数处理为真正的数组后，它们就转变为一个真正的**静态值**了，不会再动态反映DOM的变化。
```html
<form id="main">
    <input type="text" id="username">
    <input type="text" name="password">
</form>
<script>
    // 获取HTMLCollection
    var mainChildren = document.getElementById('main').children;
        console.log(mainChildren.length);  // 2

    // 新增一个input元素
    var newInput = document.createElement('input');
    main.appendChild(newInput);
    console.log(mainChildren.length);  // 3

    // 通过call()函数处理成数组结构
    mainChildren = Array.prototype.slice.call(mainChildren, 0);
    mainChildren.splice(1, 1);
    console.log(mainChildren.length);  // 2

    // 再新增一个input元素
    var newInput2 = document.createElement('input');
    main.appendChild(newInput2);
    console.log(mainChildren.length);  // 2

</script>
```
NodeList对象与HTMLCollection对象相比，存在一些细微的差异，主要表现在不是所有的函数获取的NodeList对象都是实时的。例如通过querySelectorAll()函数获取的NodeList对象就不是实时的。
```html
<ul id="main">
    <li>文本1</li>
    <li>文本2</li>
    <li>文本3</li>
    <li>文本4</li>
    <li>文本5</li>
</ul>
<script>
    // 获取ul
    var main = document.getElementById('main');
    // 获取li集合
    var lis = document.querySelectorAll('ul li');
    // 第一次输出li集合长度，值为5
    console.log(lis.length);

    // 新增li元素
    var newLi = document.createElement('li');
    var text = document.createTextNode('文本8');
    newLi.appendChild(text);
    main.appendChild(newLi);
    // 再次输出li集合长度，值为5
    console.log(lis.length);
    // 重新获取li的集合并输出长度，值为6
    console.log(document.querySelectorAll('ul li').length);
</script>
```
综上所述，两者具有以下的相同点和不同点。
#### 相同点
- 都是类数组对象，有length属性，可以通过call()函数或apply()函数处理成真正的数组。
- 都有item()函数，通过索引定位元素。
- 都是实时性的，DOM树的变化会及时反映到HTMLCollection对象和NodeList对象上，只是在某些函数调用的返回结果上会存在差异。
#### 不同点
- HTMLCollection对象比NodeList对象多个namedItem()函数，可以通过id或者name属性定位元素。
- HTMLCollection对象只包含元素的集合（Element），即具有标签名的元素；而NodeList对象是节点的集合，既包括元素，也包括节点，例如text文本节点。

## 常用的DOM操作
> 文档树是由各种类型节点构成的集合，DOM操作实际是对文档结构中节点的操作。
> 文档结构树中的节点类型众多，但是操作的主要节点类型为元素节点、属性节点和文本节点。
```html
<!DOCTYPE html>
<html>
<head>
    <title>文档标题</title>
</head>
<body>
  <a href="http://www.mianshiting.com">我的链接</a>
  <h1>我的标题</h1>
</body>
</html>
```
如果将这些节点画成一个树的话:
[文档](./assets/drowio/document.drawio ':include :type=code')
- 元素节点是拥有一对开闭合标签的元素整体，例如常见的div、ul、li标签都是元素节点。
  - `<div></div>，<ul></ul>，<li></li>`
- 属性节点是元素节点具有的属性，例如a标签的href属性。
- 文本节点是DOM中用于呈现文本内容的节点，例如h1标签内部的“我的标题”。
- 其中元素节点和文本节点存在父子关系，而元素节点与属性节点并不存在父子关系。

### 新增节点
> 两个步骤，首先是新建节点，然后将节点添加至指定的位置。
```html
<ul id="container">
    <li class="first">文本1</li>
    <li class="second">文本2</li>
    <li>文本3</li>
    <li id="target">文本4</li>
    <li>文本5</li>
    <li>文本6</li>
</ul>
```
需要完成这样一个操作：第一步，在ul的末尾添加一个li元素，其类名为“last”，内容为“新增文本1”；第二步，在新增的li之前再新增第二个li，内容为“新增文本2”。
```js
// 1️⃣获取指定元素。
var container = document.querySelector('#container');
// 2️⃣新建创建一个元素节点。
var newLiOne = document.createElement('li');
// 3️⃣新建一个属性节点，并设置值。
var newLiAttr = document.createAttribute('class');
newLiAttr.value = 'last';
// 4️⃣将属性节点绑定在元素节点上。
newLiOne.setAttributeNode(newLiAttr);
// 5️⃣新建一个文本节点。
var newTextOne = document.createTextNode('新增文本1');
// 6️⃣将文本节点作为元素节点的子元素。
newLiOne.appendChild(newTextOne);
// 7️⃣使用appendChild()函数将新增元素节点添加至末尾。
container.appendChild(newLiOne);
// 8️⃣新创建第二个元素节点。
var newTextTwo = document.createTextNode('新增文本2');
// 9️⃣新创建第二个文本节点。
var newTextTwo = document.createTextNode('新增文本2');
// 🔟将文本节点作为元素节点的子元素。
newLiTwo.appendChild(newTextTwo);
// 🔟+1️⃣使用insertBefore()函数将节点添加至第一个新增节点的前面。
container.insertBefore(newLiTwo, newLiOne);
```
至此，完成指定的两个新增操作。

在新增属性节点时，还有另外一种更简单的setAttribute()函数。以上面代码为例，可以通过下面这一行代码完成上述3️⃣4️⃣这两步共3行代码的功能。
```js
newLiOne.setAttribute('class', 'last'); // 不兼容IE8及更早的版本
```
### 删除节点
删除节点的操作实际包含删除元素节点、删除属性节点和删除文本节点。
```html
<ul id="main">
    <li>文本1</li>
    <li>文本2</li>
    <li>文本3</li>
</ul>
<a id="link" href="http://www.mianshiting.com">面试厅</a>
```
1. 删除ul的第一个li元素节点
删除一个元素节点需要进行三步操作。
```js
// 1️⃣获取该元素的父元素。
var main = document.querySelector('#main');
// 2️⃣获取待删除节点。
// 待删除节点是父元素的第一个元素节点，很多人可能直接想到的是使用firstChild属性，这是不可取的。firstChild属性实际是取childNodes属性返回的NodeList对象中的第一个值，在此例中实际为一个换行符。
// 如果需要获取第一个元素节点，应该使用firstElementChild属性。
var firstChild = main.firstElementChild;
// 3️⃣通过父节点，调用removeChild()函数删除该节点。
main.removeChild(firstChild);
```
2. 删除a标签的href属性
删除一个元素的属性需要进行两步操作。
```js
// 1️⃣获取该元素。
var link = document.querySelector('#link');
// 2️⃣通过元素节点，调用removeAttribute()函数删除指定属性节点。
link.removeAttribute('href');
```
3. 删除ul最后一个li元素的文本节点
删除一个元素的文本节点需要进行三步操作。
```js
// 1️⃣获取元素节点。
// 在获取最后一个元素节点时，使用的是lastElementChild属性而不是lastChild属性。
var lastChild = main.lastElementChild;
// 2️⃣获取文本节点。
// 在获取文本节点时，需要使用的是childNodes属性，然后取返回的NodeList对象的第一个值。不能使用children属性，因为children属性返回的是HTMLCollection对象，表示的是元素节点，不包括文本节点内容。
var textNode = lastChild.childNodes[0];
// 3️⃣通过元素节点，调用removeChild()函数删除指定的文本节点。
lastChild.removeChild(textNode);
// 关于删除文本节点还有一种比较简单的处理方法，那就是将元素节点的innerHTML属性设置为空。
lastChild.innerHTML = '';
```
在删除文本节点时，更推荐使用设置innerHTML属性为空的方法。
### 修改节点
包含着很多不同类型的操作，包括修改元素节点、修改属性节点和修改文本节点。
```html
<div id="main">
    <!-- 测试修改元素节点 -->
    <div id="div1">替换之前的元素</div>
    <!-- 测试修改属性节点 -->
    <div id="div2" class="classA" style="color: green;">这是修改属性的节点</div>
    <!-- 测试修改文本节点 -->
    <div id="last">这是最后一个节点内容</div>
</div>
```
1. 修改元素节点

修改元素节点的操作一般是直接将节点元素替换为另一个元素，可以使用replaceChild()函数来实现。replaceChild()函数的调用方是父元素，接收两个参数，第一个参数表示新元素，第二个参数表示将要被替换的旧元素。
```html
<script>
    // 1.获取父元素与待替换的元素
    var main = document.querySelector('#main');
    var div1 = document.querySelector('#div1');
    // 2.创建新元素
    var newDiv = document.createElement('div');
    var newText = document.createTextNode('这是新创建的文本');
    newDiv.appendChild(newText);
    // 3.使用新元素替换旧的元素
    main.replaceChild(newDiv, div1);
</script>
```
2. 修改属性节点
修改属性节点有两种处理方式：
- 一种是通过getAttribute()函数和setAttribute()函数获取和设置属性节点值；另一种是直接修改属性名。
- 第二种方式有个需要注意的地方是，直接修改的属性名与元素节点中的属性名不一定是一致的。就像class这个属性，因为它是JavaScript中的关键字，是不能直接使用的，所以需要使用className来代替。
```js
var div2 = document.querySelector('#div2');
// 方法1: 通过setAttribute()函数设置
div2.setAttribute('class', 'classB');
// 方法2: 直接修改属性名，注意不能直接用class，需要使用className
div2.className = 'classC';

// 方法1: 通过setAttribute()函数设置
div2.setAttribute('style', 'color: red;');
// 方法2: 直接修改属性名
div2.style.color = 'blue';
```
3. 修改文本节点
修改文本节点与删除文本节点一样，将innerHTML属性修改为需要的文本内容即可。
```js
var last = document.querySelector('#last');
// 直接修改innerHTML属性
last.innerHTML = '这是修改后的文本内容';
//如果设置的innerHTML属性值中包含HTML元素，则会被解析
//使用如下代码进行验证
last.innerHTML = '<p style="color: red">这是修改后的文本内容</p>';
//在浏览器中渲染后，可以看到“这是修改后的文本内容”为红色
```
## 事件流
在浏览器中，JavaScript和HTML之间的交互是通过事件去实现的，常用的事件有代表鼠标单击的click事件、代表加载的load事件、代表鼠标指针悬浮的mouseover事件。
在事件发生时，会相对应地触发绑定在元素上的事件处理程序，以处理对应的操作。

通常一个页面会绑定很多的事件，那么具体的事件触发顺序是什么样的呢？

这就会涉及事件流的概念，事件流描述的是从页面中接收事件的顺序。事件发生后会在目标节点和根节点之间按照特定的顺序传播，路径经过的节点都会接收到事件。

通过下面的场景来直观地想象一下事件的流转顺序。

页面上有一个table表格，分别在table表格、tbody表格体、tr行、td单元格上绑定了click事件。假如我在td上执行了单击的操作，那么将会产生什么样的事件流呢？

- 第一种事件传递顺序是先触发最外层的table元素，然后向内传播，依次触发tbody、tr与td元素。
- 第二种事件传递顺序先触发由最内层的td元素，然后向外传播，依次触发tr、tbody与table元素。
- 第一种事件传递顺序对应的是捕获型事件流，第二种事件传递顺序对应的是冒泡型事件流。

一个完整的事件流实际包含了3个阶段：事件捕获阶段>事件目标阶段>事件冒泡阶段。
上述两种类型的事件流实际对应其中的事件捕获阶段与事件冒泡阶段。

### 事件捕获阶段
事件捕获阶段的主要表现是不具体的节点先接收事件，然后**逐级向下传播**，最具体的节点最后接收到事件。

> Window > Document > html > body > table >tbody > tr > td。

如图：
![catch]('../../assets/img/event_catch.jpg')

### 事件目标阶段
事件目标阶段表示事件刚好传播到用户产生行为的元素上，可能是事件捕获的最后一个阶段，也可能是事件冒泡的第一个阶段。

### 事件冒泡阶段
事件冒泡阶段的主要表现是最具体的元素先接收事件，然后**逐级向上传播**，不具体的节点最后接收事件

> td > tr > tbody > table > body > html > Document >Window。

```html
<table border="1">
    <tbody>
        <tr>
            <td>这是td的元素</td>
        </tr>
    </tbody>
</table>
<!-- 然后依次给table、tbody、tr、td绑定click事件。 -->
<script>
    var table = document.querySelector('table');
    var tbody = document.querySelector('tbody');
    var tr = document.querySelector('tr');
    var td = document.querySelector('td');

    table.addEventListener('click', function () {
        console.log('table触发');
    });
    tbody.addEventListener('click', function () {
        console.log('tbody触发');
    });
    tr.addEventListener('click', function () {
        console.log('tr触发');
    });
    td.addEventListener('click', function () {
        console.log('td触发');
    });
</script>
```
1️⃣使用addEventListener()函数绑定的事件在默认情况下，即**第三个参数默认为false时，按照`冒泡型`事件流处理**。

当单击td单元格元素时
```js
td触发
tr触发
tbody触发
table触发
// 从td元素开始向外依次传播，经由tr、tbody，最终到达table元素。
```

2️⃣使用addEventListener()函数同样可以很方便地创造出捕获型事件流，只需要将第三个参数设置为true即可。
```js
table.addEventListener('click', function () {
    console.log('table触发');
}, true);

tbody.addEventListener('click', function () {
    console.log('tbody触发');
}, true);

tr.addEventListener('click', function () {
    console.log('tr触发');
}, true);

td.addEventListener('click', function () {
    console.log('td触发');
}, true);
```
当单击td单元格元素时
```js
table触发
tbody触发
tr触发
td触发
// 从table元素开始向内依次传播，经由tbody、tr，最终到达td元素。
```

> 以上的两种类型全部都是按照捕获性事件流或冒泡型事件流处理的，那么如果我们修改其中的任意两种为不同的模式以达到混合型事件流，结果会怎么样呢？

假如将table与tr设置为事件捕获类型，将tbody与td设置为事件冒泡类型，得到的代码如下。
```js
// 事件捕获
table.addEventListener('click', function () {
    console.log('table触发');
}, true);

// 事件冒泡
tbody.addEventListener('click', function () {
    console.log('tbody触发');
}, false);

// 事件捕获
tr.addEventListener('click', function () {
    console.log('tr触发');
}, true);

// 事件冒泡
td.addEventListener('click', function () {
    console.log('td触发');
}, false);
```
当单击td元素时，结果如下所示。
```js
table触发
tr触发
td触发
tbody触发
```
发现事件触发时，既没有按照元素由内向外的顺序，也没有按照元素由外向内的顺序。这是为什么呢？

**因为完整的事件流是按照事件捕获阶段>事件目标阶段>事件冒泡阶段依次进行的。如果有元素绑定了捕获类型事件，则会优先于冒泡类型事件而先执行。**

整个事件流的实际执行过程分析如下。
- 事件捕获阶段，从table元素开始，table元素绑定捕获类型事件，所以最先执行，输出“table触发”。
- 事件捕获阶段，执行到tbody元素，但是tbody元素绑定的是冒泡类型事件，所以直接跳过，没有输出。
- 事件捕获阶段，执行到tr元素，tr元素绑定了捕获类型事件，所以会执行，输出“tr触发”。
- 事件目标阶段，执行到td元素，触发目标元素事件，不管是冒泡类型事件还是捕获类型事件，都会执行，输出“td触发”。
- 事件冒泡阶段，执行到tr元素，tr元素绑定了捕获类型事件，所以直接跳过，没有输出。
- 事件冒泡阶段，执行到tbody元素，tbody元素绑定了冒泡类型事件，所以会执行，输出“tbody触发”。
- 事件冒泡阶段，执行到table元素，table元素绑定了捕获类型事件，所以直接跳过，没有输出。

对table元素和td元素绑定冒泡类型事件，对tbody元素和tr元素绑定捕获类型事件，在单击td元素的时候，结果会输出什么？
```js
// 事件冒泡
table.addEventListener('click', function () {
    console.log('table触发');
}, false);

// 事件捕获
tbody.addEventListener('click', function () {
    console.log('tbody触发');
}, true);

// 事件捕获
tr.addEventListener('click', function () {
    console.log('tr触发');
}, true);

// 事件冒泡
td.addEventListener('click', function () {
    console.log('td触发');
}, false);

// tbody触发
// tr触发
// td触发
// table触发
```
## 事件处理程序👍👍👍
> 通过addEventListener()函数给元素绑定了事件处理程序，这只是其中的一种实现方式。

简单理解事件处理程序，就是响应某个事件的函数，例如onclick()函数、onload()函数就是响应单击、加载事件的函数，对应的是一段JavaScript的函数代码。

根据W3C DOM标准，事件处理程序分为DOM0、DOM2、DOM3这3种级别的事件处理程序。由于在DOM1中并没有定义事件的相关内容，因此没有所谓的DOM1级事件处理程序。

### DOM0级事件处理程序
一种是将一个函数赋值给一个事件处理属性，有两种表现形式。第一种是先通过JavaScript代码获取DOM元素，再将函数赋值给对应的事件属性。
```js
var btn = document.getElementById("btn"); 
btn.onclick = function(){}
```
还有一种是直接在html中设置对应事件属性的值，值有两种表现形式，一种是执行的函数体，另一种是函数名，然后在script标签中定义该函数。
```html
<button onclick="alert('面试厅');">单击</button>
<button onclick="clickFn()">单击</button>
<script>
    function clickFn() {
        alert('面试厅');
    }
</script>
```
以上两种同时存在时，第一种在JavaScript中定义的事件处理程序会覆盖掉后面在html标签中定义的事件处理程序。

> DOM0级事件处理程序只支持事件冒泡阶段

- 优点：简单且可以跨浏览器。
- 缺点：一个事件处理程序只能绑定一个函数。

```html
<!-- 使用两种方法绑定onclick事件处理程序。 -->
<button class="btn" id="btn" onclick="doClick()">click me</button>
<script>
var btn = document.getElementById("btn");
btn.onclick = function(){
    console.log('123'); // 123
};
function doClick() {
    console.log('456');
}
// 如需删除元素绑定的事件，只需要将对应的事件处理程序设置为null即可。
btn.onclick = null;
</script>
```
### DOM2级事件处理程序
当事件发生在节点时，目标元素的事件处理函数就会被触发，而且目标元素的每个祖先节点也会按照事件流顺序触发对应的事件处理程序。

DOM2级事件处理方式规定了添加事件处理程序和删除事件处理程序的方法

针对DOM2级事件处理程序，不同的浏览器厂商制定了不同的实现方式，主要分为IE浏览器和非IE浏览器。

IE
- 在IE10及以下版本中，只支持事件冒泡阶段。
- 在IE11中同时支持事件捕获阶段与事件冒泡阶段。在IE10及以下版本中，可以通过attachEvent()函数添加事件处理程序，通过detachEvent()函数删除事件处理程序。
```js
element.attachEvent("on"+ eventName, handler); // 添加事件处理程序
element.detachEvent("on"+ eventName, handler); // 删除事件处理程序
```
- 在IE11及其他非IE浏览器中，同时支持事件捕获和事件冒泡两个阶段，可以通过addEventListener()函数添加事件处理程序，通过removeEventListener()函数删除事件处理程序。
```js
addEventListener(eventName, handler, useCapture);     //添加事件处理程序
removeEventListener(eventName, handler, useCapture);  //删除事件处理程序
```
其中的useCapture参数表示是否支持事件捕获，true表示支持事件捕获，false表示支持事件冒泡，默认状态为false。

#### 共同点
1️⃣在DOM2级事件处理程序中，不管是IE浏览器还是非IE浏览器都支持对同一个事件绑定多个处理函数。
```js
var handler1 = function (){}
var handler2 = function (){}
// ---------------IE10及以下------------------
btn.attachEvent('onclick', handler1);
btn.attachEvent('onclick', handler2);
// ---------------IE11及非IE-----------------
btn.addEventListener('click', handler1);
btn.addEventListener('click', handler2);
```
如下面的所示，在div上同时绑定了两个click函数。
```html
<div id="wrap">单击我触发事件</div>
<script>
var wrap = document.getElementById('wrap');
wrap.addEventListener('click', function() {
    console.log('123'); // 123
}, false);
wrap.addEventListener('click', function () {
    console.log('456'); // 456
}, false);
</script>
```
2️⃣在需要删除绑定的事件时，不能删除匿名函数，因为添加和删除的必须是同一个函数。下面这种同时绑定和取消handler()函数的情况，可以删除掉绑定的事件。
```js
var wrap = document.getElementById('wrap');
var handler = function () {
    console.log('789');
};
// 第一种方式绑定和取消的是同一个函数，因此可以取消绑定的事件
wrap.addEventListener('click', handler, false);
wrap.removeEventListener('click', handler);
```
而如果采用下面这种方式，则无法取消绑定的事件，因为它们使用的都是匿名函数的形式，绑定与取消的函数并不是同一个。
```js
wrap.addEventListener('click', function () {
    console.log('123');
}, false);
wrap.removeEventListener('click', function () {});
```
#### 不同点
1️⃣在IE浏览器中，使用attachEvent()函数为同一个事件添加多个事件处理函数时，会按照添加的相反顺序执行。

```js
// 在一个button元素上使用attachEvent()函数先后绑定了两个onclick事件处理程序
var btn = document.getElementById("mybtn");
btn.attachEvent("onclick",function(){
    console.log("clicked");
});
btn.attachEvent("onclick",function(){
    console.log("hello world!"); 
});
// hello world!
// clicked
```
2️⃣在IE浏览器下，使用attachEvent()函数添加的事件处理程序会在全局作用域中运行，因此**this指向全局作用域window**。在非IE浏览器下，使用addEventListener()函数添加的事件处理程序在指定的元素内部执行，因此**this指向绑定的元素**。
```html
<button id="mybtn">单击</button>
<script>
  var btn = document.getElementById("mybtn");
  // IE浏览器
  btn.attachEvent("onclick", function () {
    alert(this); // 指向window
  });
  // 非IE浏览器
  btn.addEventListener("click", function () {
    alert(this); // 指向绑定的元素
  });
</script>
```
因为浏览器的差异性，我们需要使用不同的方法来实现DOM2级事件处理程序。如果我们想要针对不同的浏览器做兼容性处理，该如何实现呢？

```js
// 以下是一段针对不同浏览器所做的封装处理代码。
var EventUtil = {
    addEventHandler: function (element, type, handler) {
        if (element.addEventListener) {
            element.addEventListener(type, handler);
        } else if (element.attachEvent){
            element.attachEvent("on" + type, handler);
        } else {
            element["on" + type] = handler;
        }
    },
    removeEventHandler: function (element, type, handler) {
        if (element.addEventListener) {
            element.removeEventListener(type, handler);
        } else if (element.detachEvent){
            element.detachEvent("on" + type, handler);
        } else {
            element["on" + type] = null;
        }
    }
}
```
#### DOM3级事件处理程序
最重要的区别在于DOM3级事件处理程序允许自定义事件，自定义事件由createEvent("CustomEvent")函数创建，返回的对象有一个initCustomEvent()函数，通过传递对应的参数可以自定义事件。
函数可以接收以下4个参数。
- type：字符串、触发的事件类型、自定义，例如“keyDown”，“selectedChange”。
- bubble（布尔值）：表示事件是否可以冒泡。
- cancelable（布尔值）：表示事件是否可以取消。
- detail（对象）：任意值，保存在event对象的detail属性中。

创建完成的自定义事件，可以通过dispatchEvent()函数去手动触发，触发自定义事件的元素需要和绑定自定义事件的元素为同一个元素。

实现的场景是：在页面初始化时创建一个自定义事件myEvent，页面上有个div监听这个自定义事件myEvent，同时有一个button按钮绑定了单击事件；当我们单击button时，触发自定义事件，由div监听到，然后做对应的处理。
- 创建自定义事件。
- 监听自定义事件。
- 触发自定义事件。
```html
<div id="watchDiv">监听自定义事件的div元素</div>
<button id="btn">单击触发自定义事件</button>
<script>
  // 1️⃣创建自定义事件：通过立即执行函数创建一个自定义事件。该自定义事件支持冒泡而且会携带参数detailData。
  // 在创建自定义事件之前，需要判断浏览器是否支持DOM3级事件处理程序。可以通过判断下面代码的返回值来确认
  document.implementation.hasFeature('CustomEvents', '3.0'); // true：则表示浏览器支持，反之则。
  var customEvent;
  // 创建自定义事件
  (function () {
    if(document.implementation.hasFeature('CustomEvents','3.0')) {
      var detailData = { name: 'ming' };
      customEvent = document.createEvent('CustomEvent');
      customEvent.initCustomEvent("myEvent", true, false, detailData);
    }
  })();
  // 2️⃣监听自定义事件：通过addEventListener()函数监听自定义的myEvent事件。
  var div = document.querySelector("#watchDiv"); // 获取元素
  div.addEventListener('myEvent', function (e) { // 监听myEvent事件
    console.log('div监听到自定义事件的执行，携带的参数为：', e.detail);
  })
  // 3️⃣触发自定义事件：将触发自定义事件的入口放在button上，当单击button时会通过dispatchEvent()函数触发myEvent事件。
  var btn = document.querySelector('#btn'); // 获取元素
  btn.addEventListener('click', function() { // 绑定click事件，触发自定义事件
    div.dispatchEvent(customEvent);
  })
 
</script>
```
run, click button
```js
  div监听到自定义事件的执行，携带的参数为：{ name: "ming" }
```
该结果表明，在div上监听的自定义事件得到了触发，传递的detailData参数也得以接收。
自定义事件支持事件冒泡机制，可以在初始化自定义事件的initCustomEvent()函数中通过第二个参数来设置事件是否可以冒泡，上述例子中自定义的myEvent事件是支持冒泡的。
```js
// 沿用上面的例子，在document上增加了对自定义的myEvent事件的监听。
document.addEventListener('myEvent', function () {
  console.log('document监听到自定义事件的执行');
})
```
click button
```js
div监听到自定义事件的执行，携带的参数为：{ name: "ming" }
document监听到自定义事件的执行
```
通过结果可以看出，由于自定义的myEvent事件是支持事件冒泡的，所以div和document都会监听到myEvent事件的执行，输出对应的结果。
```js
// 当myEvent事件设置为不支持事件冒泡时。
if(document.implementation.hasFeature('CustomEvents', '3.0')) {
  var detailData = { name: 'ming' };
  customEvent = document.createEvent("CustomEvent");
  // 第二个参数设置为false，表示不支持事件冒泡
  customEvent.initCustomEvent('myEvent', false, false, detailData);
}
```
click button
```js
div监听到自定义事件的执行，携带的参数为：{ name: "ming" }
```
从结果可以看出，document上监听的myEvent事件并未触发，事件冒泡被阻止了。

## Event对象
> 事件在浏览器中是以Event对象的形式存在的，每触发一个事件，就会产生一个Event对象。

该对象包含所有与事件相关的信息，包括事件的元素、事件的类型及其他与特定事件相关的信息。
因为Event对象在不同浏览器中的实现是有差异性的，测试浏览器类型与版本号分别是：Safari 10.0.3版本、Firefox 61.0.1版本、Chrome 68.0.3440版本。
### 获取Event对象
在给元素绑定特定的事件处理程序时，可以获取到Event对象，但是考虑到不同浏览器的差异性，获取Event对象的方式也不同。

在事件处理程序中，获取Event对象的方式有以下两种。
- Event对象会作为参数传入，参数名为event。
- 通过window.event属性获取Event对象。
```js
// 同一个事件处理程序中
var btn = document.querySelector('#btn');
btn.addEventListener('click', function (event) {
  // 方式1：event作为参数传入
  console.log(event);
  // 方式2：通过window.event获取
  var winEvent = window.event;
  console.log(winEvent);
  console.log(event == winEvent);
})
```
分别在Chrome、Firefox和Safari浏览器中运行，并单击id为btn的按钮。
```js
// 在Chrome浏览器中运行时
MouseEvent {isTrusted: true, screenX: 119, screenY: 321, …}
MouseEvent {isTrusted: true, screenX: 119, screenY: 321, …}
true
// 在Firefox浏览器中运行时
click { target: button#btn2, buttons: 0, clientX: 145, …}
undefined
false
// 在Safari浏览器中运行时
MouseEvent {isTrusted: true, screenX: 119, screenY: 321, …}
MouseEvent {isTrusted: true, screenX: 119, screenY: 321, …}
true
```
> Chrome浏览器和Safari浏览器同时支持两种方式获取event对象，而Firefox浏览器只支持这种将event作为参数传入的方式。

```js
// 在获取事件对象时，为了支持不同浏览器，可以通过以下代码来实现兼容。
var EventUtil = {
  // 获取事件对象
  getEvent: function (event) {
    return event || window.event;
  }
}
```
### 获取事件的目标元素
在IE浏览器中，event对象使用srcElement属性来表示事件的目标元素；而在非IE浏览器中，event对象使用target属性来表示事件的目标元素，为了提供与IE浏览器下event对象相同的特性，某些非IE浏览器也支持srcElement属性。

```js
// 在同一个事件处理程序中使用上述两种属性来获取事件的目标元素。
btn.addEventListener('click', function (event) {
  // 获取event对象
  var event = EventUtil.getEvent(event);
  // 使用两种属性获取事件的目标元素
  var NolETarget = event.target;
  var IETarget = event.srcElement;
  console.log(NolETarget);
  console.log(IETarget);
})
```
分别在Chrome、Firefox和Safari浏览器中运行，并单击id为btn的按钮。
```js
// 在Chrome浏览器中运行时
<button id="btn">单击</button>
<button id="btn">单击</button>
// 在Firefox浏览器中运行时
<button id="btn">单击</button>
undefined
// 在Safari浏览器中运行时
<button id="btn">单击</button>
<button id="btn">单击</button>
```
从结果可以看出，Chrome浏览器和Safari浏览器同时支持两种属性来获取事件目标元素，而Firefox浏览器只支持event.target属性来获取事件目标元素。
```js
// 兼容
var EventUtil = {
  // 获取事件目标元素
  getTarget: function () {
    return event.target || event.srcElement;
  }
}
```
### target与currentTarget属性
> 两者都可以表示事件的目标元素，但是在事件流中两者却有不同的意义。

- target属性在**事件目标阶段**，理解为真实操作的目标元素。
- currentTarget属性**在事件捕获、事件目标、事件冒泡**这3个阶段，理解为当前事件流所处的某个阶段对应的目标元素。

使用table元素，分别在table、tbody、tr、td元素上绑定事件捕获阶段和事件冒泡阶段的click事件。click事件中输出对应的target属性和currentTarget属性值，为了更直观地看出结果，我们取target对象的tagName属性来获取标签名。
```html
<table border="1">
    <tbody>
        <tr>
            <td>这是td的元素</td>
        </tr>
    </tbody>
</table>
<script>
  var table = document.querySelector('table');
  var tbody = document.querySelector('tbody');
  var tr = document.querySelector('tr');
  var td = document.querySelector('td');
  // 获取target属性和currentTarget属性的元素标签名
  function getTargetAndCurrentTarget(event, stage) {
      var event = EventUtil.getEvent(event);
      var stageStr;
      if (stage === 'bubble') {
          stageStr = '事件冒泡阶段';
      } else if(stage === 'capture'){
          stageStr = '事件捕获阶段';
      } else {
          stageStr = '事件目标阶段';
      }
      console.log(stageStr, 'target:' + event.target.tagName.toLowerCase(),  'currentTarget: ' + event.currentTarget.tagName.toLowerCase());
  }

  // 事件捕获
  table.addEventListener('click', function (event) {
      getTargetAndCurrentTarget(event, 'capture');
  }, true);
  // 事件捕获
  tbody.addEventListener('click', function (event) {
      getTargetAndCurrentTarget(event, 'capture');
  }, true);
  // 事件捕获
  tr.addEventListener('click', function (event) {
      getTargetAndCurrentTarget(event, 'capture');
  }, true);
  // 事件捕获
  td.addEventListener('click', function (event) {
      getTargetAndCurrentTarget(event, 'target');
  }, true);

  // 事件冒泡
  table.addEventListener('click', function (event) {
      getTargetAndCurrentTarget(event, 'bubble');
  }, false);
  // 事件冒泡
  tbody.addEventListener('click', function (event) {
      getTargetAndCurrentTarget(event, 'bubble');
  }, false);
  // 事件冒泡
  tr.addEventListener('click', function (event) {
      getTargetAndCurrentTarget(event, 'bubble');
  }, false);
  // 事件冒泡
  td.addEventListener('click', function (event) {
      getTargetAndCurrentTarget(event, 'target');
  }, false);
</script>
```
当**单击td元素**时，会触发整个事件流，得到的结果如下所示。
```js
事件捕获阶段 target:td currentTarget: table
事件捕获阶段 target:td currentTarget: tbody
事件捕获阶段 target:td currentTarget: tr
事件目标阶段 target:td currentTarget: td
事件目标阶段 target:td currentTarget: td
事件冒泡阶段 target:td currentTarget: tr
事件冒泡阶段 target:td currentTarget: tbody
事件冒泡阶段 target:td currentTarget: table
```
为什么会得出这个结果呢？

在事件流的任何阶段，target属性始终指向的是实际操作的元素。因为我们是在td元素上进行的单击操作，所以target属性对应的是td。

在事件流的事件捕获阶段或者事件冒泡阶段，currentTarget指向的是事件流所处的某个特定阶段对应的元素。在该实例中，事件捕获阶段元素的流转顺序为`table > tbody > tr`，事件冒泡阶段元素的流转顺序为`tr > tbody > table`。

在事件目标阶段，currentTarget属性指向的也是实际操作的元素，即td。
因此只有在事件目标阶段，target属性和currentTarget属性才指向同一个元素。

#### 练习
页面上有一个ul-li标签，同时在ul和第一个li上绑定事件冒泡阶段的click事件，所有代码如下所示。
```html
<ul id="ul">
    <li id="li">第一个元素</li>
    <li>第二个元素</li>
</ul>
<script>
    var ul = document.querySelector('#ul');
    var li = document.querySelector('#li');
    ul.addEventListener('click', function (event) {
        getTargetAndCurrentTarget(event, 'bubble');
    });
    li.addEventListener('click', function (event) {
        getTargetAndCurrentTarget(event, 'bubble');
    });
</script>
```
click li
```js
// I
li li
li ul
// result
事件冒泡阶段 target:li currentTarget: li
事件冒泡阶段 target:li currentTarget: ul
```
### 阻止事件冒泡
有一个表示学生基础信息的容器ul，每个li元素都表示一个学生的基本信息，单击li元素会改变li的背景色以表示选中的标识。在每个li元素内部会有一个表示删除的button按钮，单击button按钮则会提示是否删除，单击确定则会删除该元素。
```html
<ul>
    <li>
        <p>姓名:小明</p>
        <p>学号:20180101</p>
        <button class="btn btn-default" id="btn">删除</button>
    </li>
</ul>
<script>
    var li = document.querySelector('li');
    var btn = document.querySelector('#btn');
    li.addEventListener('click', function (event) {
        // 真实操作，使用console来代替
        console.log('单击了li，做对应的处理');
    });
    btn.addEventListener('click', function (event) {
        // 真实操作，使用console来代替
        console.log('单击了button，做对应的处理');
    });
</script>
```
click button
```js
单击了button，做对应的处理
单击了li，做对应的处理
```
由于事件冒泡的存在，在单击button按钮时，事件同样会冒泡至父元素li上，因此两个click事件都会被触发。

阻止事件冒泡：在button按钮的click事件中调用event.stopPropagation()函数。在单击button按钮时，事件就**只会在事件目标阶段执行**，而不会向上继续冒泡至父元素li中，从而达到目的。
```js
btn.addEventListener('click', function (event) {
    var event = EventUtil.getEvent(event);
    // 阻止事件冒泡
    event.stopPropagation();
    // 真实操作，使用console来代替
    console.log('单击了button，做对应的处理');
});
```
click button
```js
单击了button,做对应的处理
```
event对象中还存在一个stopImmediatePropagation()函数，它和stopPropagation()函数有什么区别呢？
两者的区别主要体现在同一事件绑定多个事件处理程序的情况下。
- stopPropagation()函数仅会阻止事件冒泡，其他事件处理程序仍然可以调用。
- stopImmediatePropagation()函数不仅会阻止冒泡，也会阻止其他事件处理程序的调用。

沿用上面实例的代码，对button按钮的click事件增加3个事件处理程序，在第二个事件处理程序中使用stopPropagation()函数来阻止事件冒泡。
```js
var li = document.querySelector('li');
var btn = document.querySelector('#btn');
li.addEventListener('click', function (event) {
    // 真实操作，使用console来代替
    console.log('单击了li，做对应的处理');
});

// 第一个事件处理程序
btn.addEventListener('click', function (event) {
    // 真实操作，使用console来代替
    console.log('button的第一个事件处理程序，做对应的处理');
});

// 第二个事件处理程序
btn.addEventListener('click', function (event) {
    var event = EventUtil.getEvent(event);
    // 阻止事件冒泡
    event.stopPropagation();
    // 真实操作，使用console来代替
    console.log('button的第二个事件处理程序，做对应的处理');
    });

// 第三个事件处理程序
btn.addEventListener('click', function (event) {
    // 真实操作，使用console来代替
    console.log('button的第三个事件处理程序，做对应的处理');
});
```
click button
```js
button的第一个事件处理程序，做对应的处理
button的第二个事件处理程序，做对应的处理
button的第三个事件处理程序，做对应的处理
```
从结果可以看出，事件冒泡被阻止，li上的事件处理程序并未触发；绑定的3个事件处理程序都被触发执行。

使用stopImmediatePropagation()函数
```js
// 第二个事件处理程序
btn.addEventListener('click', function (event) {
    var event = EventUtil.getEvent(event);
    // 阻止事件冒泡
    event.stopImmediatePropagation();
    // 真实操作，使用console来代替
    console.log('btn的第二个事件处理程序，做对应的处理');
});
```
click button
```js
button的第一个事件处理程序，做对应的处理
button的第二个事件处理程序，做对应的处理
```
从结果可以看出，事件冒泡被阻止，li上的事件处理程序并未触发；只有第一个和第二个事件处理程序被触发执行，而第三个事件处理程序并未执行。
### 阻止默认行为
在众多的HTML标签中，有一些标签是具有默认行为的，这里简单地列举3个。
- a标签，在单击后默认行为会跳转至href属性指定的链接中。
- 复选框checkbox，在单击后默认行为是选中的效果。
- 输入框text，在获取焦点后，键盘输入的值会对应展示到text输入框中。

在一般情况下我们是允许标签的默认行为的，就像用户的正常操作，但是在某些时候我们是需要阻止这些标签的默认行为的，同样使用上述3种场景作为说明。
- a标签，假如a标签上显示的文案不符合预期，我们在单击a标签时将不会跳转至对应的链接中去。
- 复选框checkbox，假如已选中的复选框在单击的时候不会被取消，依然是选中的状态。
- 输入框text，假如我们限制用户输入的值只能是数字和大小写

那么该如何编写代码来阻止元素的默认行为呢？
> 通过event.preventDefault()函数去实现。

场景描述：限制用户输入的值只能是数字和大小写字母，其他的值则不能输入，如输入其他值则给出提示信息，提示信息在两秒后消失。

在本实例中，因为涉及键盘输入，所以我们需要监听keypress事件，通过兼容性来处理获取当前按键的值，然后判断输入的值是否合法，从而控制键盘输入的行为。

键盘的每个键有对应的Unicode编码。
需要获取的数字和字母的Unicode编码范围如下所示。
- 数字的Unicode编码范围是48～57。
- 大写字母A～Z的Unicode编码范围是65～90。
- 小写字母a～z的Unicode编码范围是97～122。

同样是因为浏览器的兼容性问题，Event对象提供了多种不同的属性来获取键的Unicode编码，分别是event.keyCode、event.charCode和event.which。
```js
// 兼容性处理
var charCode = event.keyCode || event.which || event.charCode;
```
最终所得的代码如下所示
```html
<input type="text" id="text">
<div id="tip"></div>
<script>
    var text = document.querySelector('#text');
    var tip = document.querySelector('#tip');
    text.addEventListener('keypress', function (event) {
        var charCode = event.keyCode || event.which || event.charCode;
        // 满足输入数字
        var numberFlag = charCode <= 57 && charCode >= 48;
        // 满足输入大写字母
        var lowerFlag = charCode <= 90 && charCode >= 65;
        // 满足输入小写字母
        var supperFlag = charCode <= 122 && charCode >= 97;

        if (!numberFlag && !lowerFlag && !supperFlag) {
            // 阻止默认行为，不允许输入
            event.preventDefault();
            tip.innerText = '只允许输入数字和大小写字母';
        }
        // 设置定时器,清空提示语
        setTimeout(function () {
            tip.innerText = '';
        }, 2000);
    });
</script>
```
运行上面的代码，在页面出现的text文本框中进行输入，输入0～9或大小写字母时可以正常输入，而输入下画线（_）、加号（+）等字符时是无法输入的，同时文本框下会出现“只允许输入数字和大小写字母”的提示。

## 事件委托
> **利用事件冒泡原理**，管理某一类型的所有事件，利用父元素来代表子元素的某一类型事件的处理方式。
### 已有元素的事件绑定 
场景：假如页面上有一个ul标签，里面包含1000个li子标签，我们需要在单击每个li时，输出li中的文本内容。

1. 给每个li标签绑定一个click事件，在click事件中输出li标签的文本内容
```html
<ul>
    <li>文本1</li>
    <li>文本2</li>
    <li>文本3</li>
    <li>文本4</li>
    <li>文本5</li>
    <!-- 剩余995 -->
</ul>
<script>
    // 1.获取所有的li标签
    var children = document.querySelectorAll('li');
    // 2.遍历添加click事件处理程序
    for (var i = 0; i < children.length; i++) {
        children[i].addEventListener('click', function () {
            console.log(this.innerText);
        });
    }
</script>
```
click li
```js
文本1
文本6
文本9
文本7
```
采用上述的方法对浏览器的性能是一个很大的挑战，主要包含以下两方面原因。
- 事件处理程序过多导致页面交互时间过长。
假如有1000个li元素，则需要绑定1000个事件处理程序，而事件处理程序需要不断地与DOM节点进行交互，因此引起浏览器重绘和重排的次数也会增多，从而会延长页面交互时间。
- 事件处理程序过多导致内存占用过多。
在JavaScript中，一个事件处理程序其实就是一个函数对象，会占用一定的内存空间。假如页面有10000个li标签，则会有10000个函数对象，占用的内存空间会急剧上升，从而影响浏览器的性能。

解决办法：利用事件委托机制。
主要思想是将事件绑定至父元素上，然后利用事件冒泡原理，当事件进入冒泡阶段时，通过绑定在父元素上的事件对象来判断当前事件流正在进行的元素。如果和期望的元素相同，则执行相应的事件代码。
```js
// 1.获取父元素
var parent = document.querySelector('ul');
// 2.父元素绑定事件
parent.addEventListener('click', function (event) {
    // 3.获取事件对象
    var event = EventUtil.getEvent(event);
    // 4.获取目标元素
    var target = EventUtil.getTarget(event);
    // 5.判断当前事件流所处的元素
    if (target.nodeName.toLowerCase() === 'li') {
          // 6.与目标元素相同，做对应的处理
        console.log(target.innerText);
    }
});
```
可以看出，事件是绑定在父元素ul上的，不管子元素li有多少个，也不会影响到页面中事件处理程序的个数，因此可以极大地提高浏览器的性能。

如果同一个ul下的li存在针对不同元素所做的处理不一样，依然可以使用事件委托。

场景：在页面上有4个button按钮，分别表示增加、删除、修改、查询这4个功能。每个按钮绑定相同的click事件处理程序，但是具体的行为不同。在这4个按钮触发click事件后，分别输出“新增”“删除”“修改”“查询”等文字。
```html
<div id="box">
    <input type="button" id="add" value="新增" />
    <input type="button" id="remove" value="删除" />
    <input type="button" id="update" value="修改" />
    <input type="button" id="search" value="查询" />
</div>
<script>
  // 传统写法
    var add = document.querySelector('#add');
    var remove = document.querySelector('#remove');
    var update = document.querySelector('#update');
    var search = document.querySelector('#search');
    // 新增按钮绑定事件
    add.addEventListener('click', function () {
        console.log('新增');
    });
    // 删除按钮绑定事件
    remove.addEventListener('click', function () {
            console.log('删除');
    });
    // 修改按钮绑定事件
    update.addEventListener('click', function () {
        console.log('修改');
    });
    // 查询按钮绑定事件
    search.addEventListener('click', function () {
        console.log('查询');
    });
</script>
```
对于不同的按钮都需要绑定一个click事件处理程序，这样在性能上会存在一定的影响。

使用事件委托：
- 获取button的父元素，在父元素上绑定click事件处理程序。
- 获取event事件对象，紧接着通过event事件对象获取到目标元素。
- 获取目标元素的id值，与HTML元素中各个button的id进行比较，输出对应的文字。
```js
// 1.获取父元素，并绑定事件处理程序
var parent = document.querySelector('#parent');
parent.addEventListener('click', function (event) {
    // 2.获取event和target
    var event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);
    // 3.判断id属性，输出对应的文字
    switch (target.id) {
        case 'add':
            console.log('新增');
            break;
        case 'remove':
            console.log('删除');
            break;
        case 'update':
            console.log('修改');
            break;
        case 'search':
            console.log('查询');
            break;
    }
});
```
### 新创建元素的事件绑定
场景：假如页面上有一个ul标签，里面包含9个li子标签，我们需要在单击每个li时，输出li中的文本内容；在页面上有一个button按钮，单击button按钮会创建一个新的li元素，单击新创建的li元素，输出它的文本内容。
#### 手动绑定方法
```html
<ul>
    <li>文本1</li>
    <li>文本2</li>
    <li>文本3</li>
    <li>文本4</li>
    <li>文本5</li>
    <li>文本6</li>
    <li>文本7</li>
    <li>文本8</li>
    <li>文本9</li>
</ul>
<script>
// 1.获取所有的li标签
var children = document.querySelectorAll('li');
// 2.遍历添加click事件处理程序
for (var i = 0; i < children.length; i++) {
    children[i].addEventListener('click', function () {
        console.log(this.innerText);
    });
}
</script>
```
然后在页面上添加一个button按钮，用于新增一个li元素。
```js
<button id="add">新增</button>
var ul = document.querySelector('ul');
var add = document.querySelector('#add');
add.addEventListener('click', function () {
    // 创建新的li元素
    var newLi = document.createElement('li');
    var newText = document.createTextNode('文本10');
    newLi.appendChild(newText);
    // 添加至父元素ul中
    ul.appendChild(newLi);
});
```
1. click button, append li：文本10。
2. click new li,  no log。

why?
因为通过querySelectorAll()函数获取到的li元素虽然会**实时感知到数量的变化**，但并**不会实时增加对事件的绑定**。如果需要新元素也具有相同的事件，则需要手动调用事件绑定的代码。

解决方案如下。
1️⃣将遍历添加click事件处理程序代码封装成一个函数。
```js
function bindEvent() {
  for(var i = 0; i < children.length; i++) {
    children[i].addEventListener('click', function() {
      console.log(this.innerText);
    })
  }
}
```
2️⃣在添加完新元素后，重新调用一次1️⃣中封装的函数。
```js
add.addEventListener('click', function() {
  var newLi = document.createElement('li');
  var newText = document.createTextNode('文本10');
  newLi.appendChild(newText);
  ul.appendChild(newLi);
  // 重新添加事件处理程序
  bindEvent();
})
```
每次在新增一个元素后都需要手动绑定事件处理程序，这样的操作是很烦琐的，而且随着绑定的事件处理程序越来越多，性能也将受到影响。

#### 事件委托方法
> 可以更加方便快捷地实现新创建元素的事件绑定。由于事件委托机制是利用的事件冒泡机制，即使在元素自身没有绑定事件的情况下，事件仍然会冒泡到父元素中，因此对于新增的元素，只要处理事件流就可以触发其事件。
```html
<script>
    // 1.获取父元素
    var parent = document.querySelector('ul');
    // 2.父元素绑定事件
    parent.addEventListener('click', function (event) {
        // 3.获取事件对象
        var event = EventUtil.getEvent(event);
        // 4.获取目标元素
        var target = EventUtil.getTarget(event);
        // 5.判断当前事件流所处的元素
        if (target.nodeName.toLowerCase() === 'li') {
            // 6.与目标元素相同，做对应的处理
            console.log(target.innerText);
        }
    });
</script>
```
然后在页面上添加一个button按钮，用于新增一个li元素。
```js
<button id="add">新增</button>
var ul = document.querySelector('ul');
var add = document.querySelector('#add');
add.addEventListener('click', function () {
    // 创建新的li元素
    var newLi = document.createElement('li');
    var newText = document.createTextNode('文本10');
    newLi.appendChild(newText);
    // 添加至父元素ul中
    ul.appendChild(newLi);
});
```
1. click button, append li。
2. click new li, log: 文本10。

## contextmenu右键事件
在JavaScript中有一系列常用的事件类型，这里总结如下。
- 焦点相关的focus、blur等事件。
- 单击相关的click、dblclick、contextmenu等事件。
- 鼠标相关的mouseover、mouseout、mouseenter等事件。
- 键盘相关的keydown、keypress、keyup事件。
- 拖曳相关的drag事件。
- 移动端touch事件。

通过contextmenu事件来实现一个定制化的鼠标右键效果。
通过右击会出现自定义的内容，而且绑定了click事件，在单击各个选项时会输出对应的内容。
```html
<ul class="tasks" id="tasks">
    <li class="task" data-id="1">
        <div class="task_ _content">first content</div>
    </li>
    <li class="task" data-id="2">
        <div class="task_ _content">second content</div>
    </li>
    <li class="task" data-id="3">
        <div class="task_ _content">third content</div>
    </li>
    <li class="task" data-id="4">
        <div class="task_ _content">fourth content</div>
    </li>
    <li class="task" data-id="5">
        <div class="task_ _content">fifth content</div>
    </li>
</ul>
<!-- 右击出现的自定义菜单 -->
<nav class="context-menu" id="context-menu">
    <ul class="context-menu_ _items">
        <li class="context-menu_ _item">
            <a href="#" class="context-menu_ _link" data-action="view">
                <i class="fa fa-eye m-r-5"></i>View Task
            </a>
        </li>
        <li class="context-menu_ _item">
            <a href="#" class="context-menu_ _link" data-action="edit">
                <i class="fa fa-edit m-r-5"></i>Edit Task
            </a>
        </li>
        <li class="context-menu_ _item">
            <a href="#" class="context-menu_ _link" data-action="delete">
                <i class="fa fa-times m-r-5"></i>Delete Task
            </a>
        </li>
    </ul>
</nav>
<script>
  // 自定义菜单元素
  var menu = document.querySelector('#context-menu');
  // 自定义菜单状态
  var menuState = 0;
  // 自定义菜单显示样式
  var active = 'context-menu--active';
  // 自定义菜单位置对象
  var menuPosition;
  // 自定义菜单水平位置
  var menuPositionX;
  // 自定义菜单纵向位置
  var menuPositionY;
  // 单击的li元素
  var targetLi;
  // 初始化事件
  function init() {
      //给li元素添加右键事件
      contextListener();
      //单击事件，单击后隐藏menu
      clickListener();
      //keyup事件，当按下ESC键时隐藏menu
      keyupListener();
      //菜单的单击事件
      menuListener();
  }
  // -----------------通过事件委托，给li元素添加右键事件。-------------------
// 给li元素添加右键事件
function contextListener() {
  document.addEventListener('contextmenu', function(e) {
    if (clickInContextLister(e)) {
      e.preventDefault();
      targetLi = e.target;
      // 显示自定义菜单
      toggleMenuOn();
      // 定位自定义菜单的位置
      positionMenu(e);
    } else {
      targetLi = null;
      // 隐藏自定义菜单
      toggleMenuOff();
    }
  })
}
// 判断单击的位置是否处于li元素内部。
// 只需要判断当前单击元素或者其祖先元素的nodeName属性是否为“LI”即可。
function clickInContextLister(e) {
  var target = e.target || e.srcElement;
  while(target) {
    if (target.nodeName.toUpperCase() === 'LI') {
      return true;
    }
    // 往上追溯父元素
    target = target.parentNode;
  }
  return false;
}
// 单击后，隐藏自定义菜单。
function clickLister() {
  document.addEventListener('click', function (e) {
    // 监听鼠标按键，左键是1，滚轮是2，右键是3
    var code = e.which || e.button;
    if (code === 1) {
      // 隐藏自定义菜单
      toggleMenuOff();
    }
  });
}
// 按下ESC键时隐藏自定义菜单。
function keyupListener() {
  window.addEventListener('keyup', function (e) {
    if(e.keyCode === 27) {
      // 隐藏自定义菜单
      toggleMenuOff();
    }
  })
}
// 右击出现菜单后，单击自定义菜单选项事件。
function menuListener() {
  menu.addEventListener('click', function (e) {
    if (e.target.nodeName.toUpperCase() === 'A') {
      var result = 'the operation is: ' + e.target.dateset.action + '\nthe id is: ' + targetLi.dataset.id;
      alert(result); 
    }
  })
}
// 显示自定义菜单。
function toggleMenuOn() {
  if (menuState !== 1) {
    menuState = 1;
    menu.classList.add(active);
  }
}
// 隐藏自定义菜单。
function toggleMenuOff() {
   if (menuState !== 0) {
    menuState = 0;
    menu.classList.add(active);
  }
}
// 根据事件触发的位置返回具体的坐标点。
function getPosition(e) {
  var posx = 0;
  var posy = 0;
  if (!e) var e = window.event;
  if (e.pageX || e.pageY) {
    posx = e.pageX;
    posy = e.pageY;
  } else if (e.clientX || e.clientY) {
    posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
    posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
  }
  return {
    x: posx,
    y: posy
  }
}
// 确定自定义菜单出现的位置
function positionMenu(e) {
    menuPosition = getPosition(e);
    menuPositionX = menuPosition.x + 'px';
    menuPositionY = menuPosition.y + 'px';
    menu.style.left = menuPositionX;
    menu.style.top = menuPositionY;
}
</script>
```
## 文档加载完成事件
在实际开发中，经常会遇到这样的场景：在页面初始化的时候去执行特定的操作，例如一个电商网站页面，在用户登录进入首页后获取用户常买的商品列表。

这个场景涉及页面初始化的操作。页面初始化的操作可以理解为文档加载完成后执行的操作，所以这一场景可以理解为文档加载完成后执行特定的事件。

在DOM中，文档加载完成有两个事件，一个是load事件，在原生JavaScript和jQuery中均有实现；另一个是jQuery提供的ready事件。
- ready事件的触发表示文档结构已经加载完成，不包含图片、flash等非文字媒体内容。
- onload事件的触发表示页面中包含的图片、flash等所有元素都加载完成。
### load事件
> load事件会在页面、脚本或者图片加载完成后触发。其中，支持onload事件的标签有body、frame、frameset、iframe、img、link、script。

如果load事件用于页面初始化，则有两种实现方式。第一种方式是在body标签上使用onload属性，类似于onclick属性的设置，其实就是**DOM0级事件处理程序**。
```html
<!-- 使用onload属性 -->
<body onload="bodyLoad()">
<script>
    function bodyLoad() {
        console.log('文档加载完成，执行onload方法');
    }
</script>
</body>
```
第二种方式是设置window对象的onload属性，属性值为一个函数。
```js
window.onload = function () {
    console.log('文档加载完成，执行onload方法');
};
```
使用以上两种方式中的任何一种，页面在加载完成后，都会输出“文档加载完成，执行onload方法”。
第一种方式的优先级会高于第二种方式，如果同时采用两种方式，则只有第一种方式会生效。

load事件有哪些使用场景：
很多时候会将JavaScript代码块写在一个单独的文件中，然后通过script标签进行引用。在使用script标签进行引用时，为了方便JavaScript代码的组织，会将其统一放在head标签中。由于head标签会先于body标签进行解析，因此如果JavaScript代码包含了对body标签中其他标签的处理，就会出现代码中操作的对象未被加载的情况。
通过以下场景来看看，页面中有一个div元素，初始化内容为“页面初始化”，等到页面加载完成后div元素内容变为“页面加载完成”。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>
        document.querySelector('#content').innerText = '页面加载完成';
    </script>
</head>
<body>
   <div id="content">页面初始化</div>
</body>
</html>
```
运行上面的代码后，发现页面上显示的内容为“页面初始化”，而并不是“页面加载完成”。

这是因为script脚本在执行代码时，并未解析到body标签处，id为content的元素并不存在，所以通过`document.querySelector('#content')`获取到的元素其实为null，然后设置innerText属性时会报错。

load事件会在页面中的所有元素全部加载完成后才会去调用，因此如果在load事件中获取id为content的元素是可以获取到的，然后就可以进行对应的操作。
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>
        window.onload = function () {
            document.querySelector('#content').innerText = '页面加载完成';
        };
    </script>
</head>
<body>
   <div id="content">页面初始化</div>
</body>
</html>
```
在代码运行后发现，页面上显示的内容为“页面加载完成”。

此外，在jQuery中同样提供了对load事件的实现，那就是load()函数，其语法格式如下所示。
```js
$(window).load(function(){...});
$(document).load(function(){...}); // 不会生效
```
jQuery的load()函数具有的功能与原生JavaScript的onload()函数是一致的，而且相比于window.onload()函数还有两大优点。
- 可以同时绑定多个$(window).load()函数。
```js
// 假如在页面加载完成之后，需要同时触发多个操作，可以同时编写多个$(window).load()函数。
// 操作1
$(window).load(function () {
    // do action1
});
// 操作2
$(window).load(function () {
    // do action2
});
// 操作3
$(window).load(function () {
    // do action3
});
```
而使用window.load()函数则不能达到这个目的，因为window.load()函数只能绑定一个事件处理程序。
```html
<!-- 在body标签中使用onload属性可以达到这个目的，在写法上如下所示。 -->
<body onload="fn1(),fn2(),fn3()"></body>
<!-- 代码看起来不规整，因此并不推荐这种写法。 -->
```
- 使用$(window).load()函数可以将JavaScript代码与HTML代码进行分离，而设置body标签的onload属性不可以将JavaScript代码与HTML代码进行完全隔离。一旦代码冗余在一起，后续的代码维护将会变得越来越困难。

到这里了解了load事件的执行原理，那么它是不是初始化完成最好的实现方案呢？并不是的，试想一下，对于一个图片网站来说，如果需要等到所有的图片都加载完成再去执行相应的操作，这将会给用户带来一段很长的等待时间，因为图片的加载相比于普通的HTML元素会消耗更长的时间。
### ready事件
> ready事件只需要等待文档结构加载完成就可以执行。

针对一个图片网站，使用ready事件，我们只需要等待HTML中的所有的img标签加载完成就可以执行初始化操作，而不需要等到img标签的src属性完全加载出来。这样将节省很长的等待时间，对性能来说是一大提升。

> ready事件并不是原生JavaScript所具有的，而是在**jQuery**中实现的，ready事件挂载在document对象上。

```js
// 使用语法
$(document).ready(function () {...});
// 因为ready()函数仅能用于当前文档，无须选择器，所以可以省略掉document而简写为如下代码。
$().ready(function () {...});
// 又因为$默认的事件为ready事件，所以ready()函数也可以省略，从而更加精简，代码如下所示。
$(function () {...});
```
在同一个页面中使用上述3种方式定义ready事件。
```js
// 方式1:最完整写法
$(document).ready(function () {
    console.log('方式1:最完整写法');
});
// 方式2:省略document的写法
$().ready(function () {
    console.log('方式2:省略document的写法');
});
// 方式3:最精简的写法
$(function () {
    console.log('方式3:最精简的写法');
});
```
run
```js
方式1:最完整写法
方式2:省略document的写法
方式3:最精简的写法
```
### 加载完成事件的执行顺序
页面加载完成一共有5种处理方式。
- 使用jQuery的$(document).ready(function () {...})。
- 使用jQuery的$(function () {...})，其实是上一种方式的简写。
- 使用jQuery的$(window).load(function(){...})。
- 使用原生JavaScript的window.onload= function(){...}。
- 在body标签上使用onload属性，`<body onload="bodyLoad()"></body>`。

在同一个页面中同时使用5种的执行顺序。
事件的执行顺序会随着事件定义顺序的不同而不同。而事件的定义会写在script标签中，具体来说就是script标签所放的位置，一个是将script标签写在head标签中，一个是将script标签写在body标签中。
#### 将script标签写在head标签中
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ready与load事件执行顺序</title>
 <script src="https://cdnjs.cloudﬂare.com/ajax/libs/jquery/1.9.0/jquery.min.
js"></script>
    <script>
        // 方式1: $(document).ready()
        $(document).ready(function () {
            console.log('执行方式1: $(document).ready()');
        });
        // 方式2: $(function(){})
        $(function () {
            console.log('执行方式2: $(function(){})');
        });
        // 方式3: $(window).load()
        $(window).load(function () {
            console.log('执行方式3: $(window).load()');
        });
        // 方式4: window.onload
        window.onload = function () {
            console.log('执行方式4: window.onload');
        };
        // 方式5: body标签的onload属性
        function bodyOnLoad() {
            console.log('执行方式5: body标签的onload属性');
        }
    </script>
</head>
<body onload="bodyOnLoad()">
</body>
</html>
```
run
```js
执行方式1: $(document).ready()
执行方式2: $(function(){})
执行方式3: $(window).load()
执行方式5: body标签的onload属性
```
#### 将script标签写在body标签中
```html
<<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ready与load事件执行顺序</title>
</head>
<body onload="bodyOnLoad()">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.0/jquery.min.
js"></script>
<script>
    // 方式1: $(document).ready()
    $(document).ready(function () {
        console.log('执行方式1: $(document).ready()');
    });
    // 方式2: $(function(){})
    $(function () {
        console.log('执行方式2: $(function(){})');
    });
    // 方式3: $(window).load()
    $(window).load(function () {
        console.log('执行方式3: $(window).load()');
    });
    // 方式4: window.onload
    window.onload = function () {
        console.log('执行方式4: window.onload');
    };
    // 方式5: body标签的onload属性
    function bodyOnLoad() {
        console.log('执行方式5: body标签的onload属性');
    }
</script>
</body>
</html>
```
run
```js
执行方式1: $(document).ready()
执行方式2: $(function(){})
执行方式4: window.onload
执行方式3: $(window).load()
```
通过以上两种不同的执行结果可以得出以下结论。
1️⃣ 使用jQuery的ready事件总会比load事件先执行，jQuery提供的ready事件的两种形式其实是等效的，定义在前面的会先执行。
2️⃣ load事件的执行顺序取决于方法定义中的位置，当将script标签写在body标签中时，方式4中window.onload会比方式3中jQuery的load()函数先执行。
3️⃣ 写在body标签中的onload属性优先级会高于window.onload属性。
4️⃣ 方式4中window.onload与方式3中jQuery的load()函数，是谁先定义则谁先执行。
## 浏览器的重排和重绘
> 虽然可以通过JavaScript操作DOM元素，但是代价却是高昂的。

可以将DOM和JavaScript想象成两个岛，它们之间的连接需要通过一座桥，而JavaScript对DOM的访问就需要通过这座桥，并收取“过桥费”，随着对DOM访问次数的增加，费用也就越高，因此我们需要尽量减少“过桥”的次数，也就是减少对DOM的访问和修改，而这也是**优化DOM性能**的手段之一。

> 对DOM的修改相比于对DOM的访问，在性能上的影响会更大，这是因为它会带来浏览器的重排或重绘。

浏览器渲染HTML的过程：
- HTML文件被HTML解析器解析成对应的DOM树，CSS样式文件被CSS解析器解析生成对应的样式规则集。
- DOM树与CSS样式集解析完成后，附加在一起形成一个渲染树。
- 节点信息的计算，即根据渲染树计算每个节点的几何信息。
- 渲染绘制，即根据计算完成的节点信息绘制整个页面。
[渲染HTML](./assets/drowio/draw_html.drawio ':include :type=code')

### 重排👍👍👍
> 浏览器渲染页面默认采用的是流式布局模型。

所以对某一个DOM节点信息进行修改时，就需要对该DOM结构进行重新计算。
该DOM结构的修改会决定周边DOM结构的更改范围，主要分为全局范围和局部范围。
- 全局范围就是从页面的根节点html标签开始，对整个渲染树进行重新计算。
  - 例如，当我们改变窗口的尺寸或者修改了根元素的字体大小时
- 局部范围只会对渲染树的某部分进行重新计算
  - 例如要改变页面中某个div的宽度，只需要重新计算渲染树中与该div相关的部分即可。

而重排的过程就发生在DOM节点信息修改的时候，重排实际是根据渲染树中每个渲染对象的信息，计算出各自渲染对象的几何信息，例如DOM元素的位置、尺寸、大小等，然后将其安置在界面中正确的位置。

重排是一种明显的改变页面布局的操作，下面总结了常见的引起重排的操作。
1. 页面首次渲染。
在页面首次渲染时，HTML页面的各个元素位置、尺寸、大小等信息均是未知的，需要通过与CSS样式规则集才能确定各个元素的几何信息。这个过程中会产生很多元素几何信息计算的过程，所以会产生重排操作。
2. 浏览器窗口大小发生改变
页面渲染完成后，就会得到一个固定的渲染树。如果此时对浏览器窗口进行缩放或者拉伸操作，渲染树中从根元素html标签开始的所有元素，都会重新计算其几何信息，从而产生重排操作。
3. 元素尺寸或位置发生改变。
4. 元素内容发生变化。
5. 元素字体发生变化。
上述3种情况，均是直观地表述DOM元素几何属性的变化。这些操作均会导致渲染树中相关的节点失效，浏览器会根据DOM元素的变化，重新构建渲染树中失效的节点，从而产生重排操作。
6. 添加或删除可见的DOM元素。
因为浏览器采用的是流式布局模型，实际为从上到下、从左到右依次遍历元素的过程。通常情况下，如果添加或者删除可见的DOM元素，则当前元素之前的元素不会受到影响；而当前元素之后的元素均会重新计算几何信息，渲染树也需要重新构建修改后的节点，从而产生重排操作。
7. 获取某些特定的属性。
也许几行简单的JavaScript代码就会引起很多重排的操作，而频繁的重排操作会对浏览器引擎产生很大的消耗。所以浏览器不会针对每个JS操作都进行一次重排，而是维护一个会引起重排操作的队列，等队列中的操作达到了一定的数量或者到了一定的时间间隔时，浏览器才会去flush一次队列，进行真正的重排操作。

虽然浏览器会有这个优化，但我们写的一些代码可能会强制浏览器提前flush队列，例如我们获取以下这些样式信息的时候。
- offsetTop, offsetLeft, offsetWidth, offsetHeight
- scrollTop/Left/Width/Height
- clientTop/Left/Width/Height
- width,height
- 调用getComputedStyle()函数
当我们请求以上这些属性时，浏览器为了返回最精准的信息，需要flush队列，因为队列中的某些操作可能会影响到某些值的获取。因此，即使你获取的样式信息与队列中的操作无关，浏览器仍然会强制flush队列，从而引起浏览器重排的操作。

在获取以下一些常见的属性和函数时，会引发重排的操作。
- width：宽度。
- height：高度。
- margin：外边距。
- padding：内边距。
- display：元素显示方式。
- border：边框。
- position：元素定位方式。
- overflow：元素溢出处理方式。
- clientWidth：元素可视区宽度。
- clientHeight：元素可视区高度。
- clientLeft：元素边框宽度。
- clientTop：元素边框高度。
- offsetWidth：元素水平方向占据的宽度。
- offsetHeight：元素水平方向占据的高度。
- offsetLeft：元素左外边框至父元素左内边框的距离。
- offsetTop：元素上外边框至父元素上内边框的距离。
- scrollWidth：元素内容占据的宽度。
- scrollHeight：元素内容占据的高度。
- scrollLeft：元素横向滚动的距离。
- scrollTop：元素纵向滚动的距离。
- scrollIntoView()：元素滚动至可视区的函数。
- scrollTo()：元素滚动至指定坐标的函数。
- getComputedStyle()：获取元素的CSS样式的函数。
- getBoundingClientRect()：获取元素相对于视窗的位置集合的函数。
- scrollIntoViewIfNeeded()：元素滚动至浏览器窗口可视区的函数。（非标准特性，谨慎使用）

### 重绘
> 重绘只是改变元素在页面中的展现样式，而不会引起元素在文档流中位置的改变。

例如更改了元素的字体颜色、背景色、透明度等，浏览器均会将这些新样式赋予元素并重新绘制。

在修改某些常见的属性时，会引发重绘的操作，接下来列举出了一部分。
- color：颜色。
- border-style：边框样式。
- visibility：元素是否可见。
- background：元素背景样式，包括背景色、背景图、背景图尺寸、背景图位置等。
- text-decoration：文本装饰，包括文本加下画线、上划线、贯穿线等。
- outline：元素的外轮廓的样式，在边框外的位置。
- border-radius：边框圆角。
- box-shadow：元素的阴影。

重排与重绘的操作它们之间有什么关系呢？
**重排一定会引起重绘的操作，而重绘却不一定会引起重排的操作。**
因为在元素重排的过程中，元素的位置等几何信息会重新计算，并会引起元素的重新渲染，这就会产生重绘的操作。而在重绘时，只是改变了元素的展现样式，而不会引起元素在文档流中位置的改变，所以并不会引起重排的操作。

### 性能优化
> 减少浏览器的重排与重绘是因为它们是比较消耗性能的操作。
#### 将多次改变样式的属性操作合并为一次
修改一个元素的样式，如果只修改style属性。
```js
var changeDiv = document.querySelector('#changeDiv');
changeDiv.style.width = '100px';
changeDiv.style.background = '#e3e3e3';
changeDiv.style.height = '100px';
changeDiv.style.marginTop = '10px';
```
上面的操作多次修改了style属性，会引发多次重排与重绘的操作。可以将这些CSS属性合并为一个class类。
```css
div.changeDiv {
    width: '100px',
    background: #e3e3e3;
    height: 100px;
    margin-top: 10px;
}
```
然后通过JavaScript直接修改元素的class类。
```js
document.getElementById('changeDiv').className = 'changeDiv';
```
这样就可以只在最后一步修改class类，从而只引起一次重排与重绘的操作。

#### 将需要多次重排的元素设置为绝对定位
> 常见的操作就是设置其position为absolute或者fixed。

需要进行重排的元素都是处于正常的文档流中的，如果这个元素不处于文档流中，那么它的变化就不会影响到其他元素的变化，这样就不会引起重排的操作。

假如一个页面有动画元素，如果它会频繁地改变位置、宽高等信息，那么最好将其设置为绝对定位

#### 在内存中多次操作节点，完成后再添加至文档树中
需求：通过异步请求获取表格的数据后，将其渲染到页面上。
这个需求可以有两种实现方式，一种是每次构造一行数据的HTML片段，分多次添加到文档树中；另一种是先在内存中构建出完整的HTML片段，再一次性添加到文档树中。
```js
// 方法1：每次构造一行数据，多次添加。
// 将数据渲染至table
function renderTable(list) {
    // 目标table元素
    var table = $('#table');
    var rowHTML = '';
    // 遍历数据集
    list.forEach(function(item) {
        rowHTML += '<tr>';
        rowHTML += '<td>' + item.name + '</td>';
        rowHTML += '<td>' + item.address + '</td>';
        rowHTML += '<td>' + item.email + '</td>';
        rowHTML += '</tr>';
        // 每次添加一行数据
        table.append($(rowHTML));
        // 添加完后清空
        rowHTML = '';
    });
}
// 方法2：一次性构造完整的数据，然后添加。
// 将数据渲染至table
function renderTable(list) {
    // 目标table元素
    var table = $('#table');
    var allHTML = '';
    // 遍历数据集
    list.forEach(function(item) {
        allHTML += '<tr>';
        allHTML += '<td>' + item.name + '</td>';
        allHTML += '<td>' + item.address + '</td>';
        allHTML += '<td>' + item.email + '</td>';
        allHTML += '</tr>';
    });
    // 获取完整片段后,一次性渲染
    table.append($(allHTML));
}
```
在方法1中每次添加一行数据时，都会引发一次浏览器重排和重绘的操作，如果表格的数据很大，则会对渲染造成很大的影响。而方法2在内存中一次性构造出完整的HTML代码段，再通过一次操作去渲染表格，这样只会引起一次浏览器重排和重绘的操作，从而带来很大的性能提升。

#### 将要进行复杂处理的元素处理为display属性为none，处理完成后再进行显示
因为display属性为none的元素不会出现在渲染树中，所以对其进行处理并不会引起其他元素的重排。当我们需要对一个元素做复杂处理时，可以将其display属性设置为none，操作完成后，再将其显示出来，这样就**只会在隐藏和显示的时候引发两次重排操作**。

#### 将频繁获取会引起重排的属性缓存至变量
在获取一些特定属性时，会引发重排或者重绘的操作。因此在获取这些属性时，应该通过一个变量去缓存，而不是每次都直接获取特定的属性。

场景：在获取一个特定元素后，根据几个不同的判断条件，需要改变元素的宽度。
```js
// ❌不推荐以下这种写法。
var element = document.querySelector('#ele');
// 判断条件1
if(true) {
    element.style.width = '200px';
}
// 判断条件2
if(true) {
    element.style.width = '300px';
}
// 判断条件3
if(true) {
    element.style.width = '400px';
}
// 在使用这种写法时，在条件都通过后，需要获取3次width属性，从而会引发3次重排的操作。

// ✔推荐以下这种写法。
var ele = document.querySelector('#ele');
// 先获取width属性
var width = ele.style.width;
// 判断条件1
if(true) {
    width = '200px';
}
// 判断条件2
if(true) {
    width = '300px';
}
// 判断条件3
if(true) {
    width = '400px';
}
// 最后执行一次width属性赋值
ele.style.width = width;
```
这种写法只会在开始时获取一次width属性，判断条件执行结束后进行一次width属性的赋值，所以不管中间执行了多少次逻辑处理，始终只会有两次重排的操作。相比于前一种方法，每执行一个判断逻辑就产生一次重排的操作会提升一定的性能。

#### 尽量减少使用table布局
如果table中任何一个元素触发了重排的操作，那么整个table都会触发重排的操作，尤其是当一个table内容比较庞大时，更加不推荐使用table布局。

如果不得已使用了table，可以设置table-layout:auto或者是table-layout:fixed。这样可以让table一行一行地渲染，这种做法也是为了限制重排的影响范围。

#### [使用事件委托绑定事件处理程序](#事件委托)
在对多个同级元素做事件绑定时，推荐使用事件委托机制进行处理。使用事件委托可以在很大程度上减少事件处理程序的数量，从而提高性能。

#### 利用DocumentFragment操作DOM节点
> DocumentFragment是一个没有父级节点的最小文档对象，它可以用于存储已经排好版或者尚未确定格式的HTML片段。

DocumentFragment最核心的知识点在于它不是真实DOM树的一部分，它的变化不会引起DOM树重新渲染的操作，也就不会引起浏览器重排和重绘的操作，从而带来性能上的提升。

因为DocumentFragment具有的特性，在需要频繁进行DOM新增或者删除的操作中，它将变得非常有用。

一般的操作方法分为以下两步。
- 将需要变更的DOM元素放置在一个新建的DocumentFragment中，因为DocumentFragment不存在于真实的DOM树中，所以这一步操作不会带来任何性能影响。
- 将DocumentFragment添加至真正的文档树中，这一步操作处理的不是DocumentFragment自身，而是DocumentFragment的全部子节点。对DocumentFragment的操作来说，只会产生一次浏览器重排和重绘的操作，相比于频繁操作真实DOM元素的方法，会有很大的性能提升。

应用场景：假如往页面的ul元素中添加100个li元素。
有两种实现方法，一种是通过createElement()函数来实现，另一种是通过createDocumentFragment()函数来实现。

接下来分别通过两段代码与运行结果来看看它们的处理效率。
##### createElement()函数
```html
<!-- 最原始的一种方法 -->
<ul id="list"></ul>
<script>
  var list = document.querySelector('#list');
  for (var i = 0; i < 100; i++) {
    var li = document.createElement('li');
    var text = document.createTextNode('节点' + i);
    li.append(text);
    list.append(li);
  }
</script>
```
list在每次append新元素li时，都会引发一次重排的操作。
##### createDocumentFragment()函数
使用DocumentFragment()函数时一般分为3步。
- 创建一个新的DocumentFragment对象。
- 将待处理的元素添加至DocumentFragment对象中。
- 处理DocumentFragment对象。

```html
<ul id="list2"></ul>
<script>
  var list = document.querySelector('#list2');
  // 1.新创建的DocumentFragment对象
  var fragment = document.createDocumentFragment();
  for(var i = 0; i < 100; i++) {
    var li = document.createElement('li');
    var text = document.createTextNode('节点' + i);
    li.append(text);
    // 2.将新增的元素添加至DocumentFragment对象中
    fragment.append(li);
  }
  // 3.处理DocumentFragment对象
  list.append(fragment);
</script>
```
使用DocumentFragment()函数处理DOM元素时，只有在最终append的时候才会去真正处理真实的DOM元素，因此只会引发一次重排操作，从而提升了浏览器渲染的性能。
