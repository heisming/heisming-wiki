# DOM与事件
DOM是文档对象模型，全称为Document Object Model。DOM用一个逻辑树来表示一个文档，树的每个分支终点都是一个节点，每个节点都包含着对象。
DOM提供了对文档结构化的表述，通过绑定不同的事件可以改变文档的结构、样式和内容，从而能实现“动态”的页面。
## DOM选择器
### 传统原生JavaScript选择器
为了能更直观地看到DOM选择器的效果，我们编写了一个HTML页面，然后通过DOM选择器定位元素，改变对应的展示内容。

HTML页面中主要是定义一系列的ul-li标签，然后通过DOM选择器定位li后并操作它们，初始代码如下所示。
```html
<ul>
    <li>节点1.1</li>
    <li>节点1.2</li>
    <li>节点1.3</li>
    <li>节点1.4</li>
    <li>节点1.5</li>
    <li>节点1.6</li>
    <li>节点1.7</li>
</ul>
<ul>
    <li>节点2.1</li>
    <li>节点2.2</li>
    <li>节点2.3</li>
    <li>节点2.4</li>
    <li>节点2.5</li>
    <li>节点2.6</li>
    <li>节点2.7</li>
</ul>
```
#### 通过id定位
```html
<!-- id唯一 -->
<ul>
    <li id="one">节点1.1</li>
    <li id="one">节点1.2</li>
    <li>节点1.3</li>
    <li>节点1.4</li>
</ul>
```
当具有相同id的元素时，除了第一个元素能被匹配到外，其他元素都会被忽略。
```js
document.getElementById('one').innerText; // 节点1.1
```
#### 通过class定位
> getElementsByClassName()函数，通过类名定位元素，返回由匹配到的元素构成的HTMLCollection对象，它是一个类数组结构。
```html
<li class="one">节点1.2</li>
<li class="one">节点1.3</li>
```
```js
document.getElementsByClassName('one');
// 返回值为一个HTMLCollection对象，里面包含匹配到的两个li元素值。
HTMLCollection(2) [li.one, li.one]
 - 0: li.one
 - 1: li.one
 - length: 2
 - __proto__:  HTMLCollection
```
#### 通过name属性定位
> getElementsByName()函数，通过元素的name属性进行定位，返回由匹配到的元素构成的NodeList对象，它是一个类数组结构。
```html
<ul>
    <li id="one">节点1.1</li>
    <li name="node">节点1.4</li>
    <li name="node">节点1.5</li>
</ul>
<ul>
    <li name="node">节点2.1</li>
    <li>节点2.2</li>
</ul>
```

```js
document.getElementsByName('node');
// 返回的值为一个NodeList对象，里面包含匹配到的name属性为“node”的元素。
NodeList(3) [li, li, li]
 - 0: li
 - 1: li
 - 2: li
 - length: 3
 -  __proto__:  NodeList
```
#### 通过标签名定位
> getElementsByTagName()函数，通过标签名定位元素，返回由匹配到的元素构成的HTMLCollection对象。
```js
// 通过标签名获取页面上的两个ul元素。
document.getElementsByTagName('ul');
// 返回值为一个HTMLCollection对象，里面包含匹配到的两个ul元素值。
HTMLCollection(2) [ul, ul]
- 0: ul
- 1: ul
- length: 2
- __proto__: HTMLCollection
```
### 新型的querySelector选择器和querySelectorAll选择器
使用传统的id、name、class等选择器来查找元素时，只能调用document具有的函数，在查找特定元素的子元素时不太方便。
#### querySelector选择器
> querySelector选择器返回的是在基准元素下，选择器匹配到的元素集合中的第一个元素。

语法如下所示。
```js
element = baseElement.querySelector(selectors);
```
其中，
- baseElement是基准元素，返回的元素必须是匹配到的基准元素的第一个子元素。该基准元素可以为Document，也可以为基本的Element。
- selectors是一个标准的CSS选择器，而且必须是合法的选择器，否则会引起语法错误。
- 返回值为匹配到的第一个子元素。匹配的过程中不仅仅针对基准元素的后代元素，实际上会遍历整个文档结构，包括基准元素和它的后代元素以外的元素。实际处理过程是首先创建一个匹配元素的初始列表，然后判断每个元素是否为基准元素的后代元素，第一个属于基准元素的后代元素将会被返回。
```html
<div>
  <h5>Original content</h5>
  <span>outside span</span>
  <p class="content">
    inside paragraph
    <span>inside span</span>
    inside paragraph
  </p>
</div>
```

```js
// 获取p元素的第一个span元素。
document.querySelector('p span').innerText; // inside span
// 获取class为content的元素的第一个span元素。
document.querySelector('.content span').innerText; // inside span
// 获取第一个span或者h5元素。
document.querySelector('h5, span').innerText // Original content
```
然后通过以下这段代码来验证上述返回值的匹配过程。
```js
var baseElement = document.querySelector("p");
console.log(baseElement.querySelector("div span").innerText); // inside span
```
第一行代码获取的基准元素为p元素，第二行代码中的选择器为“div span”。虽然在p元素中没有div元素，却依旧能匹配到span元素。这是因为在匹配过程会优先找出div元素下span元素的集合，然后判断span元素是否属于p元素的子元素，最后返回第一个匹配到的span元素值。

#### querySelectorAll选择器
> querySelectorAll选择器与querySelector选择器类似，区别在于querySelectorAll选择器会返回基准元素下匹配到的所有子元素的集合。

语法如下所示。
```js
elementList = baseElement.querySelectorAll(selectors);
// 它同样包含基准元素与选择器，返回值是一个NodeList的集合。
```

```html
<div>
    <h5>Original content</h5>
    <span>outside span</span>
    <p class="content">
        inside paragraph
        <span>inside span</span>
        inside paragraph
    </p>
</div>
```

```js
// 获取所有的span元素。
document.querySelectorAll('span');
// 其返回值如下所示。
NodeList(2) [span, span]
 - 0: span
 - 1: span
 - length: 2
 - __proto__:  NodeList
```
querySelectorAll选择器匹配过程与querySelector选择器一样，优先获取所有匹配元素的集合，然后判断每个元素是否属于基准元素。如果属于则返回结果，最终返回一个NodeList对象。

理解querySelectorAll选择器匹配元素的过程。
```html
<div id="my-id">
    <img id="inside">
    <div class="lonely"></div>
    <div class="outer">
        <div class="inner"></div>
    </div>
</div>
<script>
    var firstArr = document.querySelectorAll('#my-id div div');
        var secondArr = document.querySelector('#my-id').querySelectorAll('div div');
    console.log(firstArr);
    console.log(secondArr);
</script>
```
上面代码的主要目的是找出在id为“my-id”元素的子div中子div元素的集合。分别使用两种写法获取到了firstArr和secondArr两个值。
提问：firstArr和secondArr返回的NodeList值是否是一样的？答案：不一样。实际上它们输出的结果如下所示。
```js
firstArr   NodeList [div.inner]
        - 0: div.inner
        - length: 1
        - __proto__: NodeList
secondArr  NodeList(3) [div.lonely, div.outer, div.inner]
        - 0: div.lonely
        - 1: div.outer
        - 2: div.inner
        - length: 3
        - __proto__: NodeList
```
可以看出firstArr表示的NodeList对象的长度为1，而secondArr表示的NodeList对象的长度为3，为什么呢？

针对firstArr，querySelectorAll选择器的调用方是document，则基准元素为document；执行CSS选择器，匹配到的元素只有一个，如下代码所示。
```html
<div class="inner"></div>
```
该元素属于document中的子元素，最终返回结果如下所示。
```js
NodeList [div.inner]
```

针对secondArr，先通过querySelector选择器确定基准元素是id为“my-id”的元素，然后执行CSS选择器，选择器的内容是匹配div元素中的子div元素。
HTML代码对应的文档结构内，有3个元素是匹配的。
- id为“my-id”的div元素的第一个子节点。`<div class="lonely"></div>`
- id为“my-id”的div元素的第二个子节点。 `<div class="outer">...</div>`
- class为“outer”的div元素的第一个子节点。`<div class="inner"></div>`

紧接着判断这3个匹配的元素是否为基准元素的子元素，发现它们都是处于基准元素内部的，最终这3个值构成一个NodeList集合返回。
```js
NodeList(3) [div.lonely, div.outer, div.inner]
```
##### 特例👍👍👍
> 一个页面是不允许有相同id的元素的。如果出现了相同的id，则无法通过getElementById()函数获取到除第一个元素以外的元素。对于querySelectorAll选择器来说却是一个特例。将id选择器传入querySelectorAll选择器中后，可以通过id获取多个匹配的元素，然后通过索引获取特定的值。
```html
<div>
    <p id="first">文本1</p>
    <p id="first">文本2</p>
    <p id="first">文本3</p>
    <p id="first">文本4</p>
</div>
<script>
    console.log(document.querySelectorAll('#first').length);  // 4
    console.log(document.querySelectorAll('#first')[3].innerText); // 文本4
</script>
```
> 虽然querySelectorAll选择器也可以处理出现相同id的情况，按照HTML编写的规范，**绝对不允许**一个页面出现相同id的元素。
## HTMLCollection对象与NodeList对象
不同的DOM选择器，它们的返回值有些是NodeList对象，有些是HTMLCollection对象。那么它们有什么区别呢？

下面这段代码，主要是对children属性和childNodes属性的调用。
```html
<div id="main">
    <p class="first">first</p>
    <p class="second">second<span>content</span></p>
</div>
<script>
    var main = document.getElementById("main");
    console.log(main.children);
    console.log(main.childNodes);
</script>
```
得到的结果如下所示。
```js
HTMLCollection(2) [p.first, p.second]
 - 0: p.first
 - 1: p.second
 - length: 2
 -  __proto__:  HTMLCollection
NodeList(5) [text, p.first, text, p.second, text]
 - 0: text
 - 1: p.first
 - 2: text
 - 3: p.second
 - 4: text
 - length: 5
 -  __proto__:  NodeList
```
### HTMLCollection对象
HTMLCollection对象具有length属性，返回集合的长度，可以通过item()函数和namedItem()函数来访问特定的元素。
#### item()函数
可以调用item()函数，通过序号来获取特定的某个节点，超过索引则返回“null”。
```html
<div id="main">
    <p class="first">first</p>
    <p class="second">second</p>
    <p class="third">third</p>
    <p class="four">four</p>
</div>
<script>
    var main = document.getElementById("main").children;
    console.log(main.item(0)); // <p class="first">first</p>
    console.log(main.item(2)); // <p class="third">third</p>
</script>
```
#### namedItem()函数
用来返回一个节点。
首先通过id属性去匹配，然后如果没有匹配到则使用name属性匹配，如果还没有匹配到则返回“null”。当出现重复的id或者name属性时，只返回匹配到的第一个值。
```html
<form id="main">
    <input type="text" id="username">
    <input type="text" name="username">
    <input type="text" name="password">
</form>
<script>
    var main = document.getElementById("main").children;
    console.log(main.namedItem('username')); // <input type="text" id="username">
</script>
```
### NodeList对象
> NodeList对象也具有length属性，返回集合的长度，也同样具有item()函数，通过索引定位子元素的位置。同HTMLCollection。

### HTMLCollection对象和NodeList对象的实时性
> 两者并不是历史文档状态的静态快照，而是具有**实时性**的。对DOM树新增或者删除一个相关节点，都会立刻反映在HTMLCollection对象与NodeList对象中。

HTMLCollection对象与NodeList对象都只是类数组结构，并不能直接调用数组的函数。
而通过call()函数和apply()函数处理为真正的数组后，它们就转变为一个真正的**静态值**了，不会再动态反映DOM的变化。
```html
<form id="main">
    <input type="text" id="username">
    <input type="text" name="password">
</form>
<script>
    // 获取HTMLCollection
    var mainChildren = document.getElementById('main').children;
        console.log(mainChildren.length);  // 2

    // 新增一个input元素
    var newInput = document.createElement('input');
    main.appendChild(newInput);
    console.log(mainChildren.length);  // 3

    // 通过call()函数处理成数组结构
    mainChildren = Array.prototype.slice.call(mainChildren, 0);
    mainChildren.splice(1, 1);
    console.log(mainChildren.length);  // 2

    // 再新增一个input元素
    var newInput2 = document.createElement('input');
    main.appendChild(newInput2);
    console.log(mainChildren.length);  // 2

</script>
```
NodeList对象与HTMLCollection对象相比，存在一些细微的差异，主要表现在不是所有的函数获取的NodeList对象都是实时的。例如通过querySelectorAll()函数获取的NodeList对象就不是实时的。
```html
<ul id="main">
    <li>文本1</li>
    <li>文本2</li>
    <li>文本3</li>
    <li>文本4</li>
    <li>文本5</li>
</ul>
<script>
    // 获取ul
    var main = document.getElementById('main');
    // 获取li集合
    var lis = document.querySelectorAll('ul li');
    // 第一次输出li集合长度，值为5
    console.log(lis.length);

    // 新增li元素
    var newLi = document.createElement('li');
    var text = document.createTextNode('文本8');
    newLi.appendChild(text);
    main.appendChild(newLi);
    // 再次输出li集合长度，值为5
    console.log(lis.length);
    // 重新获取li的集合并输出长度，值为6
    console.log(document.querySelectorAll('ul li').length);
</script>
```
综上所述，两者具有以下的相同点和不同点。
#### 相同点
- 都是类数组对象，有length属性，可以通过call()函数或apply()函数处理成真正的数组。
- 都有item()函数，通过索引定位元素。
- 都是实时性的，DOM树的变化会及时反映到HTMLCollection对象和NodeList对象上，只是在某些函数调用的返回结果上会存在差异。
#### 不同点
- HTMLCollection对象比NodeList对象多个namedItem()函数，可以通过id或者name属性定位元素。
- HTMLCollection对象只包含元素的集合（Element），即具有标签名的元素；而NodeList对象是节点的集合，既包括元素，也包括节点，例如text文本节点。

## 常用的DOM操作
> 文档树是由各种类型节点构成的集合，DOM操作实际是对文档结构中节点的操作。
> 文档结构树中的节点类型众多，但是操作的主要节点类型为元素节点、属性节点和文本节点。
```html
<!DOCTYPE html>
<html>
<head>
    <title>文档标题</title>
</head>
<body>
  <a href="http://www.mianshiting.com">我的链接</a>
  <h1>我的标题</h1>
</body>
</html>
```
如果将这些节点画成一个树的话:
[文档](./assets/drowio/document.drawio ':include :type=code')
- 元素节点是拥有一对开闭合标签的元素整体，例如常见的div、ul、li标签都是元素节点。
  - `<div></div>，<ul></ul>，<li></li>`
- 属性节点是元素节点具有的属性，例如a标签的href属性。
- 文本节点是DOM中用于呈现文本内容的节点，例如h1标签内部的“我的标题”。
- 其中元素节点和文本节点存在父子关系，而元素节点与属性节点并不存在父子关系。

### 新增节点
> 两个步骤，首先是新建节点，然后将节点添加至指定的位置。
```html
<ul id="container">
    <li class="first">文本1</li>
    <li class="second">文本2</li>
    <li>文本3</li>
    <li id="target">文本4</li>
    <li>文本5</li>
    <li>文本6</li>
</ul>
```
需要完成这样一个操作：第一步，在ul的末尾添加一个li元素，其类名为“last”，内容为“新增文本1”；第二步，在新增的li之前再新增第二个li，内容为“新增文本2”。
```js
// 1️⃣获取指定元素。
var container = document.querySelector('#container');
// 2️⃣新建创建一个元素节点。
var newLiOne = document.createElement('li');
// 3️⃣新建一个属性节点，并设置值。
var newLiAttr = document.createAttribute('class');
newLiAttr.value = 'last';
// 4️⃣将属性节点绑定在元素节点上。
newLiOne.setAttributeNode(newLiAttr);
// 5️⃣新建一个文本节点。
var newTextOne = document.createTextNode('新增文本1');
// 6️⃣将文本节点作为元素节点的子元素。
newLiOne.appendChild(newTextOne);
// 7️⃣使用appendChild()函数将新增元素节点添加至末尾。
container.appendChild(newLiOne);
// 8️⃣新创建第二个元素节点。
var newTextTwo = document.createTextNode('新增文本2');
// 9️⃣新创建第二个文本节点。
var newTextTwo = document.createTextNode('新增文本2');
// 🔟将文本节点作为元素节点的子元素。
newLiTwo.appendChild(newTextTwo);
// 🔟+1️⃣使用insertBefore()函数将节点添加至第一个新增节点的前面。
container.insertBefore(newLiTwo, newLiOne);
```
至此，完成指定的两个新增操作。

在新增属性节点时，还有另外一种更简单的setAttribute()函数。以上面代码为例，可以通过下面这一行代码完成上述3️⃣4️⃣这两步共3行代码的功能。
```js
newLiOne.setAttribute('class', 'last'); // 不兼容IE8及更早的版本
```
### 删除节点
删除节点的操作实际包含删除元素节点、删除属性节点和删除文本节点。
```html
<ul id="main">
    <li>文本1</li>
    <li>文本2</li>
    <li>文本3</li>
</ul>
<a id="link" href="http://www.mianshiting.com">面试厅</a>
```
1. 删除ul的第一个li元素节点
删除一个元素节点需要进行三步操作。
```js
// 1️⃣获取该元素的父元素。
var main = document.querySelector('#main');
// 2️⃣获取待删除节点。
// 待删除节点是父元素的第一个元素节点，很多人可能直接想到的是使用firstChild属性，这是不可取的。firstChild属性实际是取childNodes属性返回的NodeList对象中的第一个值，在此例中实际为一个换行符。
// 如果需要获取第一个元素节点，应该使用firstElementChild属性。
var firstChild = main.firstElementChild;
// 3️⃣通过父节点，调用removeChild()函数删除该节点。
main.removeChild(firstChild);
```
2. 删除a标签的href属性
删除一个元素的属性需要进行两步操作。
```js
// 1️⃣获取该元素。
var link = document.querySelector('#link');
// 2️⃣通过元素节点，调用removeAttribute()函数删除指定属性节点。
link.removeAttribute('href');
```
3. 删除ul最后一个li元素的文本节点
删除一个元素的文本节点需要进行三步操作。
```js
// 1️⃣获取元素节点。
// 在获取最后一个元素节点时，使用的是lastElementChild属性而不是lastChild属性。
var lastChild = main.lastElementChild;
// 2️⃣获取文本节点。
// 在获取文本节点时，需要使用的是childNodes属性，然后取返回的NodeList对象的第一个值。不能使用children属性，因为children属性返回的是HTMLCollection对象，表示的是元素节点，不包括文本节点内容。
var textNode = lastChild.childNodes[0];
// 3️⃣通过元素节点，调用removeChild()函数删除指定的文本节点。
lastChild.removeChild(textNode);
// 关于删除文本节点还有一种比较简单的处理方法，那就是将元素节点的innerHTML属性设置为空。
lastChild.innerHTML = '';
```
在删除文本节点时，更推荐使用设置innerHTML属性为空的方法。
### 修改节点
包含着很多不同类型的操作，包括修改元素节点、修改属性节点和修改文本节点。
```html
<div id="main">
    <!-- 测试修改元素节点 -->
    <div id="div1">替换之前的元素</div>
    <!-- 测试修改属性节点 -->
    <div id="div2" class="classA" style="color: green;">这是修改属性的节点</div>
    <!-- 测试修改文本节点 -->
    <div id="last">这是最后一个节点内容</div>
</div>
```
1. 修改元素节点

修改元素节点的操作一般是直接将节点元素替换为另一个元素，可以使用replaceChild()函数来实现。replaceChild()函数的调用方是父元素，接收两个参数，第一个参数表示新元素，第二个参数表示将要被替换的旧元素。
```html
<script>
    // 1.获取父元素与待替换的元素
    var main = document.querySelector('#main');
    var div1 = document.querySelector('#div1');
    // 2.创建新元素
    var newDiv = document.createElement('div');
    var newText = document.createTextNode('这是新创建的文本');
    newDiv.appendChild(newText);
    // 3.使用新元素替换旧的元素
    main.replaceChild(newDiv, div1);
</script>
```
2. 修改属性节点
修改属性节点有两种处理方式：
- 一种是通过getAttribute()函数和setAttribute()函数获取和设置属性节点值；另一种是直接修改属性名。
- 第二种方式有个需要注意的地方是，直接修改的属性名与元素节点中的属性名不一定是一致的。就像class这个属性，因为它是JavaScript中的关键字，是不能直接使用的，所以需要使用className来代替。
```js
var div2 = document.querySelector('#div2');
// 方法1: 通过setAttribute()函数设置
div2.setAttribute('class', 'classB');
// 方法2: 直接修改属性名，注意不能直接用class，需要使用className
div2.className = 'classC';

// 方法1: 通过setAttribute()函数设置
div2.setAttribute('style', 'color: red;');
// 方法2: 直接修改属性名
div2.style.color = 'blue';
```
3. 修改文本节点
修改文本节点与删除文本节点一样，将innerHTML属性修改为需要的文本内容即可。
```js
var last = document.querySelector('#last');
// 直接修改innerHTML属性
last.innerHTML = '这是修改后的文本内容';
//如果设置的innerHTML属性值中包含HTML元素，则会被解析
//使用如下代码进行验证
last.innerHTML = '<p style="color: red">这是修改后的文本内容</p>';
//在浏览器中渲染后，可以看到“这是修改后的文本内容”为红色
```
## 事件流
在浏览器中，JavaScript和HTML之间的交互是通过事件去实现的，常用的事件有代表鼠标单击的click事件、代表加载的load事件、代表鼠标指针悬浮的mouseover事件。
在事件发生时，会相对应地触发绑定在元素上的事件处理程序，以处理对应的操作。

通常一个页面会绑定很多的事件，那么具体的事件触发顺序是什么样的呢？

这就会涉及事件流的概念，事件流描述的是从页面中接收事件的顺序。事件发生后会在目标节点和根节点之间按照特定的顺序传播，路径经过的节点都会接收到事件。

通过下面的场景来直观地想象一下事件的流转顺序。

页面上有一个table表格，分别在table表格、tbody表格体、tr行、td单元格上绑定了click事件。假如我在td上执行了单击的操作，那么将会产生什么样的事件流呢？

- 第一种事件传递顺序是先触发最外层的table元素，然后向内传播，依次触发tbody、tr与td元素。
- 第二种事件传递顺序先触发由最内层的td元素，然后向外传播，依次触发tr、tbody与table元素。
- 第一种事件传递顺序对应的是捕获型事件流，第二种事件传递顺序对应的是冒泡型事件流。

一个完整的事件流实际包含了3个阶段：事件捕获阶段>事件目标阶段>事件冒泡阶段。
上述两种类型的事件流实际对应其中的事件捕获阶段与事件冒泡阶段。

### 事件捕获阶段
事件捕获阶段的主要表现是不具体的节点先接收事件，然后**逐级向下传播**，最具体的节点最后接收到事件。

> Window > Document > html > body > table >tbody > tr > td。

如图：
![catch]('../../assets/img/event_catch.jpg')

### 事件目标阶段
事件目标阶段表示事件刚好传播到用户产生行为的元素上，可能是事件捕获的最后一个阶段，也可能是事件冒泡的第一个阶段。

### 事件冒泡阶段
事件冒泡阶段的主要表现是最具体的元素先接收事件，然后**逐级向上传播**，不具体的节点最后接收事件

> td > tr > tbody > table > body > html > Document >Window。

```html
<table border="1">
    <tbody>
        <tr>
            <td>这是td的元素</td>
        </tr>
    </tbody>
</table>
<!-- 然后依次给table、tbody、tr、td绑定click事件。 -->
<script>
    var table = document.querySelector('table');
    var tbody = document.querySelector('tbody');
    var tr = document.querySelector('tr');
    var td = document.querySelector('td');

    table.addEventListener('click', function () {
        console.log('table触发');
    });
    tbody.addEventListener('click', function () {
        console.log('tbody触发');
    });
    tr.addEventListener('click', function () {
        console.log('tr触发');
    });
    td.addEventListener('click', function () {
        console.log('td触发');
    });
</script>
```
1️⃣使用addEventListener()函数绑定的事件在默认情况下，即**第三个参数默认为false时，按照`冒泡型`事件流处理**。

当单击td单元格元素时
```js
td触发
tr触发
tbody触发
table触发
// 从td元素开始向外依次传播，经由tr、tbody，最终到达table元素。
```

2️⃣使用addEventListener()函数同样可以很方便地创造出捕获型事件流，只需要将第三个参数设置为true即可。
```js
table.addEventListener('click', function () {
    console.log('table触发');
}, true);

tbody.addEventListener('click', function () {
    console.log('tbody触发');
}, true);

tr.addEventListener('click', function () {
    console.log('tr触发');
}, true);

td.addEventListener('click', function () {
    console.log('td触发');
}, true);
```
当单击td单元格元素时
```js
table触发
tbody触发
tr触发
td触发
// 从table元素开始向内依次传播，经由tbody、tr，最终到达td元素。
```

> 以上的两种类型全部都是按照捕获性事件流或冒泡型事件流处理的，那么如果我们修改其中的任意两种为不同的模式以达到混合型事件流，结果会怎么样呢？

假如将table与tr设置为事件捕获类型，将tbody与td设置为事件冒泡类型，得到的代码如下。
```js
// 事件捕获
table.addEventListener('click', function () {
    console.log('table触发');
}, true);

// 事件冒泡
tbody.addEventListener('click', function () {
    console.log('tbody触发');
}, false);

// 事件捕获
tr.addEventListener('click', function () {
    console.log('tr触发');
}, true);

// 事件冒泡
td.addEventListener('click', function () {
    console.log('td触发');
}, false);
```
当单击td元素时，结果如下所示。
```js
table触发
tr触发
td触发
tbody触发
```
发现事件触发时，既没有按照元素由内向外的顺序，也没有按照元素由外向内的顺序。这是为什么呢？

**因为完整的事件流是按照事件捕获阶段>事件目标阶段>事件冒泡阶段依次进行的。如果有元素绑定了捕获类型事件，则会优先于冒泡类型事件而先执行。**

整个事件流的实际执行过程分析如下。
- 事件捕获阶段，从table元素开始，table元素绑定捕获类型事件，所以最先执行，输出“table触发”。
- 事件捕获阶段，执行到tbody元素，但是tbody元素绑定的是冒泡类型事件，所以直接跳过，没有输出。
- 事件捕获阶段，执行到tr元素，tr元素绑定了捕获类型事件，所以会执行，输出“tr触发”。
- 事件目标阶段，执行到td元素，触发目标元素事件，不管是冒泡类型事件还是捕获类型事件，都会执行，输出“td触发”。
- 事件冒泡阶段，执行到tr元素，tr元素绑定了捕获类型事件，所以直接跳过，没有输出。
- 事件冒泡阶段，执行到tbody元素，tbody元素绑定了冒泡类型事件，所以会执行，输出“tbody触发”。
- 事件冒泡阶段，执行到table元素，table元素绑定了捕获类型事件，所以直接跳过，没有输出。

对table元素和td元素绑定冒泡类型事件，对tbody元素和tr元素绑定捕获类型事件，在单击td元素的时候，结果会输出什么？
```js
// 事件冒泡
table.addEventListener('click', function () {
    console.log('table触发');
}, false);

// 事件捕获
tbody.addEventListener('click', function () {
    console.log('tbody触发');
}, true);

// 事件捕获
tr.addEventListener('click', function () {
    console.log('tr触发');
}, true);

// 事件冒泡
td.addEventListener('click', function () {
    console.log('td触发');
}, false);

// tbody触发
// tr触发
// td触发
// table触发
```
## 事件处理程序👍👍👍
> 通过addEventListener()函数给元素绑定了事件处理程序，这只是其中的一种实现方式。

简单理解事件处理程序，就是响应某个事件的函数，例如onclick()函数、onload()函数就是响应单击、加载事件的函数，对应的是一段JavaScript的函数代码。

根据W3C DOM标准，事件处理程序分为DOM0、DOM2、DOM3这3种级别的事件处理程序。由于在DOM1中并没有定义事件的相关内容，因此没有所谓的DOM1级事件处理程序。

### DOM0级事件处理程序
一种是将一个函数赋值给一个事件处理属性，有两种表现形式。第一种是先通过JavaScript代码获取DOM元素，再将函数赋值给对应的事件属性。
```js
var btn = document.getElementById("btn"); 
btn.onclick = function(){}
```
还有一种是直接在html中设置对应事件属性的值，值有两种表现形式，一种是执行的函数体，另一种是函数名，然后在script标签中定义该函数。
```html
<button onclick="alert('面试厅');">单击</button>
<button onclick="clickFn()">单击</button>
<script>
    function clickFn() {
        alert('面试厅');
    }
</script>
```
以上两种同时存在时，第一种在JavaScript中定义的事件处理程序会覆盖掉后面在html标签中定义的事件处理程序。

> DOM0级事件处理程序只支持事件冒泡阶段

- 优点：简单且可以跨浏览器。
- 缺点：一个事件处理程序只能绑定一个函数。

```html
<!-- 使用两种方法绑定onclick事件处理程序。 -->
<button class="btn" id="btn" onclick="doClick()">click me</button>
<script>
var btn = document.getElementById("btn");
btn.onclick = function(){
    console.log('123'); // 123
};
function doClick() {
    console.log('456');
}
// 如需删除元素绑定的事件，只需要将对应的事件处理程序设置为null即可。
btn.onclick = null;
</script>
```
### DOM2级事件处理程序
当事件发生在节点时，目标元素的事件处理函数就会被触发，而且目标元素的每个祖先节点也会按照事件流顺序触发对应的事件处理程序。

DOM2级事件处理方式规定了添加事件处理程序和删除事件处理程序的方法

针对DOM2级事件处理程序，不同的浏览器厂商制定了不同的实现方式，主要分为IE浏览器和非IE浏览器。

IE
- 在IE10及以下版本中，只支持事件冒泡阶段。
- 在IE11中同时支持事件捕获阶段与事件冒泡阶段。在IE10及以下版本中，可以通过attachEvent()函数添加事件处理程序，通过detachEvent()函数删除事件处理程序。
```js
element.attachEvent("on"+ eventName, handler); // 添加事件处理程序
element.detachEvent("on"+ eventName, handler); // 删除事件处理程序
```
- 在IE11及其他非IE浏览器中，同时支持事件捕获和事件冒泡两个阶段，可以通过addEventListener()函数添加事件处理程序，通过removeEventListener()函数删除事件处理程序。
```js
addEventListener(eventName, handler, useCapture);     //添加事件处理程序
removeEventListener(eventName, handler, useCapture);  //删除事件处理程序
```
其中的useCapture参数表示是否支持事件捕获，true表示支持事件捕获，false表示支持事件冒泡，默认状态为false。

#### 共同点
1️⃣在DOM2级事件处理程序中，不管是IE浏览器还是非IE浏览器都支持对同一个事件绑定多个处理函数。
```js
var handler1 = function (){}
var handler2 = function (){}
// ---------------IE10及以下------------------
btn.attachEvent('onclick', handler1);
btn.attachEvent('onclick', handler2);
// ---------------IE11及非IE-----------------
btn.addEventListener('click', handler1);
btn.addEventListener('click', handler2);
```
如下面的所示，在div上同时绑定了两个click函数。
```html
<div id="wrap">单击我触发事件</div>
<script>
var wrap = document.getElementById('wrap');
wrap.addEventListener('click', function() {
    console.log('123'); // 123
}, false);
wrap.addEventListener('click', function () {
    console.log('456'); // 456
}, false);
</script>
```
2️⃣在需要删除绑定的事件时，不能删除匿名函数，因为添加和删除的必须是同一个函数。下面这种同时绑定和取消handler()函数的情况，可以删除掉绑定的事件。
```js
var wrap = document.getElementById('wrap');
var handler = function () {
    console.log('789');
};
// 第一种方式绑定和取消的是同一个函数，因此可以取消绑定的事件
wrap.addEventListener('click', handler, false);
wrap.removeEventListener('click', handler);
```
而如果采用下面这种方式，则无法取消绑定的事件，因为它们使用的都是匿名函数的形式，绑定与取消的函数并不是同一个。
```js
wrap.addEventListener('click', function () {
    console.log('123');
}, false);
wrap.removeEventListener('click', function () {});
```
#### 不同点
1️⃣在IE浏览器中，使用attachEvent()函数为同一个事件添加多个事件处理函数时，会按照添加的相反顺序执行。

```js
// 在一个button元素上使用attachEvent()函数先后绑定了两个onclick事件处理程序
var btn = document.getElementById("mybtn");
btn.attachEvent("onclick",function(){
    console.log("clicked");
});
btn.attachEvent("onclick",function(){
    console.log("hello world!"); 
});
// hello world!
// clicked
```
2️⃣在IE浏览器下，使用attachEvent()函数添加的事件处理程序会在全局作用域中运行，因此**this指向全局作用域window**。在非IE浏览器下，使用addEventListener()函数添加的事件处理程序在指定的元素内部执行，因此**this指向绑定的元素**。
```html
<button id="mybtn">单击</button>
<script>
  var btn = document.getElementById("mybtn");
  // IE浏览器
  btn.attachEvent("onclick", function () {
    alert(this); // 指向window
  });
  // 非IE浏览器
  btn.addEventListener("click", function () {
    alert(this); // 指向绑定的元素
  });
</script>
```
因为浏览器的差异性，我们需要使用不同的方法来实现DOM2级事件处理程序。如果我们想要针对不同的浏览器做兼容性处理，该如何实现呢？

```js
// 以下是一段针对不同浏览器所做的封装处理代码。
var EventUtil = {
    addEventHandler: function (element, type, handler) {
        if (element.addEventListener) {
            element.addEventListener(type, handler);
        } else if (element.attachEvent){
            element.attachEvent("on" + type, handler);
        } else {
            element["on" + type] = handler;
        }
    },
    removeEventHandler: function (element, type, handler) {
        if (element.addEventListener) {
            element.removeEventListener(type, handler);
        } else if (element.detachEvent){
            element.detachEvent("on" + type, handler);
        } else {
            element["on" + type] = null;
        }
    }
}
```
#### DOM3级事件处理程序
```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```
