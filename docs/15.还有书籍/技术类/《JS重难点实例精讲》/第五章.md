# DOM与事件
DOM是文档对象模型，全称为Document Object Model。DOM用一个逻辑树来表示一个文档，树的每个分支终点都是一个节点，每个节点都包含着对象。
DOM提供了对文档结构化的表述，通过绑定不同的事件可以改变文档的结构、样式和内容，从而能实现“动态”的页面。
## DOM选择器
### 传统原生JavaScript选择器
为了能更直观地看到DOM选择器的效果，我们编写了一个HTML页面，然后通过DOM选择器定位元素，改变对应的展示内容。

HTML页面中主要是定义一系列的ul-li标签，然后通过DOM选择器定位li后并操作它们，初始代码如下所示。
```html
<ul>
    <li>节点1.1</li>
    <li>节点1.2</li>
    <li>节点1.3</li>
    <li>节点1.4</li>
    <li>节点1.5</li>
    <li>节点1.6</li>
    <li>节点1.7</li>
</ul>
<ul>
    <li>节点2.1</li>
    <li>节点2.2</li>
    <li>节点2.3</li>
    <li>节点2.4</li>
    <li>节点2.5</li>
    <li>节点2.6</li>
    <li>节点2.7</li>
</ul>
```
#### 通过id定位
```html
<!-- id唯一 -->
<ul>
    <li id="one">节点1.1</li>
    <li id="one">节点1.2</li>
    <li>节点1.3</li>
    <li>节点1.4</li>
</ul>
```
当具有相同id的元素时，除了第一个元素能被匹配到外，其他元素都会被忽略。
```js
document.getElementById('one').innerText; // 节点1.1
```
#### 通过class定位
> getElementsByClassName()函数，通过类名定位元素，返回由匹配到的元素构成的HTMLCollection对象，它是一个类数组结构。
```html
<li class="one">节点1.2</li>
<li class="one">节点1.3</li>
```
```js
document.getElementsByClassName('one');
// 返回值为一个HTMLCollection对象，里面包含匹配到的两个li元素值。
HTMLCollection(2) [li.one, li.one]
 - 0: li.one
 - 1: li.one
 - length: 2
 - __proto__:  HTMLCollection
```
#### 通过name属性定位
> getElementsByName()函数，通过元素的name属性进行定位，返回由匹配到的元素构成的NodeList对象，它是一个类数组结构。
```html
<ul>
    <li id="one">节点1.1</li>
    <li name="node">节点1.4</li>
    <li name="node">节点1.5</li>
</ul>
<ul>
    <li name="node">节点2.1</li>
    <li>节点2.2</li>
</ul>
```

```js
document.getElementsByName('node');
// 返回的值为一个NodeList对象，里面包含匹配到的name属性为“node”的元素。
NodeList(3) [li, li, li]
 - 0: li
 - 1: li
 - 2: li
 - length: 3
 -  __proto__:  NodeList
```
#### 通过标签名定位
> getElementsByTagName()函数，通过标签名定位元素，返回由匹配到的元素构成的HTMLCollection对象。
```js
// 通过标签名获取页面上的两个ul元素。
document.getElementsByTagName('ul');
// 返回值为一个HTMLCollection对象，里面包含匹配到的两个ul元素值。
HTMLCollection(2) [ul, ul]
- 0: ul
- 1: ul
- length: 2
- __proto__: HTMLCollection
```
### 新型的querySelector选择器和querySelectorAll选择器
使用传统的id、name、class等选择器来查找元素时，只能调用document具有的函数，在查找特定元素的子元素时不太方便。
#### querySelector选择器
> querySelector选择器返回的是在基准元素下，选择器匹配到的元素集合中的第一个元素。

语法如下所示。
```js
element = baseElement.querySelector(selectors);
```
其中，
- baseElement是基准元素，返回的元素必须是匹配到的基准元素的第一个子元素。该基准元素可以为Document，也可以为基本的Element。
- selectors是一个标准的CSS选择器，而且必须是合法的选择器，否则会引起语法错误。
- 返回值为匹配到的第一个子元素。匹配的过程中不仅仅针对基准元素的后代元素，实际上会遍历整个文档结构，包括基准元素和它的后代元素以外的元素。实际处理过程是首先创建一个匹配元素的初始列表，然后判断每个元素是否为基准元素的后代元素，第一个属于基准元素的后代元素将会被返回。
```html
<div>
  <h5>Original content</h5>
  <span>outside span</span>
  <p class="content">
    inside paragraph
    <span>inside span</span>
    inside paragraph
  </p>
</div>
```

```js
// 获取p元素的第一个span元素。
document.querySelector('p span').innerText; // inside span
// 获取class为content的元素的第一个span元素。
document.querySelector('.content span').innerText; // inside span
// 获取第一个span或者h5元素。
document.querySelector('h5, span').innerText // Original content
```
然后通过以下这段代码来验证上述返回值的匹配过程。
```js
var baseElement = document.querySelector("p");
console.log(baseElement.querySelector("div span").innerText); // inside span
```
第一行代码获取的基准元素为p元素，第二行代码中的选择器为“div span”。虽然在p元素中没有div元素，却依旧能匹配到span元素。这是因为在匹配过程会优先找出div元素下span元素的集合，然后判断span元素是否属于p元素的子元素，最后返回第一个匹配到的span元素值。

#### querySelectorAll选择器
> querySelectorAll选择器与querySelector选择器类似，区别在于querySelectorAll选择器会返回基准元素下匹配到的所有子元素的集合。

语法如下所示。
```js
elementList = baseElement.querySelectorAll(selectors);
// 它同样包含基准元素与选择器，返回值是一个NodeList的集合。
```

```html
<div>
    <h5>Original content</h5>
    <span>outside span</span>
    <p class="content">
        inside paragraph
        <span>inside span</span>
        inside paragraph
    </p>
</div>
```

```js
// 获取所有的span元素。
document.querySelectorAll('span');
// 其返回值如下所示。
NodeList(2) [span, span]
 - 0: span
 - 1: span
 - length: 2
 - __proto__:  NodeList
```
querySelectorAll选择器匹配过程与querySelector选择器一样，优先获取所有匹配元素的集合，然后判断每个元素是否属于基准元素。如果属于则返回结果，最终返回一个NodeList对象。

理解querySelectorAll选择器匹配元素的过程。
```html
<div id="my-id">
    <img id="inside">
    <div class="lonely"></div>
    <div class="outer">
        <div class="inner"></div>
    </div>
</div>
<script>
    var firstArr = document.querySelectorAll('#my-id div div');
        var secondArr = document.querySelector('#my-id').querySelectorAll('div div');
    console.log(firstArr);
    console.log(secondArr);
</script>
```
上面代码的主要目的是找出在id为“my-id”元素的子div中子div元素的集合。分别使用两种写法获取到了firstArr和secondArr两个值。
提问：firstArr和secondArr返回的NodeList值是否是一样的？答案：不一样。实际上它们输出的结果如下所示。
```js
firstArr   NodeList [div.inner]
        - 0: div.inner
        - length: 1
        - __proto__: NodeList
secondArr  NodeList(3) [div.lonely, div.outer, div.inner]
        - 0: div.lonely
        - 1: div.outer
        - 2: div.inner
        - length: 3
        - __proto__: NodeList
```
可以看出firstArr表示的NodeList对象的长度为1，而secondArr表示的NodeList对象的长度为3，为什么呢？

针对firstArr，querySelectorAll选择器的调用方是document，则基准元素为document；执行CSS选择器，匹配到的元素只有一个，如下代码所示。
```html
<div class="inner"></div>
```
该元素属于document中的子元素，最终返回结果如下所示。
```js
NodeList [div.inner]
```

针对secondArr，先通过querySelector选择器确定基准元素是id为“my-id”的元素，然后执行CSS选择器，选择器的内容是匹配div元素中的子div元素。
HTML代码对应的文档结构内，有3个元素是匹配的。
- id为“my-id”的div元素的第一个子节点。`<div class="lonely"></div>`
- id为“my-id”的div元素的第二个子节点。 `<div class="outer">...</div>`
- class为“outer”的div元素的第一个子节点。`<div class="inner"></div>`

紧接着判断这3个匹配的元素是否为基准元素的子元素，发现它们都是处于基准元素内部的，最终这3个值构成一个NodeList集合返回。
```js
NodeList(3) [div.lonely, div.outer, div.inner]
```
##### 特例👍👍👍
> 一个页面是不允许有相同id的元素的。如果出现了相同的id，则无法通过getElementById()函数获取到除第一个元素以外的元素。对于querySelectorAll选择器来说却是一个特例。将id选择器传入querySelectorAll选择器中后，可以通过id获取多个匹配的元素，然后通过索引获取特定的值。
```html
<div>
    <p id="first">文本1</p>
    <p id="first">文本2</p>
    <p id="first">文本3</p>
    <p id="first">文本4</p>
</div>
<script>
    console.log(document.querySelectorAll('#first').length);  // 4
    console.log(document.querySelectorAll('#first')[3].innerText); // 文本4
</script>
```
> 虽然querySelectorAll选择器也可以处理出现相同id的情况，按照HTML编写的规范，**绝对不允许**一个页面出现相同id的元素。
## HTMLCollection对象与NodeList对象
不同的DOM选择器，它们的返回值有些是NodeList对象，有些是HTMLCollection对象。那么它们有什么区别呢？

下面这段代码，主要是对children属性和childNodes属性的调用。
```html
<div id="main">
    <p class="first">first</p>
    <p class="second">second<span>content</span></p>
</div>
<script>
    var main = document.getElementById("main");
    console.log(main.children);
    console.log(main.childNodes);
</script>
```
得到的结果如下所示。
```js
HTMLCollection(2) [p.first, p.second]
 - 0: p.first
 - 1: p.second
 - length: 2
 -  __proto__:  HTMLCollection
NodeList(5) [text, p.first, text, p.second, text]
 - 0: text
 - 1: p.first
 - 2: text
 - 3: p.second
 - 4: text
 - length: 5
 -  __proto__:  NodeList
```
### HTMLCollection对象
HTMLCollection对象具有length属性，返回集合的长度，可以通过item()函数和namedItem()函数来访问特定的元素。
#### item()函数
可以调用item()函数，通过序号来获取特定的某个节点，超过索引则返回“null”。
```html
<div id="main">
    <p class="first">first</p>
    <p class="second">second</p>
    <p class="third">third</p>
    <p class="four">four</p>
</div>
<script>
    var main = document.getElementById("main").children;
    console.log(main.item(0)); // <p class="first">first</p>
    console.log(main.item(2)); // <p class="third">third</p>
</script>
```
#### namedItem()函数
用来返回一个节点。
首先通过id属性去匹配，然后如果没有匹配到则使用name属性匹配，如果还没有匹配到则返回“null”。当出现重复的id或者name属性时，只返回匹配到的第一个值。
```html
<form id="main">
    <input type="text" id="username">
    <input type="text" name="username">
    <input type="text" name="password">
</form>
<script>
    var main = document.getElementById("main").children;
    console.log(main.namedItem('username')); // <input type="text" id="username">
</script>
```
### NodeList对象
> NodeList对象也具有length属性，返回集合的长度，也同样具有item()函数，通过索引定位子元素的位置。同HTMLCollection。

### HTMLCollection对象和NodeList对象的实时性
> 两者并不是历史文档状态的静态快照，而是具有**实时性**的。对DOM树新增或者删除一个相关节点，都会立刻反映在HTMLCollection对象与NodeList对象中。

HTMLCollection对象与NodeList对象都只是类数组结构，并不能直接调用数组的函数。
而通过call()函数和apply()函数处理为真正的数组后，它们就转变为一个真正的**静态值**了，不会再动态反映DOM的变化。
```html
<form id="main">
    <input type="text" id="username">
    <input type="text" name="password">
</form>
<script>
    // 获取HTMLCollection
    var mainChildren = document.getElementById('main').children;
        console.log(mainChildren.length);  // 2

    // 新增一个input元素
    var newInput = document.createElement('input');
    main.appendChild(newInput);
    console.log(mainChildren.length);  // 3

    // 通过call()函数处理成数组结构
    mainChildren = Array.prototype.slice.call(mainChildren, 0);
    mainChildren.splice(1, 1);
    console.log(mainChildren.length);  // 2

    // 再新增一个input元素
    var newInput2 = document.createElement('input');
    main.appendChild(newInput2);
    console.log(mainChildren.length);  // 2

</script>
```
NodeList对象与HTMLCollection对象相比，存在一些细微的差异，主要表现在不是所有的函数获取的NodeList对象都是实时的。例如通过querySelectorAll()函数获取的NodeList对象就不是实时的。
```html
<ul id="main">
    <li>文本1</li>
    <li>文本2</li>
    <li>文本3</li>
    <li>文本4</li>
    <li>文本5</li>
</ul>
<script>
    // 获取ul
    var main = document.getElementById('main');
    // 获取li集合
    var lis = document.querySelectorAll('ul li');
    // 第一次输出li集合长度，值为5
    console.log(lis.length);

    // 新增li元素
    var newLi = document.createElement('li');
    var text = document.createTextNode('文本8');
    newLi.appendChild(text);
    main.appendChild(newLi);
    // 再次输出li集合长度，值为5
    console.log(lis.length);
    // 重新获取li的集合并输出长度，值为6
    console.log(document.querySelectorAll('ul li').length);
</script>
```
综上所述，两者具有以下的相同点和不同点。
#### 相同点
- 都是类数组对象，有length属性，可以通过call()函数或apply()函数处理成真正的数组。
- 都有item()函数，通过索引定位元素。
- 都是实时性的，DOM树的变化会及时反映到HTMLCollection对象和NodeList对象上，只是在某些函数调用的返回结果上会存在差异。
#### 不同点
- HTMLCollection对象比NodeList对象多个namedItem()函数，可以通过id或者name属性定位元素。
- HTMLCollection对象只包含元素的集合（Element），即具有标签名的元素；而NodeList对象是节点的集合，既包括元素，也包括节点，例如text文本节点。

## 常用的DOM操作
> 文档树是由各种类型节点构成的集合，DOM操作实际是对文档结构中节点的操作。
> 文档结构树中的节点类型众多，但是操作的主要节点类型为元素节点、属性节点和文本节点。
```html
<!DOCTYPE html>
<html>
<head>
    <title>文档标题</title>
</head>
<body>
  <a href="http://www.mianshiting.com">我的链接</a>
  <h1>我的标题</h1>
</body>
</html>
```
如果将这些节点画成一个树的话:
[文档](./assets/drowio/document.drawio ':include :type=code')
- 元素节点是拥有一对开闭合标签的元素整体，例如常见的div、ul、li标签都是元素节点。
  - `<div></div>，<ul></ul>，<li></li>`
- 属性节点是元素节点具有的属性，例如a标签的href属性。
- 文本节点是DOM中用于呈现文本内容的节点，例如h1标签内部的“我的标题”。
- 其中元素节点和文本节点存在父子关系，而元素节点与属性节点并不存在父子关系。

### 新增节点
> 两个步骤，首先是新建节点，然后将节点添加至指定的位置。
```html
<ul id="container">
    <li class="first">文本1</li>
    <li class="second">文本2</li>
    <li>文本3</li>
    <li id="target">文本4</li>
    <li>文本5</li>
    <li>文本6</li>
</ul>
```
需要完成这样一个操作：第一步，在ul的末尾添加一个li元素，其类名为“last”，内容为“新增文本1”；第二步，在新增的li之前再新增第二个li，内容为“新增文本2”。
```js
// 1️⃣获取指定元素。
var container = document.querySelector('#container');
// 2️⃣新建创建一个元素节点。
var newLiOne = document.createElement('li');
// 3️⃣新建一个属性节点，并设置值。
var newLiAttr = document.createAttribute('class');
newLiAttr.value = 'last';
// 4️⃣将属性节点绑定在元素节点上。
newLiOne.setAttributeNode(newLiAttr);
// 5️⃣新建一个文本节点。
var newTextOne = document.createTextNode('新增文本1');
// 6️⃣将文本节点作为元素节点的子元素。
newLiOne.appendChild(newTextOne);
// 7️⃣使用appendChild()函数将新增元素节点添加至末尾。
container.appendChild(newLiOne);
// 8️⃣新创建第二个元素节点。
var newTextTwo = document.createTextNode('新增文本2');
// 9️⃣新创建第二个文本节点。
var newTextTwo = document.createTextNode('新增文本2');
// 🔟将文本节点作为元素节点的子元素。
newLiTwo.appendChild(newTextTwo);
// 🔟+1️⃣使用insertBefore()函数将节点添加至第一个新增节点的前面。
container.insertBefore(newLiTwo, newLiOne);
```
至此，完成指定的两个新增操作。

在新增属性节点时，还有另外一种更简单的setAttribute()函数。以上面代码为例，可以通过下面这一行代码完成上述3️⃣4️⃣这两步共3行代码的功能。
```js
newLiOne.setAttribute('class', 'last'); // 不兼容IE8及更早的版本
```
### 删除节点
删除节点的操作实际包含删除元素节点、删除属性节点和删除文本节点。
```html
<ul id="main">
    <li>文本1</li>
    <li>文本2</li>
    <li>文本3</li>
</ul>
<a id="link" href="http://www.mianshiting.com">面试厅</a>
```
1. 删除ul的第一个li元素节点
删除一个元素节点需要进行三步操作。
```js
// 1️⃣获取该元素的父元素。
var main = document.querySelector('#main');
// 2️⃣获取待删除节点。
// 待删除节点是父元素的第一个元素节点，很多人可能直接想到的是使用firstChild属性，这是不可取的。firstChild属性实际是取childNodes属性返回的NodeList对象中的第一个值，在此例中实际为一个换行符。
// 如果需要获取第一个元素节点，应该使用firstElementChild属性。
var firstChild = main.firstElementChild;
// 3️⃣通过父节点，调用removeChild()函数删除该节点。
main.removeChild(firstChild);
```
2. 删除a标签的href属性
删除一个元素的属性需要进行两步操作。
```js
// 1️⃣获取该元素。
var link = document.querySelector('#link');
// 2️⃣通过元素节点，调用removeAttribute()函数删除指定属性节点。
link.removeAttribute('href');
```
3. 删除ul最后一个li元素的文本节点
删除一个元素的文本节点需要进行三步操作。
```js
// 1️⃣获取元素节点。
// 在获取最后一个元素节点时，使用的是lastElementChild属性而不是lastChild属性。
var lastChild = main.lastElementChild;
// 2️⃣获取文本节点。
// 在获取文本节点时，需要使用的是childNodes属性，然后取返回的NodeList对象的第一个值。不能使用children属性，因为children属性返回的是HTMLCollection对象，表示的是元素节点，不包括文本节点内容。
var textNode = lastChild.childNodes[0];
// 3️⃣通过元素节点，调用removeChild()函数删除指定的文本节点。
lastChild.removeChild(textNode);
// 关于删除文本节点还有一种比较简单的处理方法，那就是将元素节点的innerHTML属性设置为空。
lastChild.innerHTML = '';
```
在删除文本节点时，更推荐使用设置innerHTML属性为空的方法。
### 修改节点
包含着很多不同类型的操作，包括修改元素节点、修改属性节点和修改文本节点。
```html
<div id="main">
    <!-- 测试修改元素节点 -->
    <div id="div1">替换之前的元素</div>
    <!-- 测试修改属性节点 -->
    <div id="div2" class="classA" style="color: green;">这是修改属性的节点</div>
    <!-- 测试修改文本节点 -->
    <div id="last">这是最后一个节点内容</div>
</div>
```
1. 修改元素节点

修改元素节点的操作一般是直接将节点元素替换为另一个元素，可以使用replaceChild()函数来实现。replaceChild()函数的调用方是父元素，接收两个参数，第一个参数表示新元素，第二个参数表示将要被替换的旧元素。
```html
<script>
    // 1.获取父元素与待替换的元素
    var main = document.querySelector('#main');
    var div1 = document.querySelector('#div1');
    // 2.创建新元素
    var newDiv = document.createElement('div');
    var newText = document.createTextNode('这是新创建的文本');
    newDiv.appendChild(newText);
    // 3.使用新元素替换旧的元素
    main.replaceChild(newDiv, div1);
</script>
```
2. 修改属性节点
修改属性节点有两种处理方式：
- 一种是通过getAttribute()函数和setAttribute()函数获取和设置属性节点值；另一种是直接修改属性名。
- 第二种方式有个需要注意的地方是，直接修改的属性名与元素节点中的属性名不一定是一致的。就像class这个属性，因为它是JavaScript中的关键字，是不能直接使用的，所以需要使用className来代替。
```js
var div2 = document.querySelector('#div2');
// 方法1: 通过setAttribute()函数设置
div2.setAttribute('class', 'classB');
// 方法2: 直接修改属性名，注意不能直接用class，需要使用className
div2.className = 'classC';

// 方法1: 通过setAttribute()函数设置
div2.setAttribute('style', 'color: red;');
// 方法2: 直接修改属性名
div2.style.color = 'blue';
```
3. 修改文本节点
修改文本节点与删除文本节点一样，将innerHTML属性修改为需要的文本内容即可。
```js
var last = document.querySelector('#last');
// 直接修改innerHTML属性
last.innerHTML = '这是修改后的文本内容';
//如果设置的innerHTML属性值中包含HTML元素，则会被解析
//使用如下代码进行验证
last.innerHTML = '<p style="color: red">这是修改后的文本内容</p>';
//在浏览器中渲染后，可以看到“这是修改后的文本内容”为红色
```
## 事件流
在浏览器中，JavaScript和HTML之间的交互是通过事件去实现的，常用的事件有代表鼠标单击的click事件、代表加载的load事件、代表鼠标指针悬浮的mouseover事件。
在事件发生时，会相对应地触发绑定在元素上的事件处理程序，以处理对应的操作。

通常一个页面会绑定很多的事件，那么具体的事件触发顺序是什么样的呢？

这就会涉及事件流的概念，事件流描述的是从页面中接收事件的顺序。事件发生后会在目标节点和根节点之间按照特定的顺序传播，路径经过的节点都会接收到事件。

通过下面的场景来直观地想象一下事件的流转顺序。

页面上有一个table表格，分别在table表格、tbody表格体、tr行、td单元格上绑定了click事件。假如我在td上执行了单击的操作，那么将会产生什么样的事件流呢？



```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```
