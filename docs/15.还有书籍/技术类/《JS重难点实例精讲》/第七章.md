# ES6
## let和const关键字
其实在ES6之前，只存在全局作用域和函数作用域，并不存在块级作用域，这就会导致变量提升的问题。
变量提升往往会因为得到一些出乎意料的结果而受人诟病，所以在ES6中新增了块级作用域来避免这个问题的出现。

> 块级作用域表示的是定义的变量可执行上下文环境只能在一个代码块中，一个代码块由一个大括号括住的代码构成，超出这个代码块范围将无法访问内部的变量。

Demo
```js
{
  let a = 1;
  console.log(a); // 1
}
console.log(a); // ReferenceError: a is not defined
```
当我们使用let关键字定义一个变量a后，能够在代码块中输出变量a的值，但是在代码块外访问时会抛出a未定义的异常。

### let关键字
let关键字用于声明变量，和var关键字的用法类似。但是与var不同的是，let声明的变量只能在let所在的代码块内有效，即在块级作用域内有效，而var声明的变量在块级作用域外仍然有效。
```js
// 看区别
{
    var a = 1;
    let b = 2;
}
console.log(a);  // 1
console.log(b);  // ReferenceError: b is not defined
```
#### let关键字的特性
##### 不存在变量提升
使用var定义的变量会存在变量提升的情况，变量提升会使得变量在声明之前可以被访问，正是因为这个特性的存在，所以会出现各种奇怪的结果。
```js
// 在ES6中，使用let定义的变量不存在变量提升，所以如果在变量声明之前去使用变量，就会抛出异常。
// var声明变量
console.log(c);  // undefined
var c = 'ming';
// let声明变量
console.log(d);  // ReferenceError: d is not defined
let d = 'ming';
```

##### 存在暂时性死区
在ES6中，暂时性死区会出现在使用let或const的代码中，表示的是当程序流程进入一个新的作用域时，在此作用域内使用let或const声明的变量会先在作用域中被创建出来，但此时还未进行赋值，如果此时对该变量进行求值运算，变量是不能被访问的，访问就会抛出异常。

> 其中，流程进入新作用域创建变量到变量可以被访问的这一段代码区域，被称为暂时性死区。

简单点来讲就是，在使用let声明变量之前，该变量都是不可访问的。
```js
if (true) {
    // 暂时性死区开始
    param = 'ming';
    console.log(param); // ReferenceError: param is not defined
    // ……
    // 暂时性死区结束
    let param;
}
```
因为有暂时性死区的存在，typeof运算符也不再是绝对安全的，在let定义的变量之前使用typeof运算符同样会抛出异常。
```js
typeof param;  // ReferenceError: param is not defined
let param;
```
而针对非let或const声明的变量，使用typeof运算符确实是绝对安全的，处理一个未声明的变量时会返回“undefined”。
```js
typeof param;  // undefined
```

##### 不能重复声明

```js
1 function foo() {
2     let arg1 = 'ming';
3     if (true) {
4         let arg1 = 'ming';
5     }
6     var arg1 = 'ming'; // SyntaxError: Identifier 'arg1' has already been declared
7 }
```
在foo()函数内部，使用let与var同时声明了名为arg1的变量，因为处于同一个作用域，所以会抛出异常。

而第4行同样使用let定义的变量arg1，其只在第3～5行的代码块内有效，与外部声明的变量arg1相互独立，故可以正确定义。

在函数内部，如果处于相同作用域下，则不能重复声明和形参相同的变量名。
```js
1 function foo(arg1) {
2     let arg1 = 'ming'; // SyntaxError: Identifier 'arg1' has already been declared
3     if (true) {
4         let arg1 = 'ming';
5     }
6 }
```
第2行代码使用let声明了一个与形参相同的变量arg1，两者同处于函数级作用域中，所以会抛出异常。
而第4行代码使用let声明的变量arg1，其只在第3～5行的代码块内有效，与外部声明的变量arg1相互独立，故可以正确定义。

##### 不再是全局对象的属性
在ES6以前，在浏览器环境的全局作用域下，使用var声明的变量、函数表达式或者函数声明均是window对象的属性。
在ES6以后，依然遵循上述原则，但是如果是使用let声明的变量或者函数表达式，将不再是window对象的属性。
```js
// var声明的变量和函数表达式
var a = 1;
var fn = function () {
    console.log('global method');
};
console.log(window.a); // 1
window.fn();  // global method

// let声明的变量和函数表达式
let b = 2;
let foo = function () {
    console.log('global method');
};
console.log(window.b); // undefined
window.foo(); // TypeError: window.foo is not a function
```
#### 使用let关键字的好处
##### 不会导致for循环索引值泄露
在for循环中，因为循环的索引值一般只会在循环体内有效，所以当循环结束后索引值应该被回收。但是如果通过var定义索引值的话，该索引值在循环结束后仍然可以访问，此时使用let定义循环的索引值就很合适。
```js
// var
for (var i = 0; i < 10; i++) {
    // ...
}
console.log(i);  // 10
// let
for (let i = 0; i < 10; i++) {
    // ...
}
console.log(i); // ReferenceError: i is not defined
```
经典场景：在for循环体中通过函数输出索引i值。
```js
var arr = [];
for (var i = 0; i < 10; i++) {
    arr[i] = function () {
        console.log(i);
    };
}
arr[1]();  // 10
```
通过var定义的索引i值，在调用函数时，最终会输出“10”，这是为什么呢？
因为通过var声明的索引i是一个全局变量，每一次循环，全局变量i都会发生改变。而数组arr所有成员里面的i都指向同一个i，当循环结束后，全局变量i的值已经变为10。
最终在调用成员函数时，每个函数都闭包了全局变量i，因此会输出“10”。

通过let定义的索引值就不会出现这个问题。
```js
var arr = [];
for (let i = 0; i < 10; i++) {
    arr[i] = function () {
        console.log(i);
    };
}
arr[1]();  // 1
```
这是因为通过let定义的索引值i，只在当前循环内有效，实际上每一轮循环中的i都是一个新的变量，而且最关键的是JavaScript引擎能够记住上一轮循环的值，所以在本轮循环开始时，会基于上一轮循环计算，从而索引i的值会递增。

因此在调用arr数组的成员函数时，会输出正确的索引i值。
为什么通过let声明的变量i在循环体外，仍然可以访问呢？这是因为arr数组的每个成员都是一个函数，对变量i的引用**构成了一个闭包**，所以在循环体外调用函数时仍然可以访问到i。

另外for循环还有一个特别之处，声明变量的那部分（小括号内部）是一个父作用域，循环体内部是一个单独的子作用域。
```js
for (let i = 0; i < 2; i++) {
    let i = 'ming';
    console.log(i); // 输出两次'ming'
}
```
根据let的特点，如果在同一个代码块中同时使用let定义了具有相同名称的变量，则会直接抛出异常。
而在上面的例子中，小括号内和循环体内同时使用let声明了变量i，但是在循环体内仍然可以输出变量i的值，就表明这两个变量i是处在两个独立的父子作用域中的。

##### 避免出现变量提升导致的变量覆盖问题
```js
var arg1 = 'ming';
function foo() {
    console.log(arg1);  // undefined
    if (false) {
        var arg1 = 'ming2';
    }
}
foo(); // undefined
```
在上面的实例中，定义了一个全局变量arg1，在foo()函数中想要输出变量arg1，但是由于变量提升的存在，if代码块内的变量arg1会被提升至foo()函数顶部，导致输出arg1时覆盖了外层的全局变量arg1，因此输出“undefined”。

如果使用let定义if代码块内的arg1，则该arg1只在if代码块内有效，不会影响到全局的arg1变量，从而能输出“ming”。
##### 代替立即执行函数IIFE
立即执行函数（Immediately-Invoked Function Expression，简称IIFE）的内部是一个独立的函数级作用域，使用IIFE的目的主要是避免污染当前作用域内的变量，而使用块级作用域则可以直接避免这个问题。
```js
// I IFE 写法
(function () {
   var arg = ...;
    ...
}());
// 块级作用域写法
{
    let arg = ...;
    ...
}
```
### const关键字
```js
// 声明的值为一个常量，一旦声明将不会再改变。
const MAX = 123;
MAX = 456; // TypeError: Assignment to constant variable.
// 如果只声明，不初始化，则会抛出异常。
const MAX = 123; // 声明正常
const MIN; // SyntaxError: Missing initializer in const declaration
```
const与let声明的变量存在以下相同的特性。
#### 在块级作用域内有效
```js
if (true) {
    const MAX = 123;
}
console.log(MAX);  // ReferenceError: MAX is not defined
```
#### 不存在变量提升，会产生暂时性死区
使用const声明的常量也不会进行变量提升，只能在const声明之后使用常量，在使用处到常量的声明之前会产生暂时性死区。
```js
if (true) {
    console.log(MAX);  // ReferenceError: MAX is not defined
    const MAX = 123;
}
```
#### 不能重复声明变量
在同一个作用域内，不能重复使用const声明常量。
```js
var MIN = 1;
if (true) {
    const MIN = 1; // 正常声明
}
const MIN = 2;  // SyntaxError: Identifier 'MIN' has already been declared
```
> 使用const声明的变量不能被修改，严格意义来说是保存变量值的内存地址不能被修改。

对于基本类型的变量来说，变量就保存着内存地址的值，因此不能直接修改；而对于引用类型的变量来说，变量保存的是一个指向数据内存地址的指针，只要该指针固定不变，就可以改变数据本身的值。
```js
const person = {
    age: 12
};
person.name = 'ming';
person.age = 13;
console.log(person); // { age: 13, name: 'ming' }
person = { age: 12 }; // TypeError: Assignment to constant variable.
```
在上面的实例中，使用const定义了一个person变量，其值为对象类型，然后新增了一个name属性，并修改age属性，仍然能正常输出。
但是当我们重新给person变量赋值时，会抛出异常。
对于数组类型的变量，变量存储的是数组在内存中的地址，仍然可以修改每个元素的值。
```js
// 简单类型成员的数组
const arr = ['1', '2'];
arr[0] = '3';  // 正常操作
// 引用类型成员的数组
const arr2 = [{
    name: 'ming'
}];
arr2[0] = null;  // 正常操作
```
重新给arr或者arr2赋值新的数组时，会抛出异常。
```js
arr = ['3']; // TypeError: Assignment to constant variable.
```
#### 不再是全局对象的属性
与let一致，**在浏览器环境下**，使用const声明的变量不再是全局对象的属性。
```js
const c = 1;
console.log(window.c); // undefined
```

## 解构赋值
传统的ES5及以前的版本中
```js
var arr = ['one', 'two', 'three'];
var one = arr[0];
var two = arr[1];

var obj = {name: 'ming', age: 21};
var name = obj.name;
var age = obj.age;
```
### 数组的解构赋值
针对数组，在解构赋值时，使用的是模式匹配，只要等号两边数组的模式相同，右边数组的值就会相应赋给左边数组的变量。
```js
let [arg1, arg2] = [12, 34];
console.log(num1); // 12
console.log(num2); // 34
```
使用逗号作为占位符，而不指定变量名。
```js
let [, , num3] = [12, 34, 56];
console.log(num3); // 56
```
当右边的数组的值不足以将左边数组的值全部赋值时，会解构失败，对应的值就等于“undefined”。
```js
let [num1, num2, num3] = [12, 34];
console.log(num2); // 34
console.log(num3); // undefined
```
#### 数组解构默认值
在数组解构时设置默认值，可以防止出现解构得到undefined值的情况。具体的做法是在左侧的数组中，直接给变量赋初始值。
```js
let [num1 = 1, num2] = [, 34];
console.log(num1); // 1
console.log(num2); // 34
```
要注意的是，ES6在判断解构是否会得到undefined值时，使用的是严格等于（===）。只有在**严格等于undefined的情况下**，才会判断该值解构为undefined，**相应变量的默认值才会生效**。
```js
let [
    num1 = 1,
    num2 = 2,
    num3 = 3
] = [null, ''];
console.log(num1);  // null
console.log(num2);  // ''
console.log(num3);  // 3
```
#### 交换变量
在使用解构赋值以前，当我们需要交换两个变量时，需要使用一个临时变量，以下是一个经典的写法。
```js
var a = 1;
var b = 2;
var tmp; // 临时变量

tmp = a;
a = b;
b = tmp;
console.log(a);  // 2
console.log(b);  // 1
```
如果使用数组的解构赋值，只需要在等式两边的数组中交换两个变量的顺序即可。
```js
var a = 1;
var b = 2;
// 使用数组的解构赋值交换变量
[b, a] = [a, b];
console.log(a);  // 2
console.log(b);  // 1
```
#### 解析函数返回的数组
```js
function fn() {
    return [12, 34];
}
let [num1, num2] = fn();
console.log(num1); // 12
console.log(num2); // 34
```
####  嵌套数组的解构
```js
let [num1, num2, [num3]] = [12, [34, 56], [78, 89]];
console.log(num1); // 12
console.log(num2); // [34, 56]
console.log(num3); // 78
```
#### 函数参数解构
当函数的参数为数组类型时，可以将实参和形参进行解构。
```js
function foo([arg1, arg2]) {
    console.log(arg1); // 2
    console.log(arg2); // 3
}
foo([2, 3]);
```
### 对象的解构赋值
在ES6中，对象同样可以进行解构赋值。数组的解构赋值是基于数组元素的索引，只要左右两侧的数组元素索引相同，便可以进行解构赋值。但是在对象中，属性是没有顺序的，这就要求右侧解构对象的属性名和左侧定义对象的变量名必须相同，这样才可以进行解构。
同样，未匹配到的变量名在解构时会赋值“undefined”。
```js
let {m, n, o} = {m: 'ming', n: 12};
console.log(m); // ming
console.log(n); // 12
console.log(o); // undefined
```
当解构对象的属性名和定义的变量名不同时，必须严格按照key:value的形式补充左侧对象。
```js
let {m: name, n: age} = {m: 'ming', n: 12};
console.log(name); // ming
console.log(age); // 12
```
而当key和value值相同时，对于value的省略实际上是一种简写方案。
```js
let {m: m, n: n} = {m: 'ming', n: 12};
// 简写方案
let {m, n} = {m: 'ming', n: 12};
```
事实上，对象解构赋值的原理是：先找到左右两侧相同的属性名（key），然后再赋给对应的变量（value），真正被赋值的是value部分，并不是key的部分。
在如下所示的代码中，m作为key，只是用于匹配两侧的属性名是否相同，而真正被赋值的是右侧的name变量，最终name变量会被赋值为“ming”，而m不会被赋值。
```js
let {m: name} = {m: 'ming'};
console.log(name);// ming
console.log(m); // ReferenceError: m is not defined
```
#### 对象解构的默认值
默认值生效的条件是对应的属性值严格等于undefined。
```js
let {m, n = 1, o = true} = {m: 'ming', o: null};
console.log(m); // ming
console.log(n); // 1
console.log(o); // null，因为null与undefined不严格相等，默认值并未生效
```
当属性名和变量名不相同时，默认值是赋给变量的。
```js
let {m, n: age = 1} = {m: 'ming'};
console.log(m);   // ming
console.log(age); // 1
console.log(n);   // ReferenceError: n is not defined
```
#### 嵌套对象的解构
解构时从最外层对象向内部逐层进行，每一层对象值都遵循相同的解构规则。
```js
let obj = {
    p: [
        'Hello',
        {y: 'World'}
    ]
};
let {p: [x, {y: name}]} = obj;
console.log(x); // Hello
console.log(name); // World
console.log(y); // ReferenceError: y is not defined
```
在上面的实例中，变量obj是一个嵌套对象，会存在多次解构的过程。
第一次解构从最外层的属性p开始，属性p对应的值为一个数组[‘Hello’, {y: ‘World’}]，对应左侧的[x, {y: name}]。
第二次解构得到的x值为“Hello”，{y: ‘World’}对应左侧的{y: name} 。
第三次解构得到name值为“World”，解构结束。而y仅仅作为匹配属性名的key，不会参与赋值，因此输出y值时，会抛出异常。
注意：当父层对象对应的属性不存在，而解构子层对象时，会出错并抛出异常。
```js
let obj = {
    m: {
        n: 'ming'
    }
};

let {o: {n}} = obj;
console.log(n); //TypeError: Cannot match against 'undefined' or 'null'.
```
因为在obj对象中，外层的属性名是m，而在左侧的对象中，外层属性名是o，两者并不匹配，所以o会解构得到“undefined”。而对undefined再次解构想要获取n属性时，相当于调用undefined.n，会抛出异常。
#### 选择性解构对象的属性
假如一个对象有很多通用的函数，在某次处理中，只想使用其中的几个函数，那么可以使用解构赋值。
```js
let { min, max } = Math;
console.log(min(1, 3));  // 1
console.log(max(1, 3));  // 3
```
#### 函数参数解构
当函数的参数是一个复杂的对象类型时，可以通过解构去获得想要获取的值并赋给变量。
```js
function whois({displayName: displayName, fullName: { firstName: name }}){
    console.log(displayName + "is" + name);
}
const user = {
    id: 42,
    displayName: "jdoe",
    fullName: {
        firstName: "John",
        lastName: "Doe"
    }
};
whois(user); // jdoe is John
```
## 扩展运算符与rest运算符
这两种运算符可以很好地解决函数参数和数组元素长度未知情况下的编码问题，使得代码能更加健壮和简洁。
### 扩展运算符
用3个点表示（...），用于将一个数组或类数组对象转换为用逗号分隔的值序列。
```js
// 它的基本用法是拆解数组和字符串。
const array = [1, 2, 3, 4];
console.log(...array); // 1 2 3 4
const str = "string";
console.log(...str); // s t r i n g
```
数组类型变量array和字符串类型变量str在经过扩展运算符的处理后，得到的都是单独的值序列。
#### 扩展运算符代替apply()函数
将数组转换为函数参数。
```js
// 获取数组最大值时
let arr = [1, 4, 6, 8, 2];
console.log(Math.max.apply(null, arr)); // 8
// 使用扩展运算符
console.log(Math.max(...arr)); // 8
```
例如，自定义一个add()函数，用于接收两个参数，并返回两个参数相加的和。当传递的参数是一个数组时，如果使用apply()函数，写法如下。
```js
function add (num1, num2) {
  return num1 + num2;
}
const arr = [1, 3];
add.apply(null, arr); // 4
// 使用扩展运算符
add(...arr); // 4
```
#### 扩展运算符代替concat()函数合并数组

```js
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
console.log(arr1.concat(arr2)); // [ 1, 2, 3, 4, 5, 6 ]
// 使用扩展运算符
console.log([...arr1, ...arr2]); // [ 1, 2, 3, 4, 5, 6 ]
```
#### 扩展运算符转换Set，得到去重的数组
Set具有自动的去重性质
```js
let arr = [1, 2, 4, 6, 2, 7, 4];
console.log([...new Set(arr)]); // [ 1, 2, 4, 6, 7 ]
```
#### 扩展运算符用于对象克隆
使用扩展运算符克隆的对象的属性值为基本数据类型的场景。
```js
let obj = {name: 'ming'};
var obj2 = {...obj};
obj2.name = 'ming2';
console.log(obj); // {name: "ming"}
```
克隆后对象的值进行修改并未影响到被克隆的对象，那么是不是就意味着使用扩展运算符实现的是深克隆呢？

场景：克隆对象的属性值为引用数据类型。
```js
let obj3 = {
    name: 'ming', 
    address: {province: 'guangdong', city: 'guangzhou'}
};
let obj4 = {...obj3};
obj4.name = 'ming3';
obj4.address.city = 'shenzhen';
console.log(obj3);
// {name: "ming", address: {province: "guangdong", city: "shenzhen"}}
```
表明对克隆后对象的值进行更改后，影响到了被克隆的对象，这就意味着使用扩展运算符的克隆并不是严格的深克隆。
```js
// 同样适用于数组
let arr1 = [1, 3, 4, 6];  // 可以进行深克隆
let arr2 = [1, 3, [4, 6]]; // 不可以进行深克隆
```
结论：使用扩展运算符对数组或对象进行克隆时，如果数组的元素或者对象的属性是基本数据类型，则支持深克隆；如果是引用数据类型，则不支持深克隆。
> 因为引用数据类型的克隆只是复制了引用的地址，克隆后的对象仍然共享同一个引用地址。
### rest运算符
> 同样使用3个点表示（...），其作用与扩展运算符相反，用于将以逗号分隔的值序列转换成数组。
#### 与解构组合使用
解构会将相同数据结构对应的值赋给对应的变量，将其中的一部分值统一赋给一个变量时，可以使用rest运算符。
```js
let arr = ['one', 'two', 'three', 'four'];
let [arg1, ...arg2] = arr;
console.log(arg1);  // one
console.log(arg2);  // [ 'two', 'three', 'four' ]
```
使用rest运算符进行解构，则rest运算符对应的变量应该放在最后一位，否则就会抛出异常。因为如果rest运算符不是放在最后一位，变量并不知道要读取多少个数值。
```js
let arr = ['one', 'two', 'three', 'four'];
let [...arg1, arg2] = arr; // SyntaxError: Rest element must be last element 
in array
```
和对象解构相关的内容。
```js
let {x, y, ...z} = {x: 1, y: 2, a: 3, b: 4};
console.log(x); // 1
console.log(y); // 2
console.log(z); // {a: 3, b: 4}
```
#### 代替arguments处理函数参数
```js
// 不确定传入的参数长度，可以统一使用arguments来获取所有传递的参数
function foo() {
    for (let arg of arguments) {
        console.log(arg);
    }
}
foo('one', 'two', 'three', 'four');// 输出'one', 'two', 'three', 'four'
```
函数的参数是一个使用逗号分隔的值序列，可以使用rest运算符处理成一个数组，从而确定最终传入的参数，以代替arguments的使用。
```js
function foo(...args) {
    for (let arg of args) {
        console.log(arg);
    }
}
foo('one', 'two', 'three', 'four');// 输出'one', 'two', 'three', 'four'
```
通过以上对扩展运算符和rest运算符的讲解，其实两者是互为逆运算的，**扩展运算符是将数组分割成独立的序列，而rest运算符是将独立的序列合并成一个数组。**

那么如何判断呢？
- 当3个点（…）出现在函数的**形参**上或者出现在赋值等号的**左侧**，则表示它为rest运算符。
- 当3个点（…）出现在函数的**实参**上或者出现在赋值等号的**右侧**，则表示它为扩展运算符。
## 模板字符串
```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```
