# ES6
## let和const关键字
其实在ES6之前，只存在全局作用域和函数作用域，并不存在块级作用域，这就会导致变量提升的问题。
变量提升往往会因为得到一些出乎意料的结果而受人诟病，所以在ES6中新增了块级作用域来避免这个问题的出现。

> 块级作用域表示的是定义的变量可执行上下文环境只能在一个代码块中，一个代码块由一个大括号括住的代码构成，超出这个代码块范围将无法访问内部的变量。

Demo
```js
{
  let a = 1;
  console.log(a); // 1
}
console.log(a); // ReferenceError: a is not defined
```
当我们使用let关键字定义一个变量a后，能够在代码块中输出变量a的值，但是在代码块外访问时会抛出a未定义的异常。

### let关键字
let关键字用于声明变量，和var关键字的用法类似。但是与var不同的是，let声明的变量只能在let所在的代码块内有效，即在块级作用域内有效，而var声明的变量在块级作用域外仍然有效。
```js
// 看区别
{
    var a = 1;
    let b = 2;
}
console.log(a);  // 1
console.log(b);  // ReferenceError: b is not defined
```
#### let关键字的特性
##### 不存在变量提升
使用var定义的变量会存在变量提升的情况，变量提升会使得变量在声明之前可以被访问，正是因为这个特性的存在，所以会出现各种奇怪的结果。
```js
// 在ES6中，使用let定义的变量不存在变量提升，所以如果在变量声明之前去使用变量，就会抛出异常。
// var声明变量
console.log(c);  // undefined
var c = 'ming';
// let声明变量
console.log(d);  // ReferenceError: d is not defined
let d = 'ming';
```

##### 存在暂时性死区
在ES6中，暂时性死区会出现在使用let或const的代码中，表示的是当程序流程进入一个新的作用域时，在此作用域内使用let或const声明的变量会先在作用域中被创建出来，但此时还未进行赋值，如果此时对该变量进行求值运算，变量是不能被访问的，访问就会抛出异常。

> 其中，流程进入新作用域创建变量到变量可以被访问的这一段代码区域，被称为暂时性死区。

简单点来讲就是，在使用let声明变量之前，该变量都是不可访问的。
```js
if (true) {
    // 暂时性死区开始
    param = 'ming';
    console.log(param); // ReferenceError: param is not defined
    // ……
    // 暂时性死区结束
    let param;
}
```
因为有暂时性死区的存在，typeof运算符也不再是绝对安全的，在let定义的变量之前使用typeof运算符同样会抛出异常。
```js
typeof param;  // ReferenceError: param is not defined
let param;
```
而针对非let或const声明的变量，使用typeof运算符确实是绝对安全的，处理一个未声明的变量时会返回“undefined”。
```js
typeof param;  // undefined
```

##### 不能重复声明

```js
1 function foo() {
2     let arg1 = 'ming';
3     if (true) {
4         let arg1 = 'ming';
5     }
6     var arg1 = 'ming'; // SyntaxError: Identifier 'arg1' has already been declared
7 }
```
在foo()函数内部，使用let与var同时声明了名为arg1的变量，因为处于同一个作用域，所以会抛出异常。

而第4行同样使用let定义的变量arg1，其只在第3～5行的代码块内有效，与外部声明的变量arg1相互独立，故可以正确定义。

在函数内部，如果处于相同作用域下，则不能重复声明和形参相同的变量名。
```js
1 function foo(arg1) {
2     let arg1 = 'ming'; // SyntaxError: Identifier 'arg1' has already been declared
3     if (true) {
4         let arg1 = 'ming';
5     }
6 }
```
第2行代码使用let声明了一个与形参相同的变量arg1，两者同处于函数级作用域中，所以会抛出异常。
而第4行代码使用let声明的变量arg1，其只在第3～5行的代码块内有效，与外部声明的变量arg1相互独立，故可以正确定义。

##### 不再是全局对象的属性
在ES6以前，在浏览器环境的全局作用域下，使用var声明的变量、函数表达式或者函数声明均是window对象的属性。
在ES6以后，依然遵循上述原则，但是如果是使用let声明的变量或者函数表达式，将不再是window对象的属性。
```js
// var声明的变量和函数表达式
var a = 1;
var fn = function () {
    console.log('global method');
};
console.log(window.a); // 1
window.fn();  // global method

// let声明的变量和函数表达式
let b = 2;
let foo = function () {
    console.log('global method');
};
console.log(window.b); // undefined
window.foo(); // TypeError: window.foo is not a function
```
#### 使用let关键字的好处
##### 不会导致for循环索引值泄露
在for循环中，因为循环的索引值一般只会在循环体内有效，所以当循环结束后索引值应该被回收。但是如果通过var定义索引值的话，该索引值在循环结束后仍然可以访问，此时使用let定义循环的索引值就很合适。
```js
// var
for (var i = 0; i < 10; i++) {
    // ...
}
console.log(i);  // 10
// let
for (let i = 0; i < 10; i++) {
    // ...
}
console.log(i); // ReferenceError: i is not defined
```
经典场景：在for循环体中通过函数输出索引i值。
```js
var arr = [];
for (var i = 0; i < 10; i++) {
    arr[i] = function () {
        console.log(i);
    };
}
arr[1]();  // 10
```
通过var定义的索引i值，在调用函数时，最终会输出“10”，这是为什么呢？
因为通过var声明的索引i是一个全局变量，每一次循环，全局变量i都会发生改变。而数组arr所有成员里面的i都指向同一个i，当循环结束后，全局变量i的值已经变为10。
最终在调用成员函数时，每个函数都闭包了全局变量i，因此会输出“10”。

通过let定义的索引值就不会出现这个问题。
```js
var arr = [];
for (let i = 0; i < 10; i++) {
    arr[i] = function () {
        console.log(i);
    };
}
arr[1]();  // 1
```
这是因为通过let定义的索引值i，只在当前循环内有效，实际上每一轮循环中的i都是一个新的变量，而且最关键的是JavaScript引擎能够记住上一轮循环的值，所以在本轮循环开始时，会基于上一轮循环计算，从而索引i的值会递增。

因此在调用arr数组的成员函数时，会输出正确的索引i值。
为什么通过let声明的变量i在循环体外，仍然可以访问呢？这是因为arr数组的每个成员都是一个函数，对变量i的引用**构成了一个闭包**，所以在循环体外调用函数时仍然可以访问到i。

另外for循环还有一个特别之处，声明变量的那部分（小括号内部）是一个父作用域，循环体内部是一个单独的子作用域。
```js
for (let i = 0; i < 2; i++) {
    let i = 'ming';
    console.log(i); // 输出两次'ming'
}
```
根据let的特点，如果在同一个代码块中同时使用let定义了具有相同名称的变量，则会直接抛出异常。
而在上面的例子中，小括号内和循环体内同时使用let声明了变量i，但是在循环体内仍然可以输出变量i的值，就表明这两个变量i是处在两个独立的父子作用域中的。

##### 避免出现变量提升导致的变量覆盖问题
```js
var arg1 = 'ming';
function foo() {
    console.log(arg1);  // undefined
    if (false) {
        var arg1 = 'ming2';
    }
}
foo(); // undefined
```
在上面的实例中，定义了一个全局变量arg1，在foo()函数中想要输出变量arg1，但是由于变量提升的存在，if代码块内的变量arg1会被提升至foo()函数顶部，导致输出arg1时覆盖了外层的全局变量arg1，因此输出“undefined”。

如果使用let定义if代码块内的arg1，则该arg1只在if代码块内有效，不会影响到全局的arg1变量，从而能输出“ming”。
##### 代替立即执行函数IIFE
立即执行函数（Immediately-Invoked Function Expression，简称IIFE）的内部是一个独立的函数级作用域，使用IIFE的目的主要是避免污染当前作用域内的变量，而使用块级作用域则可以直接避免这个问题。
```js
// I IFE 写法
(function () {
   var arg = ...;
    ...
}());
// 块级作用域写法
{
    let arg = ...;
    ...
}
```
### const关键字
```js
// 声明的值为一个常量，一旦声明将不会再改变。
const MAX = 123;
MAX = 456; // TypeError: Assignment to constant variable.
// 如果只声明，不初始化，则会抛出异常。
const MAX = 123; // 声明正常
const MIN; // SyntaxError: Missing initializer in const declaration
```
const与let声明的变量存在以下相同的特性。
#### 在块级作用域内有效
```js
if (true) {
    const MAX = 123;
}
console.log(MAX);  // ReferenceError: MAX is not defined
```
#### 不存在变量提升，会产生暂时性死区
使用const声明的常量也不会进行变量提升，只能在const声明之后使用常量，在使用处到常量的声明之前会产生暂时性死区。
```js
if (true) {
    console.log(MAX);  // ReferenceError: MAX is not defined
    const MAX = 123;
}
```
#### 不能重复声明变量
在同一个作用域内，不能重复使用const声明常量。
```js
var MIN = 1;
if (true) {
    const MIN = 1; // 正常声明
}
const MIN = 2;  // SyntaxError: Identifier 'MIN' has already been declared
```
> 使用const声明的变量不能被修改，严格意义来说是保存变量值的内存地址不能被修改。

对于基本类型的变量来说，变量就保存着内存地址的值，因此不能直接修改；而对于引用类型的变量来说，变量保存的是一个指向数据内存地址的指针，只要该指针固定不变，就可以改变数据本身的值。
```js
const person = {
    age: 12
};
person.name = 'ming';
person.age = 13;
console.log(person); // { age: 13, name: 'ming' }
person = { age: 12 }; // TypeError: Assignment to constant variable.
```
在上面的实例中，使用const定义了一个person变量，其值为对象类型，然后新增了一个name属性，并修改age属性，仍然能正常输出。
但是当我们重新给person变量赋值时，会抛出异常。
对于数组类型的变量，变量存储的是数组在内存中的地址，仍然可以修改每个元素的值。
```js
// 简单类型成员的数组
const arr = ['1', '2'];
arr[0] = '3';  // 正常操作
// 引用类型成员的数组
const arr2 = [{
    name: 'ming'
}];
arr2[0] = null;  // 正常操作
```
重新给arr或者arr2赋值新的数组时，会抛出异常。
```js
arr = ['3']; // TypeError: Assignment to constant variable.
```
#### 不再是全局对象的属性
与let一致，**在浏览器环境下**，使用const声明的变量不再是全局对象的属性。
```js
const c = 1;
console.log(window.c); // undefined
```

## 解构赋值
传统的ES5及以前的版本中
```js
var arr = ['one', 'two', 'three'];
var one = arr[0];
var two = arr[1];

var obj = {name: 'ming', age: 21};
var name = obj.name;
var age = obj.age;
```
### 数组的解构赋值
针对数组，在解构赋值时，使用的是模式匹配，只要等号两边数组的模式相同，右边数组的值就会相应赋给左边数组的变量。
```js
let [arg1, arg2] = [12, 34];
console.log(num1); // 12
console.log(num2); // 34
```
使用逗号作为占位符，而不指定变量名。
```js
let [, , num3] = [12, 34, 56];
console.log(num3); // 56
```
当右边的数组的值不足以将左边数组的值全部赋值时，会解构失败，对应的值就等于“undefined”。
```js
let [num1, num2, num3] = [12, 34];
console.log(num2); // 34
console.log(num3); // undefined
```
#### 数组解构默认值
在数组解构时设置默认值，可以防止出现解构得到undefined值的情况。具体的做法是在左侧的数组中，直接给变量赋初始值。
```js
let [num1 = 1, num2] = [, 34];
console.log(num1); // 1
console.log(num2); // 34
```
要注意的是，ES6在判断解构是否会得到undefined值时，使用的是严格等于（===）。只有在**严格等于undefined的情况下**，才会判断该值解构为undefined，**相应变量的默认值才会生效**。
```js
let [
    num1 = 1,
    num2 = 2,
    num3 = 3
] = [null, ''];
console.log(num1);  // null
console.log(num2);  // ''
console.log(num3);  // 3
```
#### 交换变量
在使用解构赋值以前，当我们需要交换两个变量时，需要使用一个临时变量，以下是一个经典的写法。
```js
var a = 1;
var b = 2;
var tmp; // 临时变量

tmp = a;
a = b;
b = tmp;
console.log(a);  // 2
console.log(b);  // 1
```
如果使用数组的解构赋值，只需要在等式两边的数组中交换两个变量的顺序即可。
```js
var a = 1;
var b = 2;
// 使用数组的解构赋值交换变量
[b, a] = [a, b];
console.log(a);  // 2
console.log(b);  // 1
```
#### 解析函数返回的数组
```js
function fn() {
    return [12, 34];
}
let [num1, num2] = fn();
console.log(num1); // 12
console.log(num2); // 34
```
####  嵌套数组的解构
```js
let [num1, num2, [num3]] = [12, [34, 56], [78, 89]];
console.log(num1); // 12
console.log(num2); // [34, 56]
console.log(num3); // 78
```
#### 函数参数解构
当函数的参数为数组类型时，可以将实参和形参进行解构。
```js
function foo([arg1, arg2]) {
    console.log(arg1); // 2
    console.log(arg2); // 3
}
foo([2, 3]);
```
### 对象的解构赋值
在ES6中，对象同样可以进行解构赋值。数组的解构赋值是基于数组元素的索引，只要左右两侧的数组元素索引相同，便可以进行解构赋值。但是在对象中，属性是没有顺序的，这就要求右侧解构对象的属性名和左侧定义对象的变量名必须相同，这样才可以进行解构。
同样，未匹配到的变量名在解构时会赋值“undefined”。
```js
let {m, n, o} = {m: 'ming', n: 12};
console.log(m); // ming
console.log(n); // 12
console.log(o); // undefined
```
当解构对象的属性名和定义的变量名不同时，必须严格按照key:value的形式补充左侧对象。
```js
let {m: name, n: age} = {m: 'ming', n: 12};
console.log(name); // ming
console.log(age); // 12
```
而当key和value值相同时，对于value的省略实际上是一种简写方案。
```js
let {m: m, n: n} = {m: 'ming', n: 12};
// 简写方案
let {m, n} = {m: 'ming', n: 12};
```
事实上，对象解构赋值的原理是：先找到左右两侧相同的属性名（key），然后再赋给对应的变量（value），真正被赋值的是value部分，并不是key的部分。
在如下所示的代码中，m作为key，只是用于匹配两侧的属性名是否相同，而真正被赋值的是右侧的name变量，最终name变量会被赋值为“ming”，而m不会被赋值。
```js
let {m: name} = {m: 'ming'};
console.log(name);// ming
console.log(m); // ReferenceError: m is not defined
```
#### 对象解构的默认值
默认值生效的条件是对应的属性值严格等于undefined。
```js
let {m, n = 1, o = true} = {m: 'ming', o: null};
console.log(m); // ming
console.log(n); // 1
console.log(o); // null，因为null与undefined不严格相等，默认值并未生效
```
当属性名和变量名不相同时，默认值是赋给变量的。
```js
let {m, n: age = 1} = {m: 'ming'};
console.log(m);   // ming
console.log(age); // 1
console.log(n);   // ReferenceError: n is not defined
```
#### 嵌套对象的解构
解构时从最外层对象向内部逐层进行，每一层对象值都遵循相同的解构规则。
```js
let obj = {
    p: [
        'Hello',
        {y: 'World'}
    ]
};
let {p: [x, {y: name}]} = obj;
console.log(x); // Hello
console.log(name); // World
console.log(y); // ReferenceError: y is not defined
```
在上面的实例中，变量obj是一个嵌套对象，会存在多次解构的过程。
第一次解构从最外层的属性p开始，属性p对应的值为一个数组[‘Hello’, {y: ‘World’}]，对应左侧的[x, {y: name}]。
第二次解构得到的x值为“Hello”，{y: ‘World’}对应左侧的{y: name} 。
第三次解构得到name值为“World”，解构结束。而y仅仅作为匹配属性名的key，不会参与赋值，因此输出y值时，会抛出异常。
注意：当父层对象对应的属性不存在，而解构子层对象时，会出错并抛出异常。
```js
let obj = {
    m: {
        n: 'ming'
    }
};

let {o: {n}} = obj;
console.log(n); //TypeError: Cannot match against 'undefined' or 'null'.
```
因为在obj对象中，外层的属性名是m，而在左侧的对象中，外层属性名是o，两者并不匹配，所以o会解构得到“undefined”。而对undefined再次解构想要获取n属性时，相当于调用undefined.n，会抛出异常。
#### 选择性解构对象的属性
假如一个对象有很多通用的函数，在某次处理中，只想使用其中的几个函数，那么可以使用解构赋值。
```js
let { min, max } = Math;
console.log(min(1, 3));  // 1
console.log(max(1, 3));  // 3
```
#### 函数参数解构
当函数的参数是一个复杂的对象类型时，可以通过解构去获得想要获取的值并赋给变量。
```js
function whois({displayName: displayName, fullName: { firstName: name }}){
    console.log(displayName + "is" + name);
}
const user = {
    id: 42,
    displayName: "jdoe",
    fullName: {
        firstName: "John",
        lastName: "Doe"
    }
};
whois(user); // jdoe is John
```
## 扩展运算符与rest运算符
这两种运算符可以很好地解决函数参数和数组元素长度未知情况下的编码问题，使得代码能更加健壮和简洁。
### 扩展运算符
用3个点表示（...），用于将一个数组或类数组对象转换为用逗号分隔的值序列。
```js
// 它的基本用法是拆解数组和字符串。
const array = [1, 2, 3, 4];
console.log(...array); // 1 2 3 4
const str = "string";
console.log(...str); // s t r i n g
```
数组类型变量array和字符串类型变量str在经过扩展运算符的处理后，得到的都是单独的值序列。
#### 扩展运算符代替apply()函数
将数组转换为函数参数。
```js
// 获取数组最大值时
let arr = [1, 4, 6, 8, 2];
console.log(Math.max.apply(null, arr)); // 8
// 使用扩展运算符
console.log(Math.max(...arr)); // 8
```
例如，自定义一个add()函数，用于接收两个参数，并返回两个参数相加的和。当传递的参数是一个数组时，如果使用apply()函数，写法如下。
```js
function add (num1, num2) {
  return num1 + num2;
}
const arr = [1, 3];
add.apply(null, arr); // 4
// 使用扩展运算符
add(...arr); // 4
```
#### 扩展运算符代替concat()函数合并数组

```js
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
console.log(arr1.concat(arr2)); // [ 1, 2, 3, 4, 5, 6 ]
// 使用扩展运算符
console.log([...arr1, ...arr2]); // [ 1, 2, 3, 4, 5, 6 ]
```
#### 扩展运算符转换Set，得到去重的数组
Set具有自动的去重性质
```js
let arr = [1, 2, 4, 6, 2, 7, 4];
console.log([...new Set(arr)]); // [ 1, 2, 4, 6, 7 ]
```
#### 扩展运算符用于对象克隆
使用扩展运算符克隆的对象的属性值为基本数据类型的场景。
```js
let obj = {name: 'ming'};
var obj2 = {...obj};
obj2.name = 'ming2';
console.log(obj); // {name: "ming"}
```
克隆后对象的值进行修改并未影响到被克隆的对象，那么是不是就意味着使用扩展运算符实现的是深克隆呢？

场景：克隆对象的属性值为引用数据类型。
```js
let obj3 = {
    name: 'ming', 
    address: {province: 'guangdong', city: 'guangzhou'}
};
let obj4 = {...obj3};
obj4.name = 'ming3';
obj4.address.city = 'shenzhen';
console.log(obj3);
// {name: "ming", address: {province: "guangdong", city: "shenzhen"}}
```
表明对克隆后对象的值进行更改后，影响到了被克隆的对象，这就意味着使用扩展运算符的克隆并不是严格的深克隆。
```js
// 同样适用于数组
let arr1 = [1, 3, 4, 6];  // 可以进行深克隆
let arr2 = [1, 3, [4, 6]]; // 不可以进行深克隆
```
结论：使用扩展运算符对数组或对象进行克隆时，如果数组的元素或者对象的属性是基本数据类型，则支持深克隆；如果是引用数据类型，则不支持深克隆。
> 因为引用数据类型的克隆只是复制了引用的地址，克隆后的对象仍然共享同一个引用地址。
### rest运算符
> 同样使用3个点表示（...），其作用与扩展运算符相反，用于将以逗号分隔的值序列转换成数组。
#### 与解构组合使用
解构会将相同数据结构对应的值赋给对应的变量，将其中的一部分值统一赋给一个变量时，可以使用rest运算符。
```js
let arr = ['one', 'two', 'three', 'four'];
let [arg1, ...arg2] = arr;
console.log(arg1);  // one
console.log(arg2);  // [ 'two', 'three', 'four' ]
```
使用rest运算符进行解构，则rest运算符对应的变量应该放在最后一位，否则就会抛出异常。因为如果rest运算符不是放在最后一位，变量并不知道要读取多少个数值。
```js
let arr = ['one', 'two', 'three', 'four'];
let [...arg1, arg2] = arr; // SyntaxError: Rest element must be last element 
in array
```
和对象解构相关的内容。
```js
let {x, y, ...z} = {x: 1, y: 2, a: 3, b: 4};
console.log(x); // 1
console.log(y); // 2
console.log(z); // {a: 3, b: 4}
```
#### 代替arguments处理函数参数
```js
// 不确定传入的参数长度，可以统一使用arguments来获取所有传递的参数
function foo() {
    for (let arg of arguments) {
        console.log(arg);
    }
}
foo('one', 'two', 'three', 'four');// 输出'one', 'two', 'three', 'four'
```
函数的参数是一个使用逗号分隔的值序列，可以使用rest运算符处理成一个数组，从而确定最终传入的参数，以代替arguments的使用。
```js
function foo(...args) {
    for (let arg of args) {
        console.log(arg);
    }
}
foo('one', 'two', 'three', 'four');// 输出'one', 'two', 'three', 'four'
```
通过以上对扩展运算符和rest运算符的讲解，其实两者是互为逆运算的，**扩展运算符是将数组分割成独立的序列，而rest运算符是将独立的序列合并成一个数组。**

那么如何判断呢？
- 当3个点（…）出现在函数的**形参**上或者出现在赋值等号的**左侧**，则表示它为rest运算符。
- 当3个点（…）出现在函数的**实参**上或者出现在赋值等号的**右侧**，则表示它为扩展运算符。
## 模板字符串
使用反引号（``）括起来，可用作普通的字符串，也可以用来定义多行字符串，同时支持在字符串中使用${}嵌入变量。
### 字符串原生输出
```js
// 传统字符串方案
var str = 'Hello, my name is ming, ' +
          'I am working in Beijng.';
console.log(str); // Hello, my name is ming, I am working in Beijng.
```
str变量的第一行字符串和第二行字符串之间使用加号进行拼接，并且字符串中有缩进和换行符，但是输出的结果中它们都被忽略了。
```js
let str2 = `Hello, my name is ming,
            I am working in Beijng.`;
console.log(str2);
// 以下是输出结果
Hello, my name is ming,
            I am working in Beijng.
```
而使用模板字符串语法，会保留字符串内部的空白、缩进和换行符。
### 字符串变量值传递
#### 传递基本数据类型的变量
```js
// 传统解决方案
var name = 'ming';
var address = 'Beijing';
var str = 'Hello, my name is ' + name + ', ' +
          'I am working in ' + address + '.';
console.log(str);  // Hello, my name is ming, I am working in Beijng.
```
在一个复杂的语句中，通过变量拼接，会很容易出错，尤其是遇到单引号和双引号同时出现的场景。
```js
// 模板字符串方案
let name = 'ming';
let address = 'Beijing';
let str = `Hello, my name is ${name},
           I am working in ${address}.`;
console.log(str);
// 以下是输出结果
Hello, my name is ming,
            I am working Beijng.
```
#### 传递表达式
在${}之中不仅可以传递变量，还可以传递任意的JavaScript表达式，包括数学运算、属性引用、函数调用。
```js
// 数学运算
let x = 1,
    y = 2;
console.log(`${x} + ${y * 2} = ${x + y * 2}`); // 1 + 4 = 5

// 属性引用和数学运算
let obj = {x: 1, y: 2};
console.log(`${obj.x + obj.y}`); // 3

// 函数调用
function fn() {
    return "Hello World";
}
console.log(`foo ${fn()} bar`); // foo Hello World bar
```
#### 传递复杂引用数据类型的变量
当传递的变量是一个多层嵌套的复杂引用数据类型值时，模板字符串同样可以支持嵌套解析，遇到表达式会解析成对应的值。
```js
const tmpl = function (addrs) {
    return `
        <table>
            ${addrs.map(addr => `
                <tr><td>${addr.provice}</td></tr>
                <tr><td>${addr.city}</td></tr>
            `).join('')}
        </table>
    `;
};
const addrs = [{ provice: '湖北省', city: '武汉市' }, 
{ provice: '广东省', city: '广州市' }];
console.log(tmpl(addrs));
```
输出的字符串结果如下所示。
```js
</table>  
    <tr><td>湖北省</td></tr>
    <tr><td>武汉市</td></tr>
    <tr><td>广东省</td></tr>
    <tr><td>广州市</td></tr>
</table>
```
> 结论：只要${}里是可以获得唯一值的即可

## 箭头函数
```js
// ES6语法
const foo = v => v;
// 等同于传统语法
var foo = function (v) {
    return v;
};
```
在编写上省去了function关键字，函数参数和普通的函数参数一样，函数体会被一个大括号括起来。
```js
const fn = (num1, num2) => {
    return num1 + num2;
};
```
如果函数的参数只有一个，则可以省略小括号；如果函数体只有一行，则可以省略大括号和return关键字。
```js
[1, 2, 3].map(r => r * 2);  // [2, 4, 6]
// 等同于
[1, 2, 3].map(function(r) {
    return r * 2;
});
```
### 箭头函数的特点
#### 语法简洁
求一个数组各项的和。
```js
[1, 2, 3, 4].reduce((x, y) => x + y, 0); // 10
```
数组中的元素按照从小到大顺序排序，可以简写
```js
[1, 4, 6, 3, 2].sort((x, y) => x - y) //[1, 2, 3, 4, 6]
```
过滤出数组中大于3的数字，可以简写
```js
[1, 2, 5, 6, 3].filter(x => x > 3); // [ 5, 6 ]
```
#### 不绑定this
> function: this的指向问题，得出的结论是：this永远指向函数的调用者。
> 在箭头函数中: this指向的是定义时所在的对象，而不是使用时所在的对象。

通过setTimeout()和setInterval()函数看区别。
```js
function Timer() {
    this.s1 = 0;
    this.s2 = 0;
    // 箭头函数
    setInterval(() => this.s1++, 1000);
    // 普通函数
    setInterval(function () {
        this.s2++;
    }, 1000);
}

let timer = new Timer();

setTimeout(() => console.log('s1: ', timer.s1), 3100); // 3.1秒后输出s1: 3
setTimeout(() => console.log('s2: ', timer.s2), 3100); // 3.1秒后输出s2: 0
```
why?
在生成Timer的实例timer后，通过setTimeout()函数在3.1秒后输出timer的s1变量，此时setInterval()函数已经执行了3次，由于this.s1++是处在箭头函数中的，**这里的this就指向timer**，此时timer.s1值为“3”。

而this.s2++是处在普通函数中的，**这里的this指向的是全局对象window**，实际上相当于`window.s2++`，结果是`window.s2 = 3`，而在最后一行的输出结果中，timer.s2仍然为“0”。

> 箭头函数中不会创建自己的this，而是会从自己作用域链的上一层继承this。

```js
const Person = {
    'name': 'ming',
    'age': 18,
    'sayHello': function () {
        setTimeout(() => {
            console.log('我叫' + this.name + '，我今年' + this.age + '岁!')
        }, 1000);
    }
};
Person.sayHello(); // 我叫ming，我今年18岁!

const Person2 = {
    'name': 'little bear',
    'age': 18,
    'sayHello': () => {
        setTimeout(() => {
            console.log('我叫' + this.name + '，我今年' + this.age + '岁!')
        }, 1000);
    }
};
Person2.sayHello(); // 我叫undefined，我今年undefined岁!
```
在第一段代码中，sayHello()函数通过function关键字进行定义，在执行Person.sayHello()函数时，sayHello()函数中的this会指向函数的调用体，即Person本身；在调用setTimeout()函数时，由于其函数体部分是通过箭头函数定义的，内部的this会继承至父作用域的this，因此setTimeout()函数内部的this会指向Person，从而输出结果“我叫ming,我今年18岁!”。

Person2.sayHello()函数时，sayHello()函数中的this会指向外层作用域，而Person2的父作用域就是全局作用域window；在调用setTimeout()函数时，由于其函数体部分是通过箭头函数定义的，内部的this会继承至sayHello()函数所在的作用域的this，即window，而window上并没有定义name和age属性，因此输出结果“我叫undefined,我今年undefined岁!”。

> 对象函数使用箭头函数是不合适的。

#### 不支持call()与apply()函数的特性
> 被调用函数是一个箭头函数，则不会改变箭头函数中this的指向。

```js
let adder = {
  base : 1,
  add : function(a) {
    var f = v => v + this.base;
    return f(a);
  },
  addThruCall: function(a) {
    var f = v => v + this.base;
      var b = {
        base : 2
      };   
    return f.call(b, a);
  }
};
console.log(adder.add(1));         // 2
console.log(adder.addThruCall(1)); // 2
```
在上面的实例中，执行adder.add(1)时，add()函数内部通过箭头函数的形式定义了f()函数，**f()函数中的this会继承至父作用域**，即adder，那么`this.base = 1`，因此执行`adder.add(1)`相当于执行1 + 1的操作，结果输出“2”。

执行adder.addThruCall(1)时，addThruCall()函数内部通过箭头函数定义了f()函数，**其中的this指向了adder**。虽然在返回结果时，通过call()函数调用了f()函数，但是并**不会改变f()函数中this的指向**，this仍然指向adder，而且会接收参数a，因此执行adder.addThruCall(1)相当于执行1 + 1的操作，结果输出“2”。

#### 不绑定arguments
箭头函数中没有arguments
```js
const fn = () => {
    console.log(arguments);
};
fn(1, 2); // Uncaught ReferenceError: arguments is not defined

// 可以借助rest运算符（...）来达到这个目的。
const fn = (..args) => {
  console.log(args);
}
fn(1, 2); // [1, 2]
```
因为无法在箭头函数中使用arguments，同样也就无法使用caller和callee属性。

#### 支持嵌套
场景：有一个参数会以管道的形式经过两个函数处理，第一个函数处理完的输出将作为第二个函数的输入，两个函数运算完后输出最后的结果。
```js
1  const pipeline = (...funcs) =>
2       val => funcs.reduce((a, b) => b(a), val);
3  const plus1 = a => a + 1;
4  const mult2 = a => a * 2;
5  const addThenMult = pipeline(plus1, mult2);
6  addThenMult(5);  // 12
```
先看第5行代码，这里调用了pipeline()函数，并传入plus1和mult2两个参数，返回的是一个函数，在函数中使用reduce()函数先后调用传入的两个处理函数。

在执行第6行代码时，pipeline()函数中的val为5，在第一次执行reduce()函数时，a为5，b为plus1()函数，实际相当于执行5 + 1 = 6，并返回了计算结果。

在第二次执行reduce()函数时，a为上一次返回的结果6，b为mult2()函数，实际相当于执行6×2 = 12，因此最后输出“12”。

### 不适用的场景
#### 不适合作为对象的函数
箭头函数并不会绑定this，如果使用箭头函数定义对象字面量的函数，那么其中的this将会指向外层作用域，并不会指向对象本身，因此箭头函数并不适合作为对象的函数。
#### 不能作为构造函数，不能使用new操作符
构造函数是通过new操作符生成对象实例的，**生成实例的过程也是通过构造函数给实例绑定this的过程**，而箭头函数没有自己的this。因此不能使用箭头函数作为构造函数，也就不能通过new操作符来调用箭头函数。
```js
// 普通函数
function Person(name) {
    this.name = name;
}
var p = new Person('ming'); // 正常
// 箭头函数
let Person = (name) => {
    this.name = name
};
let p = new Person('ming'); // Uncaught TypeError: Person is not a constructor
```
#### 没有prototype属性
箭头函数中是没有this的，也就不存在自己的作用域，因此箭头函数是没有prototype属性的。
```js
let a = () => {
    return 1;
};
function b(){
    return 2;
}
console.log(a.prototype);  // undefined
console.log(b.prototype);  // {constructor: ƒ}
```
#### 不适合将原型函数定义成箭头函数
在给构造函数添加原型函数时，如果使用箭头函数，其中的this会指向全局作用域window，而并不会指向构造函数，因此并不会访问到构造函数本身，也就无法访问到实例属性，这就失去了作为原型函数的意义。
```js
function Person(name) {
    this.name = name
}
Person.prototype.sayHello = () => {
    console.log(this);  // window
    console.log(this.name);  // undefined ❌❌❌
};
let p1 = new Person('ming');
p1.sayHello(); 
```
Person()构造函数增加了一个原型函数sayHello()，因为sayHello()函数是通过箭头函数定义的，所以其中的this会指向全局作用域window，从而无法访问到实例的name属性，输出“undefined”。

## ES6对于对象的扩展
### 属性简写
传统的JavaScript中，对象都会采用`{ key: value }`的写法，但是在ES6中，可以直接在对象中写入变量，key相当于变量名，value相当于变量值，并且可以直接省略value，通过key表示一个对象的完整属性。
```js
const name = 'ming';
const age = 12;
const obj = { name, age }; // { name: 'ming', age: 12 }
// 等同于
const obj = {
    name: name,
    age: age
};
```
函数也可以简写，即省略掉关键字function。
```js
const obj = {
    method: function () {
        return 'Hello';      
    }
};
// 等同于
const obj = {
    method() {
        return 'Hello';
    }
};
```

按照**CommonJS写法**，当需要输出一组模块变量时，对象简写的方法就非常合适。
```js
// 下面是一个完整的使用属性简写的例子。
let obj = {};
// 获取元素
function getItem (key) {
  return key in obj ? obj[key] : null;
}
// 增加元素
function setItem (key, value) {
  obj[key] = value;
}
// 清空对象
function clear() {
  obj = {};
}
module.exports = { getItem, setItem, clear };
// 等同于
module.exports = { getItem: getItem, setItem: setItem, clear: clear };
```
### 属性遍历👍👍👍
到ES6为止，一共有5种方法可以实现对象属性的遍历，具体方法如下所示。
- for...in。
- Object.keys(obj)。
- Object.getOwnPropertyNames(obj)。
- Object.getOwnPropertySymbols(obj)。
- Reflect.ownKeys(obj)。

使用方法和差异性。

定义一个拥有实例属性、继承属性的对象，其中包含Symbol属性、可枚举属性、不可枚举属性，覆盖全部的场景，用来测试这5种属性遍历方法的差异。
```js
// 定义父类
function Animal(name, type) {
  this.name = name;
  this.type = type;
}
// 定义子类
function Cat(age, weight) {
  this.age = age;
  this.weight = weight;
  this[Symbol('one')] = 'one';
}
// 子类继承父类
Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
// 生成子类的实例
let cat = new Cat(12, '10kg');
// 实例增加可枚举属性
Object.defineProperty(cat, 'color', {
  configurable: true,
  enumerable: true,
  value: 'blue',
  writable: true
});
// 实例增加不可枚举属性
Object.defineProperty(cat, 'height', {
  configurable: true,
  enumerable: false,
  value: '20cm',
  writable: true
});
```
实例cat具有的属性如下所示。
```bash
实例属性: age, weight, Symbol('one'), color
继承属性: name, type
可枚举属性：age, weight, color
不可枚举属性: height
Symbol属性: Symbol('one')
```
#### for...in
> 用于遍历对象自身和继承的可枚举属性（**不包含**Symbol属性）。
```js
for(let key in cat) {
  console.log(key); // 'age', 'weight', 'color', 'name', 'type'
}
```
没有包含不可枚举属性height和Symbol属性Symbol('one')。
#### Object.keys()函数
> 返回一个数组，**包含**对象自身所有可枚举属性，**不包含**继承属性和Symbol属性。
```js
Object.keys(cat); // ['age', 'weight', 'color']
```
#### Object.getOwnPropertyNames()函数
> 返回一个数组，**包含**对象自身所有可枚举属性和不可枚举属性，**不包含**继承属性和Symbol属性。
```js
Object.getOwnPropertyNames(cat); // ['age', 'weight', 'color', 'height']
```
#### Object.getOwnPropertySymbols()函数
> 返回一个数组，**包含**对象自身所有Symbol属性，**不包含**其他属性。
```js
Object.getOwnPropertySymbols(cat); // [Symbol('one')]
```
#### Reflect.ownKeys()函数
> 返回一个数组，**包含**可枚举属性、不可枚举属性以及Symbol属性，**不包含**继承属性。
```js
Reflect.ownKeys(cat); // ['age', 'weight', 'color', 'height', Symbol('one')]
```
### 新增Object.assign()函数
用于将一个或者多个对象的**可枚举属性赋值给目标对象**，然后返回目标对象。

当多个源对象具有相同的属性时，后者的属性值会覆盖前面的属性值。
```js
let target = { a: 1 }; //目标对象
let source1 = { b: 2 }; //源对象1
let source2 = { c: 3 }; //源对象2
let source3 = { c: 4 }; //源对象3，和source2对象有同名属性c
console.log(Object.assign(target, source1, source2, source3));
// { a: 1, b: 2, c: 4 }
```
> Object.assign()函数无法复制对象的不可枚举属性和继承属性，但可以复制可枚举的Symbol属性。
```js
// 创建一个同时拥有可枚举属性、不可枚举属性、继承属性、Symbol属性的对象。
let obj = Object.create(
  { a: 1 }, // a是继承属性
  { 
    b: { value: 2 }, // b是不可枚举属性
    c: { value: 3, enumerable: true }, // c是可枚举属性
    [Symbol('one')]: { value: 'one', enumerable: true } // Symbol属性
});
console.log(Object.assign({}, obj)); // { c: 3, Symbol(one): "one" }
```
#### 对象克隆
浅克隆：如果属性是基本数据类型，则会复制它的值；如果属性是引用数据类型，则会复制它的引用。
```js
function cloneObj(source) {
    return Object.assign({}, source);
}
let source = {
    name: 'ming',
    age: 18
};
let result = cloneObj(source);
console.log(result); // { name: 'ming', age: 18 }
```

```js
1 let target = {};
2 let source1 = {a: 1, b: {c: 2}};
3 let result = Object.assign(target, source1);
4 console.log(result.a);  // 1
5 console.log(result.b.c);// 2
6 source1.b.c = 3;
7 console.log(result.b.c); // 3
```
通过上面实例的第1～5行代码可以看出，将source1对象的属性复制后得到了result对象，既可以访问到基本数据类型属性a，也可以访问到引用数据类型属性c。
通过第6、7行代码可以看出，因为使用的是浅克隆，对源对象属性值进行的修改会影响到目标对象的属性值，两者实际共享同一个对象的引用。
#### 给对象添加属性
采用传统的写法为对象添加实例属性时，会将其添加到this属性上。
当属性很多时，通过Object.assign()函数可以节约操作。
```js
// 传统的写法
function Person(name, age, address) {
    this.name = name;
    this.age = age;
    this.address = address;
}
// Object.assign()写法
function Person(name, age, address) {
    Object.assign(this, {name, age, address});
}
```
#### 给对象添加函数
采用传统的写法为对象添加公共的函数时，会扩展其prototype属性，使用Object.assign()函数也可以简化代码编写方式。
```js
// 传统写法
Person.prototype.getName = function () {
    return this.name;
};
Person.prototype.getAge = function () {
    return this.age;
};
// Object.assign()写法
Object.assign(Person.prototype, {
    getName() {
        return this.name;
    },
    getAge() {
        return this.age;  
    }
});
```
#### 合并对象
即可以将多个对象合并到某个对象中，也可以将多个对象合并为一个新对象并返回，只需要将target设置为空对象{}即可。
```js
// 多个对象合并到一个目标对象中
const merge = (target, ...sources) => Object.assign(target, ...sources);
// 多个对象合并为一个新对象并返回
const merge = (...sources) => Object.assign({}, ...sources);
```
## Symbol类型
在传统的JavaScript中，对象的属性名都是由字符串构成的。这样就会带来一个问题，假如一个对象继承了另一个对象的属性，又需要定义新的属性时，很容易造成属性名的冲突。

为了解决这个问题，ES6引入了一种新的基本数据类型Symbol，**它表示的是一个独一无二的值**。

至此JavaScript中就一共存在6种基本数据类型，分别是Undefined类型、Null类型、Boolean类型、String类型、Number类型、**Symbol类型**。
### Symbol类型的特性
#### 值的唯一性
类似于一种唯一标识性的ID，通过Symbol()函数来创建一个Symbol值。
```js
let s = Symbol();
// Symbol类型是一个新增的基本数据类型
console.log(typeof s); // symbol
```
在Symbol()函数中可以传递一个字符串参数，表示对Symbol值的描述，主要是方便对不同Symbol值的区分。
但是需要注意的是，由于Symbol值的唯一性，**任何通过Symbol()函数创建的Symbol值都是不相同的，即使传递了相同的字符串**。
```js
const a = Symbol();
const b = Symbol();
const c = Symbol('one');
const d = Symbol('one');
console.log(a === b);  // false
console.log(c === d);  // false
```
#### 不能使用new操作符
Symbol函数并不是一个构造函数，因此不能通过new操作符创建Symbol值。
```js
let s1 = new Symbol(); // TypeError: Symbol is not a constructor
```
#### 不能参与类型运算
Symbol值可以通过toString()函数显示地转换为字符串，但是本身不能参与其他类型值的运算，例如在对Symbol值进行字符串拼接操作时，会抛出异常。
```js
let s4 = Symbol('hello');
s4.toString(); // Symbol(hello)
's4 content is: ' + s4; // TypeError: Cannot convert a Symbol value to a string
```
#### 可以使用同一个Symbol值
通过Symbol()函数创建的每个值都是不同的，那么当我们想要使用同一个Symbol值时，该怎么处理呢？

那就是使用Symbol.for()函数，它接收一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。
```js
let s1 = Symbol.for('one');
let s2 = Symbol.for('one');
s1 === s2; // true
```
在上面的实例中，通过Symbol.for()函数传入相同的字符串会得到相同的Symbol值，因此返回“true”。

Symbol.for()函数与Symbol()函数这两种写法，都会生成新的Symbol值。
它们的区别是：前者会被登记在全局环境中以供搜索，而后者不会。Symbol.for()函数不会每次调用就返回一个新的Symbol类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。
```js
Symbol.for("bar") === Symbol.for("bar"); // true
Symbol("bar") === Symbol("bar");  // false
```
### Symbol类型的用法
#### 用作对象属性名
由于每一个Symbol值都是不相等的，它会经常用作对象的属性名，尤其是当一个对象由多个模块组成时，这样能够避免属性名被覆盖的情况。
在使用Symbol类型的数据时，存在几种不同的写法，遵循的一个原则就是**为对象字面量新增属性时需要使用方括号[]**。
```js
// 新增一个symbol属性
let PROP_NAME = Symbol();

// 第一种写法
let obj = {};
obj[PROP_NAME] = 'Hello';

// 第二种写法
let obj = {
    [PROP_NAME]: 'Hello'
};

// 第三种写法
let obj = {};
Object.defineProperty(obj, PROP_NAME, {
    value: 'Hello' 
});
```
> 需要注意的是，不能通过点运算符为对象添加Symbol属性。
```js
const PROP_NAME = Symbol();
const obj = {};

obj.PROP_NAME = 'Hello!';
console.log(obj[PROP_NAME]);  // undefined
console.log(obj['PROP_NAME']); // 'Hello'
```
在上面的实例中，在通过点运算符为obj增加PROP_NAME属性时，**这个PROP_NAME实际是一个字符串**，并不是一个Symbol变量。因此通过中括号输出PROP_NAME变量对应的值时，得到的是“undefined”；而通过中括号输出'PROP_NAME'字符串值时，得到的是字符串'Hello'。
#### 用于属性区分
一种场景，即通过区分两个属性来做对应的处理。

假如写一个公共的函数用来计算图形的面积，三角形面积为1/2×底×高，长方形面积为底×高。在传统的写法上，会通过switch判断变量是否为字符串'triangle'或者字符串'rectangle'，然后在调用的时候传递对应的字符串。
```js
// 求图形的面积
function getArea(shape, options) {
    let area = 0;
    switch (shape) {
        case 'triangle':
            area = .5 * options.width * options.height;
            break;
        case 'rectangle':
            area = options.width * options.height;
            break;
    }
    return area;
}
console.log(getArea('triangle', { width: 100, height: 100 }));  // 5000
console.log(getArea('rectangle', { width: 100, height: 100 })); // 10000
```
在上面的写法中，字符串'triangle'和'rectangle'会强耦合在代码中。

而事实上，仅想区分各种不同的形状，并不关心每个形状使用什么字符串表示，只需要知道每个变量的值是独一无二的即可，此时使用Symbol就会很合适。
```js
// 事先声明两个Symbol值，用于作判断
let shapeType = {
    triangle: Symbol('triangle'),
    rectangle: Symbol('rectangle')
};
function getArea(shape, options) {
    let area = 0;
    switch (shape) {
        case shapeType.triangle:
            area = .5 * options.width * options.height;
            break;
        case shapeType.rectangle:
            area = options.width * options.height;
            break;
    }
    return area;
}
console.log(getArea(shapeType.triangle, { width: 100, height: 100 }));  // 5000
console.log(getArea(shapeType.rectangle, { width: 100, height: 100 })); // 10000
```
#### 用于属性名遍历
使用Symbol作为属性名时，不能通过Object.keys()函数或者for...in来枚举，这样可以将一些不需要对外操作和访问的属性通过Symbol来定义。
```js
let obj = {
    [Symbol('name')]: 'Hello',
    age: 18,
    title: 'Engineer'
};
console.log(Object.keys(obj)); // ['age', 'title']
for (let p in obj) {
    console.log(p); // 分别会输出：'age' 和 'title'
}
console.log(Object.getOwnPropertyNames(obj)); // ['age', 'title']
```
因为Symbol属性不会出现在属性遍历的过程中，所以在使用JSON.stringify()函数将对象转换为JSON字符串时，Symbol值也不会出现在结果中
```js
JSON.stringify(obj);  // { "age": 18,"title": "Engineer" }
```
当我们需要获取Symbol属性时，可以使用专门针对Symbol的API。
```js
// 使用Object的API
Object.getOwnPropertySymbols(obj); // [Symbol(name)]
// 使用新增的反射API
Reflect.ownKeys(obj); // [Symbol(name), 'age', 'title']
```
## Set和Map数据结构
### Set数据结构
```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```
