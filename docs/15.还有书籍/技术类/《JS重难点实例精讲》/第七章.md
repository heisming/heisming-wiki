# ES6
## let和const关键字
其实在ES6之前，只存在全局作用域和函数作用域，并不存在块级作用域，这就会导致变量提升的问题。
变量提升往往会因为得到一些出乎意料的结果而受人诟病，所以在ES6中新增了块级作用域来避免这个问题的出现。

> 块级作用域表示的是定义的变量可执行上下文环境只能在一个代码块中，一个代码块由一个大括号括住的代码构成，超出这个代码块范围将无法访问内部的变量。

Demo
```js
{
  let a = 1;
  console.log(a); // 1
}
console.log(a); // ReferenceError: a is not defined
```
当我们使用let关键字定义一个变量a后，能够在代码块中输出变量a的值，但是在代码块外访问时会抛出a未定义的异常。

### let关键字
let关键字用于声明变量，和var关键字的用法类似。但是与var不同的是，let声明的变量只能在let所在的代码块内有效，即在块级作用域内有效，而var声明的变量在块级作用域外仍然有效。
```js
// 看区别
{
    var a = 1;
    let b = 2;
}
console.log(a);  // 1
console.log(b);  // ReferenceError: b is not defined
```
#### let关键字的特性
##### 不存在变量提升
使用var定义的变量会存在变量提升的情况，变量提升会使得变量在声明之前可以被访问，正是因为这个特性的存在，所以会出现各种奇怪的结果。
```js
// 在ES6中，使用let定义的变量不存在变量提升，所以如果在变量声明之前去使用变量，就会抛出异常。
// var声明变量
console.log(c);  // undefined
var c = 'ming';
// let声明变量
console.log(d);  // ReferenceError: d is not defined
let d = 'ming';
```

##### 存在暂时性死区
在ES6中，暂时性死区会出现在使用let或const的代码中，表示的是当程序流程进入一个新的作用域时，在此作用域内使用let或const声明的变量会先在作用域中被创建出来，但此时还未进行赋值，如果此时对该变量进行求值运算，变量是不能被访问的，访问就会抛出异常。

> 其中，流程进入新作用域创建变量到变量可以被访问的这一段代码区域，被称为暂时性死区。

简单点来讲就是，在使用let声明变量之前，该变量都是不可访问的。
```js
if (true) {
    // 暂时性死区开始
    param = 'ming';
    console.log(param); // ReferenceError: param is not defined
    // ……
    // 暂时性死区结束
    let param;
}
```
因为有暂时性死区的存在，typeof运算符也不再是绝对安全的，在let定义的变量之前使用typeof运算符同样会抛出异常。
```js
typeof param;  // ReferenceError: param is not defined
let param;
```
而针对非let或const声明的变量，使用typeof运算符确实是绝对安全的，处理一个未声明的变量时会返回“undefined”。
```js
typeof param;  // undefined
```

##### 不能重复声明

```js
1 function foo() {
2     let arg1 = 'ming';
3     if (true) {
4         let arg1 = 'ming';
5     }
6     var arg1 = 'ming'; // SyntaxError: Identifier 'arg1' has already been declared
7 }
```
在foo()函数内部，使用let与var同时声明了名为arg1的变量，因为处于同一个作用域，所以会抛出异常。

而第4行同样使用let定义的变量arg1，其只在第3～5行的代码块内有效，与外部声明的变量arg1相互独立，故可以正确定义。

在函数内部，如果处于相同作用域下，则不能重复声明和形参相同的变量名。
```js
1 function foo(arg1) {
2     let arg1 = 'ming'; // SyntaxError: Identifier 'arg1' has already been declared
3     if (true) {
4         let arg1 = 'ming';
5     }
6 }
```
第2行代码使用let声明了一个与形参相同的变量arg1，两者同处于函数级作用域中，所以会抛出异常。
而第4行代码使用let声明的变量arg1，其只在第3～5行的代码块内有效，与外部声明的变量arg1相互独立，故可以正确定义。

##### 不再是全局对象的属性
在ES6以前，在浏览器环境的全局作用域下，使用var声明的变量、函数表达式或者函数声明均是window对象的属性。
在ES6以后，依然遵循上述原则，但是如果是使用let声明的变量或者函数表达式，将不再是window对象的属性。
```js
// var声明的变量和函数表达式
var a = 1;
var fn = function () {
    console.log('global method');
};
console.log(window.a); // 1
window.fn();  // global method

// let声明的变量和函数表达式
let b = 2;
let foo = function () {
    console.log('global method');
};
console.log(window.b); // undefined
window.foo(); // TypeError: window.foo is not a function
```
#### 使用let关键字的好处
##### 不会导致for循环索引值泄露
在for循环中，因为循环的索引值一般只会在循环体内有效，所以当循环结束后索引值应该被回收。但是如果通过var定义索引值的话，该索引值在循环结束后仍然可以访问，此时使用let定义循环的索引值就很合适。
```js
// var
for (var i = 0; i < 10; i++) {
    // ...
}
console.log(i);  // 10
// let
for (let i = 0; i < 10; i++) {
    // ...
}
console.log(i); // ReferenceError: i is not defined
```
经典场景：在for循环体中通过函数输出索引i值。
```js
var arr = [];
for (var i = 0; i < 10; i++) {
    arr[i] = function () {
        console.log(i);
    };
}
arr[1]();  // 10
```
通过var定义的索引i值，在调用函数时，最终会输出“10”，这是为什么呢？
因为通过var声明的索引i是一个全局变量，每一次循环，全局变量i都会发生改变。而数组arr所有成员里面的i都指向同一个i，当循环结束后，全局变量i的值已经变为10。
最终在调用成员函数时，每个函数都闭包了全局变量i，因此会输出“10”。

通过let定义的索引值就不会出现这个问题。
```js
var arr = [];
for (let i = 0; i < 10; i++) {
    arr[i] = function () {
        console.log(i);
    };
}
arr[1]();  // 1
```
这是因为通过let定义的索引值i，只在当前循环内有效，实际上每一轮循环中的i都是一个新的变量，而且最关键的是JavaScript引擎能够记住上一轮循环的值，所以在本轮循环开始时，会基于上一轮循环计算，从而索引i的值会递增。

因此在调用arr数组的成员函数时，会输出正确的索引i值。
为什么通过let声明的变量i在循环体外，仍然可以访问呢？这是因为arr数组的每个成员都是一个函数，对变量i的引用**构成了一个闭包**，所以在循环体外调用函数时仍然可以访问到i。

另外for循环还有一个特别之处，声明变量的那部分（小括号内部）是一个父作用域，循环体内部是一个单独的子作用域。
```js
for (let i = 0; i < 2; i++) {
    let i = 'ming';
    console.log(i); // 输出两次'ming'
}
```
根据let的特点，如果在同一个代码块中同时使用let定义了具有相同名称的变量，则会直接抛出异常。
而在上面的例子中，小括号内和循环体内同时使用let声明了变量i，但是在循环体内仍然可以输出变量i的值，就表明这两个变量i是处在两个独立的父子作用域中的。

##### 避免出现变量提升导致的变量覆盖问题
```js
var arg1 = 'ming';
function foo() {
    console.log(arg1);  // undefined
    if (false) {
        var arg1 = 'ming2';
    }
}
foo(); // undefined
```
在上面的实例中，定义了一个全局变量arg1，在foo()函数中想要输出变量arg1，但是由于变量提升的存在，if代码块内的变量arg1会被提升至foo()函数顶部，导致输出arg1时覆盖了外层的全局变量arg1，因此输出“undefined”。

如果使用let定义if代码块内的arg1，则该arg1只在if代码块内有效，不会影响到全局的arg1变量，从而能输出“ming”。
##### 代替立即执行函数IIFE
立即执行函数（Immediately-Invoked Function Expression，简称IIFE）的内部是一个独立的函数级作用域，使用IIFE的目的主要是避免污染当前作用域内的变量，而使用块级作用域则可以直接避免这个问题。
```js
// I IFE 写法
(function () {
   var arg = ...;
    ...
}());
// 块级作用域写法
{
    let arg = ...;
    ...
}
```
### const关键字
```js
// 声明的值为一个常量，一旦声明将不会再改变。
const MAX = 123;
MAX = 456; // TypeError: Assignment to constant variable.
// 如果只声明，不初始化，则会抛出异常。
const MAX = 123; // 声明正常
const MIN; // SyntaxError: Missing initializer in const declaration
```
const与let声明的变量存在以下相同的特性。
#### 在块级作用域内有效
```js
if (true) {
    const MAX = 123;
}
console.log(MAX);  // ReferenceError: MAX is not defined
```
#### 不存在变量提升，会产生暂时性死区
使用const声明的常量也不会进行变量提升，只能在const声明之后使用常量，在使用处到常量的声明之前会产生暂时性死区。
```js
if (true) {
    console.log(MAX);  // ReferenceError: MAX is not defined
    const MAX = 123;
}
```
#### 不能重复声明变量
在同一个作用域内，不能重复使用const声明常量。
```js
var MIN = 1;
if (true) {
    const MIN = 1; // 正常声明
}
const MIN = 2;  // SyntaxError: Identifier 'MIN' has already been declared
```
> 使用const声明的变量不能被修改，严格意义来说是保存变量值的内存地址不能被修改。

对于基本类型的变量来说，变量就保存着内存地址的值，因此不能直接修改；而对于引用类型的变量来说，变量保存的是一个指向数据内存地址的指针，只要该指针固定不变，就可以改变数据本身的值。
```js
const person = {
    age: 12
};
person.name = 'ming';
person.age = 13;
console.log(person); // { age: 13, name: 'ming' }
person = { age: 12 }; // TypeError: Assignment to constant variable.
```
在上面的实例中，使用const定义了一个person变量，其值为对象类型，然后新增了一个name属性，并修改age属性，仍然能正常输出。
但是当我们重新给person变量赋值时，会抛出异常。
对于数组类型的变量，变量存储的是数组在内存中的地址，仍然可以修改每个元素的值。
```js
// 简单类型成员的数组
const arr = ['1', '2'];
arr[0] = '3';  // 正常操作
// 引用类型成员的数组
const arr2 = [{
    name: 'ming'
}];
arr2[0] = null;  // 正常操作
```
重新给arr或者arr2赋值新的数组时，会抛出异常。
```js
arr = ['3']; // TypeError: Assignment to constant variable.
```
#### 不再是全局对象的属性
与let一致，**在浏览器环境下**，使用const声明的变量不再是全局对象的属性。
```js
const c = 1;
console.log(window.c); // undefined
```

## 解构赋值
传统的ES5及以前的版本中
```js
var arr = ['one', 'two', 'three'];
var one = arr[0];
var two = arr[1];

var obj = {name: 'ming', age: 21};
var name = obj.name;
var age = obj.age;
```
### 数组的解构赋值
针对数组，在解构赋值时，使用的是模式匹配，只要等号两边数组的模式相同，右边数组的值就会相应赋给左边数组的变量。
```js
let [arg1, arg2] = [12, 34];
console.log(num1); // 12
console.log(num2); // 34
```
使用逗号作为占位符，而不指定变量名。
```js
let [, , num3] = [12, 34, 56];
console.log(num3); // 56
```
当右边的数组的值不足以将左边数组的值全部赋值时，会解构失败，对应的值就等于“undefined”。
```js
let [num1, num2, num3] = [12, 34];
console.log(num2); // 34
console.log(num3); // undefined
```
#### 数组解构默认值
在数组解构时设置默认值，可以防止出现解构得到undefined值的情况。具体的做法是在左侧的数组中，直接给变量赋初始值。
```js
let [num1 = 1, num2] = [, 34];
console.log(num1); // 1
console.log(num2); // 34
```
要注意的是，ES6在判断解构是否会得到undefined值时，使用的是严格等于（===）。只有在**严格等于undefined的情况下**，才会判断该值解构为undefined，**相应变量的默认值才会生效**。
```js
let [
    num1 = 1,
    num2 = 2,
    num3 = 3
] = [null, ''];
console.log(num1);  // null
console.log(num2);  // ''
console.log(num3);  // 3
```
#### 交换变量
在使用解构赋值以前，当我们需要交换两个变量时，需要使用一个临时变量，以下是一个经典的写法。
```js
var a = 1;
var b = 2;
var tmp; // 临时变量

tmp = a;
a = b;
b = tmp;
console.log(a);  // 2
console.log(b);  // 1
```
如果使用数组的解构赋值，只需要在等式两边的数组中交换两个变量的顺序即可。
```js
var a = 1;
var b = 2;
// 使用数组的解构赋值交换变量
[b, a] = [a, b];
console.log(a);  // 2
console.log(b);  // 1
```
#### 解析函数返回的数组
```js
function fn() {
    return [12, 34];
}
let [num1, num2] = fn();
console.log(num1); // 12
console.log(num2); // 34
```
####  嵌套数组的解构
```js
let [num1, num2, [num3]] = [12, [34, 56], [78, 89]];
console.log(num1); // 12
console.log(num2); // [34, 56]
console.log(num3); // 78
```
#### 函数参数解构
当函数的参数为数组类型时，可以将实参和形参进行解构。
```js
function foo([arg1, arg2]) {
    console.log(arg1); // 2
    console.log(arg2); // 3
}
foo([2, 3]);
```
### 对象的解构赋值
在ES6中，对象同样可以进行解构赋值。数组的解构赋值是基于数组元素的索引，只要左右两侧的数组元素索引相同，便可以进行解构赋值。但是在对象中，属性是没有顺序的，这就要求右侧解构对象的属性名和左侧定义对象的变量名必须相同，这样才可以进行解构。
同样，未匹配到的变量名在解构时会赋值“undefined”。
```js
let {m, n, o} = {m: 'ming', n: 12};
console.log(m); // ming
console.log(n); // 12
console.log(o); // undefined
```
当解构对象的属性名和定义的变量名不同时，必须严格按照key:value的形式补充左侧对象。
```js
let {m: name, n: age} = {m: 'ming', n: 12};
console.log(name); // ming
console.log(age); // 12
```
而当key和value值相同时，对于value的省略实际上是一种简写方案。
```js
let {m: m, n: n} = {m: 'ming', n: 12};
// 简写方案
let {m, n} = {m: 'ming', n: 12};
```
事实上，对象解构赋值的原理是：先找到左右两侧相同的属性名（key），然后再赋给对应的变量（value），真正被赋值的是value部分，并不是key的部分。
在如下所示的代码中，m作为key，只是用于匹配两侧的属性名是否相同，而真正被赋值的是右侧的name变量，最终name变量会被赋值为“ming”，而m不会被赋值。
```js
let {m: name} = {m: 'ming'};
console.log(name);// ming
console.log(m); // ReferenceError: m is not defined
```
#### 对象解构的默认值
默认值生效的条件是对应的属性值严格等于undefined。
```js
let {m, n = 1, o = true} = {m: 'ming', o: null};
console.log(m); // ming
console.log(n); // 1
console.log(o); // null，因为null与undefined不严格相等，默认值并未生效
```
当属性名和变量名不相同时，默认值是赋给变量的。
```js
let {m, n: age = 1} = {m: 'ming'};
console.log(m);   // ming
console.log(age); // 1
console.log(n);   // ReferenceError: n is not defined
```
#### 嵌套对象的解构
解构时从最外层对象向内部逐层进行，每一层对象值都遵循相同的解构规则。
```js
let obj = {
    p: [
        'Hello',
        {y: 'World'}
    ]
};
let {p: [x, {y: name}]} = obj;
console.log(x); // Hello
console.log(name); // World
console.log(y); // ReferenceError: y is not defined
```
在上面的实例中，变量obj是一个嵌套对象，会存在多次解构的过程。
第一次解构从最外层的属性p开始，属性p对应的值为一个数组[‘Hello’, {y: ‘World’}]，对应左侧的[x, {y: name}]。
第二次解构得到的x值为“Hello”，{y: ‘World’}对应左侧的{y: name} 。
第三次解构得到name值为“World”，解构结束。而y仅仅作为匹配属性名的key，不会参与赋值，因此输出y值时，会抛出异常。
注意：当父层对象对应的属性不存在，而解构子层对象时，会出错并抛出异常。
```js
let obj = {
    m: {
        n: 'ming'
    }
};

let {o: {n}} = obj;
console.log(n); //TypeError: Cannot match against 'undefined' or 'null'.
```
因为在obj对象中，外层的属性名是m，而在左侧的对象中，外层属性名是o，两者并不匹配，所以o会解构得到“undefined”。而对undefined再次解构想要获取n属性时，相当于调用undefined.n，会抛出异常。
#### 选择性解构对象的属性
假如一个对象有很多通用的函数，在某次处理中，只想使用其中的几个函数，那么可以使用解构赋值。
```js
let { min, max } = Math;
console.log(min(1, 3));  // 1
console.log(max(1, 3));  // 3
```
#### 函数参数解构
当函数的参数是一个复杂的对象类型时，可以通过解构去获得想要获取的值并赋给变量。
```js
function whois({displayName: displayName, fullName: { firstName: name }}){
    console.log(displayName + "is" + name);
}
const user = {
    id: 42,
    displayName: "jdoe",
    fullName: {
        firstName: "John",
        lastName: "Doe"
    }
};
whois(user); // jdoe is John
```
## 扩展运算符与rest运算符
这两种运算符可以很好地解决函数参数和数组元素长度未知情况下的编码问题，使得代码能更加健壮和简洁。
### 扩展运算符
用3个点表示（...），用于将一个数组或类数组对象转换为用逗号分隔的值序列。
```js
// 它的基本用法是拆解数组和字符串。
const array = [1, 2, 3, 4];
console.log(...array); // 1 2 3 4
const str = "string";
console.log(...str); // s t r i n g
```
数组类型变量array和字符串类型变量str在经过扩展运算符的处理后，得到的都是单独的值序列。
#### 扩展运算符代替apply()函数
将数组转换为函数参数。
```js
// 获取数组最大值时
let arr = [1, 4, 6, 8, 2];
console.log(Math.max.apply(null, arr)); // 8
// 使用扩展运算符
console.log(Math.max(...arr)); // 8
```
例如，自定义一个add()函数，用于接收两个参数，并返回两个参数相加的和。当传递的参数是一个数组时，如果使用apply()函数，写法如下。
```js
function add (num1, num2) {
  return num1 + num2;
}
const arr = [1, 3];
add.apply(null, arr); // 4
// 使用扩展运算符
add(...arr); // 4
```
#### 扩展运算符代替concat()函数合并数组

```js
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
console.log(arr1.concat(arr2)); // [ 1, 2, 3, 4, 5, 6 ]
// 使用扩展运算符
console.log([...arr1, ...arr2]); // [ 1, 2, 3, 4, 5, 6 ]
```
#### 扩展运算符转换Set，得到去重的数组
Set具有自动的去重性质
```js
let arr = [1, 2, 4, 6, 2, 7, 4];
console.log([...new Set(arr)]); // [ 1, 2, 4, 6, 7 ]
```
#### 扩展运算符用于对象克隆
使用扩展运算符克隆的对象的属性值为基本数据类型的场景。
```js
let obj = {name: 'ming'};
var obj2 = {...obj};
obj2.name = 'ming2';
console.log(obj); // {name: "ming"}
```
克隆后对象的值进行修改并未影响到被克隆的对象，那么是不是就意味着使用扩展运算符实现的是深克隆呢？

场景：克隆对象的属性值为引用数据类型。
```js
let obj3 = {
    name: 'ming', 
    address: {province: 'guangdong', city: 'guangzhou'}
};
let obj4 = {...obj3};
obj4.name = 'ming3';
obj4.address.city = 'shenzhen';
console.log(obj3);
// {name: "ming", address: {province: "guangdong", city: "shenzhen"}}
```
表明对克隆后对象的值进行更改后，影响到了被克隆的对象，这就意味着使用扩展运算符的克隆并不是严格的深克隆。
```js
// 同样适用于数组
let arr1 = [1, 3, 4, 6];  // 可以进行深克隆
let arr2 = [1, 3, [4, 6]]; // 不可以进行深克隆
```
结论：使用扩展运算符对数组或对象进行克隆时，如果数组的元素或者对象的属性是基本数据类型，则支持深克隆；如果是引用数据类型，则不支持深克隆。
> 因为引用数据类型的克隆只是复制了引用的地址，克隆后的对象仍然共享同一个引用地址。
### rest运算符
> 同样使用3个点表示（...），其作用与扩展运算符相反，用于将以逗号分隔的值序列转换成数组。
#### 与解构组合使用
解构会将相同数据结构对应的值赋给对应的变量，将其中的一部分值统一赋给一个变量时，可以使用rest运算符。
```js
let arr = ['one', 'two', 'three', 'four'];
let [arg1, ...arg2] = arr;
console.log(arg1);  // one
console.log(arg2);  // [ 'two', 'three', 'four' ]
```
使用rest运算符进行解构，则rest运算符对应的变量应该放在最后一位，否则就会抛出异常。因为如果rest运算符不是放在最后一位，变量并不知道要读取多少个数值。
```js
let arr = ['one', 'two', 'three', 'four'];
let [...arg1, arg2] = arr; // SyntaxError: Rest element must be last element 
in array
```
和对象解构相关的内容。
```js
let {x, y, ...z} = {x: 1, y: 2, a: 3, b: 4};
console.log(x); // 1
console.log(y); // 2
console.log(z); // {a: 3, b: 4}
```
#### 代替arguments处理函数参数
```js
// 不确定传入的参数长度，可以统一使用arguments来获取所有传递的参数
function foo() {
    for (let arg of arguments) {
        console.log(arg);
    }
}
foo('one', 'two', 'three', 'four');// 输出'one', 'two', 'three', 'four'
```
函数的参数是一个使用逗号分隔的值序列，可以使用rest运算符处理成一个数组，从而确定最终传入的参数，以代替arguments的使用。
```js
function foo(...args) {
    for (let arg of args) {
        console.log(arg);
    }
}
foo('one', 'two', 'three', 'four');// 输出'one', 'two', 'three', 'four'
```
通过以上对扩展运算符和rest运算符的讲解，其实两者是互为逆运算的，**扩展运算符是将数组分割成独立的序列，而rest运算符是将独立的序列合并成一个数组。**

那么如何判断呢？
- 当3个点（…）出现在函数的**形参**上或者出现在赋值等号的**左侧**，则表示它为rest运算符。
- 当3个点（…）出现在函数的**实参**上或者出现在赋值等号的**右侧**，则表示它为扩展运算符。
## 模板字符串
使用反引号（``）括起来，可用作普通的字符串，也可以用来定义多行字符串，同时支持在字符串中使用${}嵌入变量。
### 字符串原生输出
```js
// 传统字符串方案
var str = 'Hello, my name is ming, ' +
          'I am working in Beijng.';
console.log(str); // Hello, my name is ming, I am working in Beijng.
```
str变量的第一行字符串和第二行字符串之间使用加号进行拼接，并且字符串中有缩进和换行符，但是输出的结果中它们都被忽略了。
```js
let str2 = `Hello, my name is ming,
            I am working in Beijng.`;
console.log(str2);
// 以下是输出结果
Hello, my name is ming,
            I am working in Beijng.
```
而使用模板字符串语法，会保留字符串内部的空白、缩进和换行符。
### 字符串变量值传递
#### 传递基本数据类型的变量
```js
// 传统解决方案
var name = 'ming';
var address = 'Beijing';
var str = 'Hello, my name is ' + name + ', ' +
          'I am working in ' + address + '.';
console.log(str);  // Hello, my name is ming, I am working in Beijng.
```
在一个复杂的语句中，通过变量拼接，会很容易出错，尤其是遇到单引号和双引号同时出现的场景。
```js
// 模板字符串方案
let name = 'ming';
let address = 'Beijing';
let str = `Hello, my name is ${name},
           I am working in ${address}.`;
console.log(str);
// 以下是输出结果
Hello, my name is ming,
            I am working Beijng.
```
#### 传递表达式
在${}之中不仅可以传递变量，还可以传递任意的JavaScript表达式，包括数学运算、属性引用、函数调用。
```js
// 数学运算
let x = 1,
    y = 2;
console.log(`${x} + ${y * 2} = ${x + y * 2}`); // 1 + 4 = 5

// 属性引用和数学运算
let obj = {x: 1, y: 2};
console.log(`${obj.x + obj.y}`); // 3

// 函数调用
function fn() {
    return "Hello World";
}
console.log(`foo ${fn()} bar`); // foo Hello World bar
```
#### 传递复杂引用数据类型的变量
当传递的变量是一个多层嵌套的复杂引用数据类型值时，模板字符串同样可以支持嵌套解析，遇到表达式会解析成对应的值。
```js
const tmpl = function (addrs) {
    return `
        <table>
            ${addrs.map(addr => `
                <tr><td>${addr.provice}</td></tr>
                <tr><td>${addr.city}</td></tr>
            `).join('')}
        </table>
    `;
};
const addrs = [{ provice: '湖北省', city: '武汉市' }, 
{ provice: '广东省', city: '广州市' }];
console.log(tmpl(addrs));
```
输出的字符串结果如下所示。
```js
</table>  
    <tr><td>湖北省</td></tr>
    <tr><td>武汉市</td></tr>
    <tr><td>广东省</td></tr>
    <tr><td>广州市</td></tr>
</table>
```
> 结论：只要${}里是可以获得唯一值的即可

## 箭头函数
```js
// ES6语法
const foo = v => v;
// 等同于传统语法
var foo = function (v) {
    return v;
};
```
在编写上省去了function关键字，函数参数和普通的函数参数一样，函数体会被一个大括号括起来。
```js
const fn = (num1, num2) => {
    return num1 + num2;
};
```
如果函数的参数只有一个，则可以省略小括号；如果函数体只有一行，则可以省略大括号和return关键字。
```js
[1, 2, 3].map(r => r * 2);  // [2, 4, 6]
// 等同于
[1, 2, 3].map(function(r) {
    return r * 2;
});
```
### 箭头函数的特点
#### 语法简洁
求一个数组各项的和。
```js
[1, 2, 3, 4].reduce((x, y) => x + y, 0); // 10
```
数组中的元素按照从小到大顺序排序，可以简写
```js
[1, 4, 6, 3, 2].sort((x, y) => x - y) //[1, 2, 3, 4, 6]
```
过滤出数组中大于3的数字，可以简写
```js
[1, 2, 5, 6, 3].filter(x => x > 3); // [ 5, 6 ]
```
#### 不绑定this
> function: this的指向问题，得出的结论是：this永远指向函数的调用者。
> 在箭头函数中: this指向的是定义时所在的对象，而不是使用时所在的对象。

通过setTimeout()和setInterval()函数看区别。
```js
function Timer() {
    this.s1 = 0;
    this.s2 = 0;
    // 箭头函数
    setInterval(() => this.s1++, 1000);
    // 普通函数
    setInterval(function () {
        this.s2++;
    }, 1000);
}

let timer = new Timer();

setTimeout(() => console.log('s1: ', timer.s1), 3100); // 3.1秒后输出s1: 3
setTimeout(() => console.log('s2: ', timer.s2), 3100); // 3.1秒后输出s2: 0
```
why?
在生成Timer的实例timer后，通过setTimeout()函数在3.1秒后输出timer的s1变量，此时setInterval()函数已经执行了3次，由于this.s1++是处在箭头函数中的，**这里的this就指向timer**，此时timer.s1值为“3”。

而this.s2++是处在普通函数中的，**这里的this指向的是全局对象window**，实际上相当于`window.s2++`，结果是`window.s2 = 3`，而在最后一行的输出结果中，timer.s2仍然为“0”。

> 箭头函数中不会创建自己的this，而是会从自己作用域链的上一层继承this。

```js
const Person = {
    'name': 'ming',
    'age': 18,
    'sayHello': function () {
        setTimeout(() => {
            console.log('我叫' + this.name + '，我今年' + this.age + '岁!')
        }, 1000);
    }
};
Person.sayHello(); // 我叫ming，我今年18岁!

const Person2 = {
    'name': 'little bear',
    'age': 18,
    'sayHello': () => {
        setTimeout(() => {
            console.log('我叫' + this.name + '，我今年' + this.age + '岁!')
        }, 1000);
    }
};
Person2.sayHello(); // 我叫undefined，我今年undefined岁!
```
在第一段代码中，sayHello()函数通过function关键字进行定义，在执行Person.sayHello()函数时，sayHello()函数中的this会指向函数的调用体，即Person本身；在调用setTimeout()函数时，由于其函数体部分是通过箭头函数定义的，内部的this会继承至父作用域的this，因此setTimeout()函数内部的this会指向Person，从而输出结果“我叫ming,我今年18岁!”。

Person2.sayHello()函数时，sayHello()函数中的this会指向外层作用域，而Person2的父作用域就是全局作用域window；在调用setTimeout()函数时，由于其函数体部分是通过箭头函数定义的，内部的this会继承至sayHello()函数所在的作用域的this，即window，而window上并没有定义name和age属性，因此输出结果“我叫undefined,我今年undefined岁!”。

> 对象函数使用箭头函数是不合适的。

#### 不支持call()与apply()函数的特性
> 被调用函数是一个箭头函数，则不会改变箭头函数中this的指向。

```js
let adder = {
  base : 1,
  add : function(a) {
    var f = v => v + this.base;
    return f(a);
  },
  addThruCall: function(a) {
    var f = v => v + this.base;
      var b = {
        base : 2
      };   
    return f.call(b, a);
  }
};
console.log(adder.add(1));         // 2
console.log(adder.addThruCall(1)); // 2
```
在上面的实例中，执行adder.add(1)时，add()函数内部通过箭头函数的形式定义了f()函数，**f()函数中的this会继承至父作用域**，即adder，那么`this.base = 1`，因此执行`adder.add(1)`相当于执行1 + 1的操作，结果输出“2”。

执行adder.addThruCall(1)时，addThruCall()函数内部通过箭头函数定义了f()函数，**其中的this指向了adder**。虽然在返回结果时，通过call()函数调用了f()函数，但是并**不会改变f()函数中this的指向**，this仍然指向adder，而且会接收参数a，因此执行adder.addThruCall(1)相当于执行1 + 1的操作，结果输出“2”。

#### 不绑定arguments
箭头函数中没有arguments
```js
const fn = () => {
    console.log(arguments);
};
fn(1, 2); // Uncaught ReferenceError: arguments is not defined

// 可以借助rest运算符（...）来达到这个目的。
const fn = (..args) => {
  console.log(args);
}
fn(1, 2); // [1, 2]
```
因为无法在箭头函数中使用arguments，同样也就无法使用caller和callee属性。

#### 支持嵌套
场景：有一个参数会以管道的形式经过两个函数处理，第一个函数处理完的输出将作为第二个函数的输入，两个函数运算完后输出最后的结果。
```js
1  const pipeline = (...funcs) =>
2       val => funcs.reduce((a, b) => b(a), val);
3  const plus1 = a => a + 1;
4  const mult2 = a => a * 2;
5  const addThenMult = pipeline(plus1, mult2);
6  addThenMult(5);  // 12
```
先看第5行代码，这里调用了pipeline()函数，并传入plus1和mult2两个参数，返回的是一个函数，在函数中使用reduce()函数先后调用传入的两个处理函数。

在执行第6行代码时，pipeline()函数中的val为5，在第一次执行reduce()函数时，a为5，b为plus1()函数，实际相当于执行5 + 1 = 6，并返回了计算结果。

在第二次执行reduce()函数时，a为上一次返回的结果6，b为mult2()函数，实际相当于执行6×2 = 12，因此最后输出“12”。

### 不适用的场景
#### 不适合作为对象的函数
箭头函数并不会绑定this，如果使用箭头函数定义对象字面量的函数，那么其中的this将会指向外层作用域，并不会指向对象本身，因此箭头函数并不适合作为对象的函数。
#### 不能作为构造函数，不能使用new操作符
构造函数是通过new操作符生成对象实例的，**生成实例的过程也是通过构造函数给实例绑定this的过程**，而箭头函数没有自己的this。因此不能使用箭头函数作为构造函数，也就不能通过new操作符来调用箭头函数。
```js
// 普通函数
function Person(name) {
    this.name = name;
}
var p = new Person('ming'); // 正常
// 箭头函数
let Person = (name) => {
    this.name = name
};
let p = new Person('ming'); // Uncaught TypeError: Person is not a constructor
```
#### 没有prototype属性
箭头函数中是没有this的，也就不存在自己的作用域，因此箭头函数是没有prototype属性的。
```js
let a = () => {
    return 1;
};
function b(){
    return 2;
}
console.log(a.prototype);  // undefined
console.log(b.prototype);  // {constructor: ƒ}
```
#### 不适合将原型函数定义成箭头函数
在给构造函数添加原型函数时，如果使用箭头函数，其中的this会指向全局作用域window，而并不会指向构造函数，因此并不会访问到构造函数本身，也就无法访问到实例属性，这就失去了作为原型函数的意义。
```js
function Person(name) {
    this.name = name
}
Person.prototype.sayHello = () => {
    console.log(this);  // window
    console.log(this.name);  // undefined ❌❌❌
};
let p1 = new Person('ming');
p1.sayHello(); 
```
Person()构造函数增加了一个原型函数sayHello()，因为sayHello()函数是通过箭头函数定义的，所以其中的this会指向全局作用域window，从而无法访问到实例的name属性，输出“undefined”。

## ES6对于对象的扩展
### 属性简写
传统的JavaScript中，对象都会采用`{ key: value }`的写法，但是在ES6中，可以直接在对象中写入变量，key相当于变量名，value相当于变量值，并且可以直接省略value，通过key表示一个对象的完整属性。
```js
const name = 'ming';
const age = 12;
const obj = { name, age }; // { name: 'ming', age: 12 }
// 等同于
const obj = {
    name: name,
    age: age
};
```
函数也可以简写，即省略掉关键字function。
```js
const obj = {
    method: function () {
        return 'Hello';      
    }
};
// 等同于
const obj = {
    method() {
        return 'Hello';
    }
};
```

按照**CommonJS写法**，当需要输出一组模块变量时，对象简写的方法就非常合适。
```js
// 下面是一个完整的使用属性简写的例子。
let obj = {};
// 获取元素
function getItem (key) {
  return key in obj ? obj[key] : null;
}
// 增加元素
function setItem (key, value) {
  obj[key] = value;
}
// 清空对象
function clear() {
  obj = {};
}
module.exports = { getItem, setItem, clear };
// 等同于
module.exports = { getItem: getItem, setItem: setItem, clear: clear };
```
### 属性遍历👍👍👍
到ES6为止，一共有5种方法可以实现对象属性的遍历，具体方法如下所示。
- for...in。
- Object.keys(obj)。
- Object.getOwnPropertyNames(obj)。
- Object.getOwnPropertySymbols(obj)。
- Reflect.ownKeys(obj)。

使用方法和差异性。

定义一个拥有实例属性、继承属性的对象，其中包含Symbol属性、可枚举属性、不可枚举属性，覆盖全部的场景，用来测试这5种属性遍历方法的差异。
```js
// 定义父类
function Animal(name, type) {
  this.name = name;
  this.type = type;
}
// 定义子类
function Cat(age, weight) {
  this.age = age;
  this.weight = weight;
  this[Symbol('one')] = 'one';
}
// 子类继承父类
Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
// 生成子类的实例
let cat = new Cat(12, '10kg');
// 实例增加可枚举属性
Object.defineProperty(cat, 'color', {
  configurable: true,
  enumerable: true,
  value: 'blue',
  writable: true
});
// 实例增加不可枚举属性
Object.defineProperty(cat, 'height', {
  configurable: true,
  enumerable: false,
  value: '20cm',
  writable: true
});
```
实例cat具有的属性如下所示。
```bash
实例属性: age, weight, Symbol('one'), color
继承属性: name, type
可枚举属性：age, weight, color
不可枚举属性: height
Symbol属性: Symbol('one')
```
#### for...in
> 用于遍历对象自身和继承的可枚举属性（**不包含**Symbol属性）。
```js
for(let key in cat) {
  console.log(key); // 'age', 'weight', 'color', 'name', 'type'
}
```
没有包含不可枚举属性height和Symbol属性Symbol('one')。
#### Object.keys()函数
> 返回一个数组，**包含**对象自身所有可枚举属性，**不包含**继承属性和Symbol属性。
```js
Object.keys(cat); // ['age', 'weight', 'color']
```
#### Object.getOwnPropertyNames()函数
> 返回一个数组，**包含**对象自身所有可枚举属性和不可枚举属性，**不包含**继承属性和Symbol属性。
```js
Object.getOwnPropertyNames(cat); // ['age', 'weight', 'color', 'height']
```
#### Object.getOwnPropertySymbols()函数
> 返回一个数组，**包含**对象自身所有Symbol属性，**不包含**其他属性。
```js
Object.getOwnPropertySymbols(cat); // [Symbol('one')]
```
#### Reflect.ownKeys()函数
> 返回一个数组，**包含**可枚举属性、不可枚举属性以及Symbol属性，**不包含**继承属性。
```js
Reflect.ownKeys(cat); // ['age', 'weight', 'color', 'height', Symbol('one')]
```
### 新增Object.assign()函数
用于将一个或者多个对象的**可枚举属性赋值给目标对象**，然后返回目标对象。

当多个源对象具有相同的属性时，后者的属性值会覆盖前面的属性值。
```js
let target = { a: 1 }; //目标对象
let source1 = { b: 2 }; //源对象1
let source2 = { c: 3 }; //源对象2
let source3 = { c: 4 }; //源对象3，和source2对象有同名属性c
console.log(Object.assign(target, source1, source2, source3));
// { a: 1, b: 2, c: 4 }
```
> Object.assign()函数无法复制对象的不可枚举属性和继承属性，但可以复制可枚举的Symbol属性。
```js
// 创建一个同时拥有可枚举属性、不可枚举属性、继承属性、Symbol属性的对象。
let obj = Object.create(
  { a: 1 }, // a是继承属性
  { 
    b: { value: 2 }, // b是不可枚举属性
    c: { value: 3, enumerable: true }, // c是可枚举属性
    [Symbol('one')]: { value: 'one', enumerable: true } // Symbol属性
});
console.log(Object.assign({}, obj)); // { c: 3, Symbol(one): "one" }
```
#### 对象克隆
浅克隆：如果属性是基本数据类型，则会复制它的值；如果属性是引用数据类型，则会复制它的引用。
```js
function cloneObj(source) {
    return Object.assign({}, source);
}
let source = {
    name: 'ming',
    age: 18
};
let result = cloneObj(source);
console.log(result); // { name: 'ming', age: 18 }
```

```js
1 let target = {};
2 let source1 = {a: 1, b: {c: 2}};
3 let result = Object.assign(target, source1);
4 console.log(result.a);  // 1
5 console.log(result.b.c);// 2
6 source1.b.c = 3;
7 console.log(result.b.c); // 3
```
通过上面实例的第1～5行代码可以看出，将source1对象的属性复制后得到了result对象，既可以访问到基本数据类型属性a，也可以访问到引用数据类型属性c。
通过第6、7行代码可以看出，因为使用的是浅克隆，对源对象属性值进行的修改会影响到目标对象的属性值，两者实际共享同一个对象的引用。
#### 给对象添加属性
采用传统的写法为对象添加实例属性时，会将其添加到this属性上。
当属性很多时，通过Object.assign()函数可以节约操作。
```js
// 传统的写法
function Person(name, age, address) {
    this.name = name;
    this.age = age;
    this.address = address;
}
// Object.assign()写法
function Person(name, age, address) {
    Object.assign(this, {name, age, address});
}
```
#### 给对象添加函数
采用传统的写法为对象添加公共的函数时，会扩展其prototype属性，使用Object.assign()函数也可以简化代码编写方式。
```js
// 传统写法
Person.prototype.getName = function () {
    return this.name;
};
Person.prototype.getAge = function () {
    return this.age;
};
// Object.assign()写法
Object.assign(Person.prototype, {
    getName() {
        return this.name;
    },
    getAge() {
        return this.age;  
    }
});
```
#### 合并对象
即可以将多个对象合并到某个对象中，也可以将多个对象合并为一个新对象并返回，只需要将target设置为空对象{}即可。
```js
// 多个对象合并到一个目标对象中
const merge = (target, ...sources) => Object.assign(target, ...sources);
// 多个对象合并为一个新对象并返回
const merge = (...sources) => Object.assign({}, ...sources);
```
## Symbol类型
在传统的JavaScript中，对象的属性名都是由字符串构成的。这样就会带来一个问题，假如一个对象继承了另一个对象的属性，又需要定义新的属性时，很容易造成属性名的冲突。

为了解决这个问题，ES6引入了一种新的基本数据类型Symbol，**它表示的是一个独一无二的值**。

至此JavaScript中就一共存在6种基本数据类型，分别是Undefined类型、Null类型、Boolean类型、String类型、Number类型、**Symbol类型**。
### Symbol类型的特性
#### 值的唯一性
类似于一种唯一标识性的ID，通过Symbol()函数来创建一个Symbol值。
```js
let s = Symbol();
// Symbol类型是一个新增的基本数据类型
console.log(typeof s); // symbol
```
在Symbol()函数中可以传递一个字符串参数，表示对Symbol值的描述，主要是方便对不同Symbol值的区分。
但是需要注意的是，由于Symbol值的唯一性，**任何通过Symbol()函数创建的Symbol值都是不相同的，即使传递了相同的字符串**。
```js
const a = Symbol();
const b = Symbol();
const c = Symbol('one');
const d = Symbol('one');
console.log(a === b);  // false
console.log(c === d);  // false
```
#### 不能使用new操作符
Symbol函数并不是一个构造函数，因此不能通过new操作符创建Symbol值。
```js
let s1 = new Symbol(); // TypeError: Symbol is not a constructor
```
#### 不能参与类型运算
Symbol值可以通过toString()函数显示地转换为字符串，但是本身不能参与其他类型值的运算，例如在对Symbol值进行字符串拼接操作时，会抛出异常。
```js
let s4 = Symbol('hello');
s4.toString(); // Symbol(hello)
's4 content is: ' + s4; // TypeError: Cannot convert a Symbol value to a string
```
#### 可以使用同一个Symbol值
通过Symbol()函数创建的每个值都是不同的，那么当我们想要使用同一个Symbol值时，该怎么处理呢？

那就是使用Symbol.for()函数，它接收一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。
```js
let s1 = Symbol.for('one');
let s2 = Symbol.for('one');
s1 === s2; // true
```
在上面的实例中，通过Symbol.for()函数传入相同的字符串会得到相同的Symbol值，因此返回“true”。

Symbol.for()函数与Symbol()函数这两种写法，都会生成新的Symbol值。
它们的区别是：前者会被登记在全局环境中以供搜索，而后者不会。Symbol.for()函数不会每次调用就返回一个新的Symbol类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。
```js
Symbol.for("bar") === Symbol.for("bar"); // true
Symbol("bar") === Symbol("bar");  // false
```
### Symbol类型的用法
#### 用作对象属性名
由于每一个Symbol值都是不相等的，它会经常用作对象的属性名，尤其是当一个对象由多个模块组成时，这样能够避免属性名被覆盖的情况。
在使用Symbol类型的数据时，存在几种不同的写法，遵循的一个原则就是**为对象字面量新增属性时需要使用方括号[]**。
```js
// 新增一个symbol属性
let PROP_NAME = Symbol();

// 第一种写法
let obj = {};
obj[PROP_NAME] = 'Hello';

// 第二种写法
let obj = {
    [PROP_NAME]: 'Hello'
};

// 第三种写法
let obj = {};
Object.defineProperty(obj, PROP_NAME, {
    value: 'Hello' 
});
```
> 需要注意的是，不能通过点运算符为对象添加Symbol属性。
```js
const PROP_NAME = Symbol();
const obj = {};

obj.PROP_NAME = 'Hello!';
console.log(obj[PROP_NAME]);  // undefined
console.log(obj['PROP_NAME']); // 'Hello'
```
在上面的实例中，在通过点运算符为obj增加PROP_NAME属性时，**这个PROP_NAME实际是一个字符串**，并不是一个Symbol变量。因此通过中括号输出PROP_NAME变量对应的值时，得到的是“undefined”；而通过中括号输出'PROP_NAME'字符串值时，得到的是字符串'Hello'。
#### 用于属性区分
一种场景，即通过区分两个属性来做对应的处理。

假如写一个公共的函数用来计算图形的面积，三角形面积为1/2×底×高，长方形面积为底×高。在传统的写法上，会通过switch判断变量是否为字符串'triangle'或者字符串'rectangle'，然后在调用的时候传递对应的字符串。
```js
// 求图形的面积
function getArea(shape, options) {
    let area = 0;
    switch (shape) {
        case 'triangle':
            area = .5 * options.width * options.height;
            break;
        case 'rectangle':
            area = options.width * options.height;
            break;
    }
    return area;
}
console.log(getArea('triangle', { width: 100, height: 100 }));  // 5000
console.log(getArea('rectangle', { width: 100, height: 100 })); // 10000
```
在上面的写法中，字符串'triangle'和'rectangle'会强耦合在代码中。

而事实上，仅想区分各种不同的形状，并不关心每个形状使用什么字符串表示，只需要知道每个变量的值是独一无二的即可，此时使用Symbol就会很合适。
```js
// 事先声明两个Symbol值，用于作判断
let shapeType = {
    triangle: Symbol('triangle'),
    rectangle: Symbol('rectangle')
};
function getArea(shape, options) {
    let area = 0;
    switch (shape) {
        case shapeType.triangle:
            area = .5 * options.width * options.height;
            break;
        case shapeType.rectangle:
            area = options.width * options.height;
            break;
    }
    return area;
}
console.log(getArea(shapeType.triangle, { width: 100, height: 100 }));  // 5000
console.log(getArea(shapeType.rectangle, { width: 100, height: 100 })); // 10000
```
#### 用于属性名遍历
使用Symbol作为属性名时，不能通过Object.keys()函数或者for...in来枚举，这样可以将一些不需要对外操作和访问的属性通过Symbol来定义。
```js
let obj = {
    [Symbol('name')]: 'Hello',
    age: 18,
    title: 'Engineer'
};
console.log(Object.keys(obj)); // ['age', 'title']
for (let p in obj) {
    console.log(p); // 分别会输出：'age' 和 'title'
}
console.log(Object.getOwnPropertyNames(obj)); // ['age', 'title']
```
因为Symbol属性不会出现在属性遍历的过程中，所以在使用JSON.stringify()函数将对象转换为JSON字符串时，Symbol值也不会出现在结果中
```js
JSON.stringify(obj);  // { "age": 18,"title": "Engineer" }
```
当我们需要获取Symbol属性时，可以使用专门针对Symbol的API。
```js
// 使用Object的API
Object.getOwnPropertySymbols(obj); // [Symbol(name)]
// 使用新增的反射API
Reflect.ownKeys(obj); // [Symbol(name), 'age', 'title']
```
## Set和Map数据结构
### Set数据结构
表示的是一组数据的集合，类似于数组，但是Set的成员值都是唯一的，没有重复。
Set本身是一个构造函数，可以接收一个数组或者类数组对象作为参数
1. 属性
- Set.prototype.constructor：构造函数，默认就是Set函数。
- Set.prototype.size：返回实例的成员总数。

2. 函数
- Set.prototype.add(value)：添加一个值，返回Set结构本身。
- Set.prototype.delete(value)：删除某个值，返回布尔值。
- Set.prototype.has(value)：返回布尔值，表示是否是成员。
- Set.prototype.clear()：清除所有成员，无返回值。
向Set实例中添加新的值时，不会发生类型转换。
可以理解为使用add()函数添加新值时，新值与Set实例中原有值是采用严格相等（===）进行比较的，只有在严格相等的比较结果为不相等时，才会将新值添加到Set实例中。
```js
let set = new Set();
set.add(1);
set.add("1");
console.log(set); // Set { 1, '1' }
```
上述规则对于NaN是一个特例，NaN与NaN在进行严格相等的比较时是不相等的，但是**在Set内部NaN与NaN是严格相等的**，因此一个Set实例中只可以添加一个NaN。
```js
let set = new Set();
set.add(NaN);
set.add(NaN);
console.log(set); // Set { NaN }
```
#### Set的常见用法
##### 单一数组的去重
由于Set成员值具有唯一性，因此可以使用Set来进行数组的去重。
```js
let arr = [1, 3, 4, 2, 3, 2, 5];
console.log(new Set(arr)); // Set { 1, 3, 4, 2, 5 }
```
##### 多个数组的合并去重
先使用扩展运算符将多个数组处理成一个数组，然后将合并后得到的数组传递给Set构造函数。
```js
let arr1 = [1, 2, 3, 4];
let arr2 = [2, 3, 4, 5, 6];
let set1 = new Set([...arr1, ...arr2]);
console.log(set1); // Set { 1, 2, 3, 4, 5, 6 }
```
##### Set与数组的转换
将数组转换为Set时，只需要通过Set的构造函数即可；
将Set转换为数组时，通过Array.from()函数或者扩展运算符即可。
```js
let arr = [1, 3, 5, 7];
// 将数组转换为Set
let set = new Set(arr);
console.log(set);  // Set { 1, 3, 5, 7 }

let set = new Set();
set.add('a');
set.add('b');
// 将Set转换为数组，通过Array.from()函数
let arr = Array.from(set);
console.log(arr);  // [ 'a', 'b' ]
// 将Set转换为数组，通过扩展运算符
let arr2 = [...set];
console.log(arr2);  // [ 'a', 'b' ] 
```
#### Set的遍历
使用传统的forEach()函数进行遍历，但在Set中没有索引的概念，它实际是键和值相同的集合，第二个参数表示的是键，实际与第一个参数相同，也返回数据值本身。
```js
let set5 = new Set([4, 5, 'hello']);

set5.forEach((item, index) => {
    console.log(item, index);
});
// 4 4
// 5 5
// hello hello
```
还可以使用以下3种函数：
- keys()：返回键名的遍历器。
- values()：返回键值的遍历器。
- entries()：返回键值对的遍历器。
通过上述函数获得的对象都是**遍历器对象Iterator**，然后通过for...of循环可以获取每一项的值。
```js
let set = new Set(['red', 'green', 'blue']);

for (let item of set.keys()) {
    console.log(item);
}
// red
// green
// blue

for (let item of set.values()) {
    console.log(item);
}
// red
// green
// blue

for (let item of set.entries()) {
    console.log(item);
}
// ["red", "red"]
// ["green", "green"]
// ["blue", "blue"]
```
因为Set实例的键和值是相等的，所以keys()函数和values()函数实际返回的是相同的值。
### Map数据结构
它的本质是一种键值对的组合。但是与对象字面量不同的是，**对象字面量的键只能是字符串**，对于非字符串类型的值会采用强制类型转换成字符串，而**Map的键却可以由各种类型的值组成**。
```js
// 传统的对象类型（对象字面量）
const data = {};
const element = document.getElementById('home');
data[element] = 'first';
console.log(data); // {[object HTMLDivElement]: "first"}
```
在上面的实例中，采用的是传统的对象处理方案，将一个DOM元素作为对象的属性名，在输出时DOM元素的值会被转换成字符串。
```js
// Map
const map = new Map();
const element = document.getElementById('home');
map.set(element, 'fist');
console.log(map);  // {div#home => "fist"}
```
在上面的实例中，采用的是Map处理方案，将DOM元素作为键添加到实例map中，在输出时会发现，键的值为DOM元素的真实值，并没有转换为字符串的值。

Map本身是一个构造函数，可以接收一个数组作为参数，数组的每个元素同样是一个子数组，子数组元素表示的是键和值。
```js
const map = new Map([
    ['name', 'ming'],
    ['age', 123]
]);
console.log(map); // Map { 'name' => 'ming', 'age' => 123 }
```
Map结构有一系列的实例属性和函数，总结如下。
- size属性：返回Map结构的成员总数。
- set(key, value)：set()函数设置键名key对应的键值为value，set()函数返回的是当前Map对象，因此set()函数可以采用链式调用的写法。
- get(key)：get()函数读取key对应的键值，如果找不到key，返回“undefined”。
- has(key)：has()函数返回一个布尔值，表示某个键是否在当前Map对象中。
- delete(key)：delete()函数删除某个键，返回“true”；如果删除失败，返回“false”。
- clear()：clear()函数清除所有成员，没有返回值。
在Map数据结构中，所有的键都必须具有唯一性。对同一个键进行多次赋值，那么后面的值会覆盖前面的值。
```js
const map = new Map();
map.set(1, 'aaa')
   .set(1, 'bbb');
map.get(1); // "bbb"
```
如果Map实例的键是原生数据类型，则采用严格相等(===)判断是否为同一个键。
对于Number类型数据，+0和-0严格相等，虽然NaN与NaN不严格相等，但是Map会将其视为一个相同的键。
```js
let map = new Map();
map.set(-0, 123);
map.get(+0); // 123

map.set(NaN, 123);
map.set(NaN, 234);
map.get(NaN); // 234
```
字符串'true'与Boolean类型true不严格相等，是两个不同的键。
```js
let map = new Map();

map.set(true, 1);
map.set('true', 2);
map.get(true); // 1
```
对于Undefined类型和Null类型，undefined与null也是两个不同的键。
```js
let map = new Map();
map.set(undefined, 3);
map.set(null, 4);
map.get(undefined); // 3
map.get(null); // 4
```
如果Map实例的键是引用数据类型，则需要判断对象是否为同一个引用、是否占据同一个内存地址。
```js
const map = new Map();
map.set([0], '0');
map.set([0], '1');

console.log(map); // Map { [ 0 ] => '0', [ 0 ] => '1' }
```
在上面的实例中，将数组[0]作为map的键，但是[0]作为引用类型数据，**每次生成一个新的值都会占据新的内存地址**，实际为不同的键，因此map在输出时会有两个元素值。
如果希望元素[0]只占据同一个键，则可以将其赋给一个变量值，通过变量值添加到map中。
```js
let arr = [0];
const map = new Map();
map.set(arr, '0');
map.set(arr, '1');

console.log(map); // Map { [ 0 ] => '1' }
```
在上面的实例中，arr对应的值[0]被两次添加至map中，但是实际指向的是同一个引用，在内存中占据同一个地址，因此后面的值会覆盖前一个值，最后输出的map中只有一个值。

#### 遍历
与Set一样，Map的遍历同样可以采用4种函数，分别是forEach()函数、keys()函数、values()函数、entries()函数。
对于forEach()函数，第一个参数表示的是值，第二个参数表示的是键。
```js
const map = new Map();
map.set('name', 'ming');
map.set('age', 12);

map.forEach(function (item, key) {
    console.log(item, key); 
});
// ming name
// 12 age
```
keys()函数返回的是键的集合，values()函数返回的是值的集合，entries()函数返回的键值对的集合。

这些集合都是Iterator的实例，可以通过for...of进行遍历。
```js
for (let key of map.keys()) {
    console.log(key);
}
// name
// age

for (let value of map.values()) {
    console.log(value);
}
// ming
// 12

for (let obj of map.entries()) {
    console.log(obj);
}
// [ 'name', 'ming' ]
// [ 'age', 12 ]
```
#### 与其他数据结构的转换
```js
//Map转换为数组
const map = new Map();
map.set('name', 'ming');
map.set('age', 12);

const arr = [...map];
console.log(arr); // [ [ 'name', 'ming' ], [ 'age', 12 ] ]
```
数组转换为Map，可以通过Map构造函数实现，使用new操作符生成Map的实例。
```js
// 数组转换为Map
const arr = [[ 'name', 'ming' ], [ 'age', 12 ]];
const map = new Map(arr);
console.log(map);  // Map { 'name' => 'ming', 'age' => 12 }
```
Map转换为对象，如果Map的实例的键是字符串，则可以直接转换；如果键不是字符串，则会先转换成字符串然后再进行转换。
```js
// Map转换为对象
function mapToObj(map) {
    let obj = {};
    for(let [key, value] of map) {
        obj[key] = value;
    }
    return obj;
}
console.log(mapToObj(map));  // { name: 'ming', age: 12 }
```
对象转换为Map，只需要遍历对象的属性并通过set()函数添加到Map的实例中即可。
```js
// 对象转换为Map
function objToMap(obj) {
    let map = new Map();
    for (let k of Object.keys(obj)) {
        map.set(k, obj[k]);
    }
    return map;
}
console.log(objToMap({yes: true, no: false}));
// Map {"yes" => true, "no" => false}
```
Map转换为JSON字符串时，有两种情况，第一种是当Map的键名都是字符串时，可以先将Map转换为对象，然后调用JSON.stringify()函数。
```js
// Map转换为JSON，通过对象
function mapToJson(strMap) {
    // 先将map转换为对象，然后转换为JSON
    return JSON.stringify(mapToObj(strMap));
}
let myMap = new Map().set('yes', true).set('no', false);
console.log(mapToJson(myMap)); // {"yes":true,"no":false}
```
第二种是当Map的键名有非字符串时，我们可以先将Map转换为数组，然后调用JSON.stringify()函数。
```js
// Map转换为JSON,通过数组
function mapToArrayJson(map) {
    // 先通过扩展运算符转换为数组，再转换为JSON
    return JSON.stringify([...map]);
}
let myMap2 = new Map().set(true, 7).set({foo: 3}, ['abc']);
mapToArrayJson(myMap2); // [[true,7],[{"foo":3},["abc"]]] 
```
JSON转换为Map。JSON字符串是由一系列键值对构成，键一般都为字符串。我们可以直接通过调用JSON.parse()函数先将JSON字符串转换为对象，然后再转换为Map。
```js
// JSON转换为Map
function jsonToMap(jsonStr) {
    // 先转换为JSON对象，再转换为Map
    return objToMap(JSON.parse(jsonStr));
}
jsonToMap('{"yes": true, "no": false}'); // Map { 'yes' => true, 'no' => false }
```
Set转换为Map，Set中以数组形式存在的数据可以直接通过Map的构造函数转换为Map。
```js
// Set转换为Map
function setToMap(set) {
    return new Map(set);
}
const set = new Set([
    ['foo', 1],
    ['bar', 2]
]);
console.log(setToMap(set)); // Map { 'foo' => 1, 'bar' => 2 }
```
Map转换为Set，可以将遍历Map本身获取到的键和值构成一个数组，然后通过add()函数添加至set实例中。
```js
// Map实例转换为Set
function mapToSet(map) {
    let set = new Set();
    for (let [k,v] of map) {
        set.add([k, v])
    }
    return set;
}
const map14 = new Map()
    .set('yes', true)
    .set('no', false);
mapToSet(map14); // Set { [ 'yes', true ], [ 'no', false ] }
```
## Proxy
### 概述
ES6中新增了Proxy对象，从字面上看可以理解为代理器，主要用于改变对象的默认访问行为，实际表现是在访问对象之前增加一层拦截，任何对对象的访问行为都会通过这层拦截。
在拦截中，可以增加自定义的行为。

Proxy的基本语法如下所示。
```js
const proxy = new Proxy(target, handler);
```
一个构造函数：接收两个参数，一个是目标对象target；另一个是配置对象handler，用来定义拦截的行为。

proxy、target和handler之间的关系是什么样的呢？

通过Proxy构造函数可以生成实例proxy，**任何对proxy实例的属性的访问都会自动转发至target对象上，可以针对访问的行为配置自定义的handler对象，因此外界通过proxy访问target对象的属性时，都会执行handler对象自定义的拦截操作**。
```js
// 定义目标对象
const person = {
    name: 'ming',
    age: 23
};
// 定义配置对象
let handler = {
    get: function (target, prop, receiver) {
        console.log("你访问了person的属性");
        return target[prop];
    }
};
// 生成Proxy的实例
const p = new Proxy(person, handler);
// 执行结果
console.log(p.name);
// 你访问了person的属性
// ming
```
在上面的实例中，定义了一个包含get()函数的配置对象，表示的是对代理对象的属性进行读取操作时，就会触发get()函数。
因此在执行p.name，即调用Proxy实例的name属性时，会触发get()函数，在控制台输出“你访问了person的属性”，然后返回实际的name属性值。

在使用Proxy时，有几点需要注意的内容。
1. 必须通过代理实例访问
如果需要配置对象的拦截行为生效，那么必须是对代理实例的属性进行访问，而不是直接对目标对象进行访问。
在上面的实例中，如果直接通过目标对象person访问name属性，则不会触发拦截行为。
```js
console.log(person.name); // ming
```
2. 配置对象不能为空对象
如果需要配置对象的拦截行为生效，那么配置对象不能为空对象。如果为空对象，则代表没有设置任何拦截，实际是对目标对象的访问。另外配置对象不能为null，否则会抛出异常。
```js
const p2 = new Proxy(person, {});
console.log(p2.name); // ming
```
在上面的代码中，为person生成了一个Proxy的实例，但是其配置对象为一个空对象{}，表示没有设置任何拦截，相当于直接对目标对象进行访问。
### Proxy实例函数及其基本使用
13种函数汇总如下：
1. get(target, propKey, receiver)。
拦截对象属性的读取操作，例如调用`proxy.name`或者`proxy[name]`，其中target表示的是目标对象，propKey表示的是读取的属性值，receiver表示的是配置对象。
2. set(target, propKey, value, receiver)。
拦截对象属性的写操作，即设置属性值，例如`proxy.name='ming'`或者`proxy[name]='ming'`，其中target表示目标对象，propKey表示的是将要设置的属性，value表示将要设置的属性的值，receiver表示的是配置对象。
3. has(target, propKey)。
拦截hasProperty的操作，返回一个布尔值，最典型的表现形式是执行propKey in target，其中target表示目标对象，propKey表示判断的属性。
4. deleteProperty(target, propKey)。
拦截`delete proxy[propKey]`的操作，返回一个布尔值，表示是否执行成功，其中target表示目标对象，propKey表示将要删除的属性。
5. ownKeys(target)。
拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循等操作，其中target表示的是获取对象自身所有的属性名。
6. getOwnPropertyDescriptor(target, propKey)。
拦截Object.getOwnPropertyDescriptor(proxy, propKey)操作，返回属性的属性描述符构成的对象，其中target表示目标对象，propKey表示需要获取属性描述符集合的属性。
7. defineProperty(target, propKey, propDesc)。
拦截Object.defineProperty(proxy, propKey, propDesc)、Object.defineProperties(proxy,propDescs)操作，返回一个布尔值，其中target表示目标对象，propKey表示新增的属性，propDesc表示的是属性描述符对象。
8. preventExtensions(target)。
拦截Object.preventExtensions(proxy)操作，返回一个布尔值，表示的是让一个对象变得不可扩展，不能再增加新的属性，其中target表示目标对象。
9. getPrototypeOf(target)。
拦截Object.getPrototypeOf(proxy)操作，返回一个对象，表示的是拦截获取对象原型属性，其中target表示目标对象。
10. isExtensible(target)。
拦截Object.isExtensible(proxy)，返回一个布尔值，表示对象是否是可扩展的，其中target表示目标对象。
11. setPrototypeOf(target, proto)。
拦截Object.setPrototypeOf(proxy, proto)操作，返回一个布尔值，表示的是拦截设置对象的原型属性的行为，其中target表示目标对象，proto表示新的原型对象。
12. apply(target, object, args)。
拦截Proxy实例作为函数调用的操作，例如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)，其中target表示目标对象，object表示函数的调用方，args表示函数调用传递的参数。
13. construct(target, args)。
拦截Proxy实例作为构造函数调用的操作，例如new proxy(...args)，其中target表示目标对象，args表示函数调用传递的参数。

> 这些函数都有一个通用的特性，即如果在target中使用了this关键字，再通过Proxy处理后，this关键字指向的是Proxy的实例，而不是目标对象target。
```js
const person = {
    getName: function () {
        console.log(this === proxy);
    }
};
const proxy = new Proxy(person, {});

proxy.getName();  // true
person.getName(); // false
```

应用场景。
#### 读取不存在属性
在正常情况下，读取一个对象不存在的属性时，会返回“undefined”。通过Proxy的get()函数可以设置读取不存在的属性时抛出异常，从而避免对undefined值的兼容性处理。
```js
let person = {
    name: 'ming'
};
const proxy = new Proxy(person, {
    get: function (target, propKey) {
        if(propKey in target) {
            return target[propKey];
        } else {
            throw new ReferenceError(`访问的属性${propKey}不存在`);
        }
    }
});
console.log(proxy.name); // ming
console.log(proxy.age); // ReferenceError: 访问的属性age不存在
```
#### 读取负索引的值
数组的索引值是从0开始依次递增的，正常情况下我们无法读取负索引的值，但是通过Proxy的get()函数可以做到这一点。
负索引实际就是从数组的尾部元素开始，从后往前，寻找元素的位置。
```js
const arr = [1, 4, 9, 16, 25];
const proxy = new Proxy(arr, {
    get: function (target, index) {
        index = Number(index);
        if (index > 0) {
            return target[index];
        } else {
            // 索引为负值，则从尾部元素开始计算索引
            return target[target.length + index];
        }
    }
});
console.log(proxy[2]);  // 9
console.log(proxy[-2]); // 16
```
#### 禁止访问私有属性
在一些约定俗成的写法中，**私有属性都会以下画线（_）开头**，事实上并不希望用户能访问到私有属性，这可以通过设置Proxy的get()函数来实现。
```js
const person = {
    name: 'ming',
    _pwd: '123456'
};
const proxy = new Proxy(person, {
    get: function (target, prop) {
        if (prop.indexOf('_') === 0) {
            throw new ReferenceError('不可直接访问私有属性');
        } else {
            return target[prop];
        }
    }
});
console.log(proxy.name); // ming
console.log(proxy._pwd); // ReferenceError: 不可直接访问私有属性
```
#### Proxy访问属性的限制
当期望使用Proxy对对象的属性进行代理，并修改属性的返回值时，需要这个属性不能同时为不可配置和不可写。如果这个属性同时为不可配置和不可写，那么在通过代理读取属性时，会抛出异常。
```js
const target = Object.defineProperties({}, {
  name: {
    value: 'ming',
        // 可配置的name属性
        configurable: true,
        writable: false
    },
    age: {
      value: 12,
        // 不可配置的age属性
        configurable: false,
        writable: false
    }
});
const proxy = new Proxy(target, {
    get: function (targetObj, prop) {
        return 'abc';
    }
});
console.log(proxy.name); // abc
console.log(proxy.age);  // TypeError: expected '12' but got 'abc')
```
因为name属性是不可写但可配置的，所以可以通过代理改变其真实值，从而得到“abc”；
而age属性是不可写且不可配置的，所以在访问时就会直接抛出异常，异常信息栈的内容如下所示。
```js
TypeError: 'get' on proxy: property 'age' is a read-only and non-configurable
data property on the proxy target but the proxy did not return its actual 
value (expected '12' but got 'abc')
```
从异常信息栈可以看出，不可写且不可配置的属性只能返回其实际值。
#### 拦截属性赋值操作
> set()函数会拦截属性的赋值操作。

例如这样一个场景：事先确定好了某个属性的取值区间，但是在对属性赋值时却不在这个区间内，则可以直接抛出异常。
定义一个person对象，包含一个age属性，取值区间为0～200，只要设置的值不在这个区间内，就会抛出异常。
```js
const proxy = new Proxy({}, {
    set: function (target, prop, value) {
        if (prop === 'age') {
            if (!Number.isInteger(value)) {
                throw new TypeError('The age is not an integer');
            }
            if (value > 200 || value < 0) {
                throw new RangeError('The age is invalid');
            }
        } else {
            target[prop] = value;
        }
    }
});
proxy.name = 'ming';  // 正常
proxy.age = 10;  // 正常
proxy.age = 201; // RangeError: The age is invalid
```
##### 练习
那么如何实现私有属性不能被修改呢?

#### 隐藏内部私有属性
Proxy提供了has()函数，用于拦截hasProperty()函数，即判断对象是否具有某个属性，如果具有则返回“true”，如果不具有则返回“false”，典型的就是in操作符。
需要注意的是has()函数判断的是hasProperty()函数，而不是hasOwnProperty()函数，即**has()函数不判断一个属性是对象自身的属性，还是对象继承的属性。**
has()函数有一个最大的用处就是隐藏某些以下画线开头（_）的私有属性，不对外暴露它们，从而通过in循环时不会遍历出私有属性值。
```js
const obj = {
    _name: 'ming',
    age: 13
};
const proxy = new Proxy(obj, {
    has: function (target, prop) {
        if(prop[0] === '_') {
           return false;
        }
        return prop in target;
    }
});
console.log('age' in proxy);   // true
console.log('_name' in proxy); // false
```
> has()函数只会对in操作符生效，而不会对for...in循环操作符生效。
```js
for (let key in proxy) {
  console.log(proxy[key]);
}
// ming
// 13
```
#### 禁止删除某些属性
Proxy中提供了deleteProperty()函数，用于拦截delete操作，返回“true”时表示属性删除成功，返回“false”时表示属性删除失败。
利用这个特性，可以做特殊处理，不能删除以下画线开头的私有属性。当删除了私有属性时，会抛出异常，终止操作。
```js
let obj = {
    _name: 'ming',
    age: 12
};
const proxy = new Proxy(obj, {
    deleteProperty: function (target, prop) {
        if (prop[0] === '_') {
            throw new Error(`Invalid attempt to delete private "${prop}" property`);
        }
        return true;
    }
});
delete proxy.age;  // 删除成功
delete proxy._name; // Error: Invalid attempt to delete private "_name" property
```
#### 函数的拦截
Proxy中提供了apply()函数，用于拦截函数调用的操作，函数调用包括直接调用、call()函数调用、apply()函数调用3种方式。
通过对函数调用的拦截，可以加入自定义操作，从而得到新的函数处理结果。
```js
function sum(num1, num2) {
    return num1 + num2;
}
const proxy = new Proxy(sum, {
    apply: function (target, obj, args) {
        return target.apply(obj, args) * 2;
    }
});
console.log(proxy(1, 3));  // 8
console.log(proxy.call(null, 3, 4));  // 14
console.log(proxy.apply(null, [5, 6]));  // 22
```
在上面的实例中，定义了一个用于求和的sum()函数，然后通过Proxy的apply()函数对sum()函数的结果再乘以2。
- 第一种函数执行形式是直接通过proxy进行调用，执行过程为(1+ 3)×2 = 8。
- 第二种函数执行形式是通过call()函数调用，执行过程为(3 +4)×2 = 14。
- 第三种函数执行形式是通过apply()函数调用，执行过程为(5 +6)×2 = 22。
### Proxy的使用场景
#### 实现真正的私有
JavaScript中虽然没有私有属性的语法，但存在一种约定俗成的下画线写法，可以通过Proxy处理下画线写法来实现真正的私有。
真正的私有所要达到的目标有以下几个：
- 不能访问到私有属性，如果访问到私有属性则返回“undefined”。
- 不能直接修改私有属性的值，即使设置了也无效。
- 不能遍历出私有属性，遍历出来的属性中不会包含私有属性。
```js
const apis = {
    _apiKey: '12ab34cd56ef',
    getAllUsers: function () {
        console.log('这是查询全部用户的函数');
    },
    getUserById: function (userId) {
        console.log('这是根据用户id查询用户的函数');
    },
    saveUser: function (user) {
        console.log('这是保存用户的函数');
    }
};
const proxy = new Proxy(apis, {
    get: function (target, prop) {
        if (prop[0] === '_') {
            return undefined;
        }
        return target[prop];
    },
    set: function (target, prop, value) {
        if (prop[0] !== '_') {
            target[prop] = value;
        }
    },
    has: function (target, prop) {
        if (prop[0] === '_') {
            return false;
        }
        return prop in target;
    }
});
console.log(proxy._apiKey); // undefined
console.log(proxy.getAllUsers()); // 这是查询全部用户的函数
proxy._apiKey = '123456789'; // 设置无效
console.log('getUserById' in proxy);  // true
console.log('_apiKey' in proxy); // false
```
#### 增加日志记录
在日常的开发中，针对那些调用频繁、运行缓慢或者占用资源密集型的接口，期望能记录它们的使用情况，这个时候我们可以通过Proxy作为中间件增加日志记录。
为了达到上面的目的，我们需要使用Proxy进行拦截，首先通过get()函数拦截到调用的函数名，然后通过apply()函数进行函数的调用。
因此在实现上，get()函数会返回一个函数，在这个函数内通过apply()函数调用原始函数，然后调用记录操作日志的函数。
```js
const apis = {
    _apiKey: '12ab34cd56ef',
    getAllUsers: function () {
        console.log('这是查询全部用户的函数');
    },
    getUserById: function (userId) {
        console.log('这是根据用户id查询用户的函数');
    },
    saveUser: function (user) {
        console.log('这是保存用户的函数');
    }
};
// 记录日志的方法
function recordLog() {
    console.log('这是记录日志的函数');
}
const proxy = new Proxy(apis, {
    get: function (target, prop) {
        const value = target[prop];
        return function (...args) {
            // 此处调用记录日志的函数
            recordLog();
            // 调用真实的函数
            return value.apply(null, args);
        }
    }
});
proxy.getAllUsers();
// 这是记录日志的函数
// 这是查询全部用户的函数
```
这样就可以在不影响原应用正常运行的情况下增加日志记录。如果只想要对特定的某些函数增加日志，那么可以在get()函数中进行特殊的处理，对函数名进行判断。
#### 提供友好提示或者阻止特定操作
通过Proxy，可以增加某些操作的友好提示或者阻止特定的操作，主要包括以下几类。
- 某些被弃用的函数被调用时，给用户提供友好提示。
- 阻止删除属性的操作。
- 阻止修改某些特定的属性的操作。
```js
// 定义了一个数据源对象dataStore，其中包含了不能删除的属性noDelete、已废弃的函数oldMethod()、不能改变的属性doNotChange。
let dataStore = {
    noDelete: 1234,
    oldMethod: function () {/*...*/},
    doNotChange: "tried and true"
};
let NO_DELETE = ['noDelete'];
let DEPRECATED = ['oldMethod'];
let NO_CHANGE = ['doNotChange'];
const proxy = new Proxy(dataStore, {
    set(target, key, value, proxy) {
        if (NO_CHANGE.includes(key)) {
            throw Error(`Error! ${key} is immutable.`);
        }
        return true;
    },
    deleteProperty(target, key) {
        if (NO_DELETE.includes(key)) {
            throw Error(`Error! ${key} cannot be deleted.`);
        }
        return true;
    },
    get(target, key, proxy) {
        if (DEPRECATED.includes(key)) {
            console.warn(`Warning! ${key} is deprecated.`);
        }
        const val = target[key];
        return typeof val === 'function' ?
            function (...args) {
                val.apply(null, args);
            } : val;
    }
});
proxy.doNotChange = "foo"; // Error! doNotChange is immutable.
delete proxy.noDelete; // Error! noDelete cannot be deleted.
proxy.oldMethod(); // Warning! oldMethod is deprecated.
```
## Reflect
### 概述
Reflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。
理解：有一个名为Reflect的全局对象，上面挂载了对象的某些特殊函数，这些函数可以通过类似于Reflect.apply()这种形式来调用，所有在Reflect对象上的函数要么可以在Object原型链中找到，要么可以通过命令式操作符实现，例如delete和in操作符。

既然在ES6之前，Object对象中已经有与Reflect的函数相同功能的函数或者命令式操作符，那么为什么还要在ES6中专门增加一个Reflect对象呢？

主要原因有以下几点：
- 更合理地规划与Object对象相关的API。
  - 在ES6中，Object对象的一些明显属于语言内部的函数都会添加到Reflect对象中，这样Object对象与Reflect对象中会存在相同的处理函数。而在未来的设计中，语言内部的函数将只会添加到Reflect对象中。
- 用一个单一的全局对象去存储这些函数，能够保持其他的JavaScript代码的整洁、干净。不然的话，这些函数可能是全局的，或者要通过原型来调用，不方便统一管理。
- 将一些命令式的操作符如delete、in等使用函数来替代，这样做的目的是为了让代码更好维护，更容易向下兼容，同时也避免出现更多的保留字。
```js
// 传统写法
'assign' in Object // true

// 新写法
Reflect.has(Object, 'assign') // true
```
修改Object对象的某些函数的返回结果，可以让其变得更合理，使得代码更好维护。

如果一个对象obj是不能扩展的，那么在调用`Object.defineProperty(obj, name, desc)`时，会抛出一个异常。因此在传统的写法中，需要通过try...catch处理。

而使用Reflect.defineProperty(obj, name, desc)时，返回的是“false”，新的写法就可以通过if...else实现。
```js
// 传统写法
try {
    Object.defineProperty(target, property, attributes);
    // success
} catch (e) {
    // failure
}

// 新写法
if (Reflect.defineProperty(target, property, attributes)) {
    // success
} else {
    // failure
}
```
Reflect对象的函数与Proxy对象的函数一一对应，**只要是Proxy对象的函数，就能在Reflect对象上找到对应的函数**。这就让Proxy对象可以方便地调用对应的Reflect对象上的函数，完成默认行为，并以此作为修改行为的基础。

也就是说，不管Proxy对象怎么修改默认行为，总可以在Reflect对象上获取默认行为。而事实上Proxy对象也会经常随着Reflect对象一起进行调用。
```js
new Proxy(target, {
  set: function(target, name, value, receiver) {
    var success = Reflect.set(target,name, value, receiver);
    if (success) {
      console.log('property ' + name + ' on ' + target + ' set to ' + value);
    }
    return success;
  }
});
```
### 静态函数
与Proxy对象不同的是，Reflect对象本身并不是一个构造函数，而是直接提供静态函数以供调用，Reflect对象的静态函数一共有13个，如下所示。

- Reflect.apply(target, thisArg, args)。
  - 函数的作用是通过指定的参数列表执行target函数，等同于执行`Function.prototype.apply.call(target,thisArg, args)`。
  - 其中target表示的是目标函数，thisArg表示的是执行target函数时的this对象，args表示的是参数列表。

- Reflect.construct(target, args [, newTarget])。
  - 函数的作用是执行构造函数，等同于执行`new target(...args)`。
  - 其中target表示的是构造函数，args表示的是参数列表。newTarget是选填的参数，如果增加了该参数，则表示将newTarget作为新的构造函数；如果没有增加该参数，则仍然使用第一个参数target作为构造函数。

- Reflect.defineProperty(target, propKey, attributes)。
  - 函数的作用是为对象定义属性，等同于执行`Object.defineProperty()`。
  - 其中target表示的是定义属性的目标对象，propKey表示的是新增的属性名，attributes表示的是属性描述符对象集。

- Reflect.deleteProperty(target, propKey)。
  - 函数的作用是删除对象的属性，等同于执行`delete obj[propKey]`。
  - 其中target表示的是待删除属性的对象，propKey表示的是待删除的属性。

- Reflect.get(target, propKey, receiver)。
  - 函数的作用是获取对象的属性值，等同于执行`target[propKey]`。
  - 其中target表示的是获取属性的对象，propKey表示的是获取的属性，receiver表示函数中this绑定的对象。

- Reflect.getOwnPropertyDescriptor(target, propKey)。
  - 函数的作用是得到指定属性的描述对象，等同于执行`Object.getOwnPropertyDescriptor()`。
  - 其中target表示的是待操作的对象，propKey表示的是指定的属性。

- Reflect.getPrototypeOf(target)。
  - 函数的作用是读取对象的__proto__属性，等同于执行`Object.getPrototypeOf(obj)`。
  - 其中target表示的是目标对象。

- Reflect.has(target, propKey)。
  - 函数的作用是判断属性是否在对象中，等同于执行`propKey in target`。
  - 其中target表示的是目标对象，propKey表示的是判断的属性。

- Reflect.isExtensible(target)。
  - 函数的作用是判断对象是否可扩展，等同于执行`Object.isExtensible()`函数。
  - 其中target表示的是目标对象。

- Reflect.ownKeys(target)。
  - 函数的作用是获取对象的所有属性，包括Symbol属性，等同于`Object.getOwnPropertyNames`与`Object.getOwnPropertySymbols`之和。
  - 其中target表示的是目标对象。

- Reflect.preventExtensions(target)。
  - 函数的作用是让一个对象变得不可扩展，等同于执行`Object.preventExtensions()`。
  - 其中target表示的是目标对象。

- Reflect.set(target, propKey, value, receiver)。
  - 函数的作用是设置某个属性值，等同于执行`target[propKey] = value`。
  - 其中target表示的是目标对象，propKey表示的是待设置的属性，value表示的是设置属性的具体值，receiver表示函数中this绑定的对象。

- Reflect.setPrototypeOf(target, newProto)。
  - 函数的作用是设置对象的原型prototype，等同于执行`Object.setPrototypeOf(target,newProto)`。
  - 其中target表示的是目标对象，newProto表示的是新的原型对象。

#### Reflect.apply(target, thisArg, args)
两个应用场景：
1. 一个是找出数组里的最大元素。
2. 一个是截取字符串中的一部分值。
这两个场景分别使用传统的apply()函数和Reflect.apply()函数来实现。
```js
// 查找一个数字数组里面的最大元素
const arr = [1, 3, 5, 7];
let max;
// ES6
max = Reflect.apply(Math.max, null, arr);
console.log(max); // 7

// ES5
max = Math.max.apply(null, arr);
console.log(max); // 7
max = Function.prototype.apply.call(Math.max, null, arr);
console.log(max); // 7
```

```js
// 截取字符串的一部分
let str = 'hello, world';
let newStr;
// ES6
newStr = Reflect.apply(String.prototype.slice, str, [2, 8]);
console.log(newStr); // llo，w
// ES5
newStr = str.slice(2, 8);
console.log(newStr); // llo，w
newStr = String.prototype.slice.apply(str, [2, 8]);
console.log(newStr); // llo，w
```
#### Reflect.defineProperty(target, propKey, attributes)
与Object.defineProperty()函数的主要区别在于返回值，如果**设置失败**，Object.defineProperty()函数会抛出一个异常，而**Reflect.defineProperty()函数会返回“false”**。
```js
1  let obj = {};
2   // ES5写法，对象的属性定义失败时，采用try...catch()函数处理
3  try {
4      Object.defineProperty(null, 'a', {
5          value: 22
6      });
7  } catch (e) {
8      console.log('define property failed!');
9  }
10
11 // 使用Object.defineProperty成功地定义
12 let obj1 = Object.defineProperty(obj, 'name', {
13     enumerable: true,
14     value: 'ming'
15 });
16 console.log(obj); // { name: 'ming' }
17 console.log(obj1); // { name: 'ming' }
18 
19 let result1 = Reflect.defineProperty(obj, 'name', {
20     configurable: true,
21     enumerable: true,
22     value: 'happy'
23 });
24 console.log(result1); // false
25
26 let result2 = Reflect.defineProperty(obj, 'age', {
27     configurable: true,
28     enumerable: true,
29     value: 22
30 });
31 console.log(result2); // true
32 console.log(obj); // { name: 'ming', age: 22 }
```
在上面实例中的第1～9行代码，在采用传统ES5写法时，通过Object.defineProperty()函数为null添加一个属性，是一个失败的操作，会抛出一个异常，所以需要采用try...catch()函数的写法。

在第11～17行代码中，通过Object.defineProperty()函数为obj对象添加一个name属性，得到新的对象obj1，此时obj与obj1指向同一个引用，输出的结果都为“{ name: 'ming' }”。这里需要注意，obj对象的name属性只设置了**enumerable**值为true，那么**writable**和**configurable**值就为false，这表明name属性值是不能被修改的。

在第19～24行代码中，由于name属性值是不能被修改的，通过`Reflect.defineProperty()`函数设置obj对象的name属性值时会失败，因此在输出result1时，结果为“false”。

在第26～32行代码中，age属性是第一次被添加到obj对象中去的，因此`Reflect.defineProperty()`函数调用成功，result2值为“true”，此时obj就扩展成了拥有name和age两个属性值的对象。

#### Reflect.deleteProperty(target, propKey)
delete操作符和Reflect.deleteProperty()函数的使用差异性。
```js
// 新的Reflect写法
let obj = {
    name: 'ming',
    age: 22
};
let r1 = Reflect.deleteProperty(obj, 'name');
console.log(r1); // true
let r2 = Reflect.deleteProperty(obj, 'name');
console.log(r2); // true
let r3 = Reflect.deleteProperty(Object.freeze(obj), 'age');
console.log(r3); // false

// 传统的delete写法
let obj2 = {
    name: 'ming',
    age: 22
};
delete obj2.name;
delete obj2.name;
// 冻结obj2对象
Object.freeze(obj2);
delete obj2.age;
console.log(obj2); // { age: 22 }
```
在使用新的Reflect.deleteProperty()函数删除对象的属性时，只要对象是可扩展的，删除任何属性都会返回为“true”，即使该属性不存在。

在上面的实例中，第一次调用Reflect.deleteProperty()函数删除name属性时，删除成功，r1为“true”，此时obj对象中只包含age属性。

第二次调用Reflect.deleteProperty()函数删除name属性时，虽然name属性已经不存在，仍然可以删除成功，r2为“true”。

第三次调用Reflect.deleteProperty()函数删除age属性时，由于obj对象通过freeze()函数进行冻结，obj将不可扩展，因此删除age属性失败，r3为“false”。

使用传统的delete操作符达到的是相同的目的，即使删除的是不存在的属性，程序也不会抛出异常，所以两次调用delete obj2.name后程序依然正常；而当对象obj2通过freeze()函数冻结后，delete操作将不再生效，因此最后obj2为“{ age: 22 }”。

#### Reflect.set(target, propKey, value, receiver)
Reflect.set()函数在传递与不传递第四个参数receiver上的差异。
```js
let obj = {
    _name: '',
    set name(name) {
        console.log('this:', this);
        this._name = name;
    },
    get name() {
        return this._name;
    },
    age: 22
};

let r1 = Reflect.set(obj, 'age', 24);
let r2 = Reflect.set(obj, 'name', 'ming'); // this: { _name: '', name: [Getter/Setter], age: 24 }
console.log(r1); // true
console.log(obj); // { _name: 'ming', name: [Getter/Setter], age: 24 }

let receiver = { test: 'test' };
let r3 = Reflect.set(obj, 'name', 'ming2', receiver); // this: { test: 'test' }
console.log(r3); // true
console.log(obj); // { _name: 'ming', name: [Getter/Setter], age: 24 }
console.log(receiver); // { test: 'test', _name: 'ming2' }
```
首先定义一个obj对象，具有_name、name和age这3个属性，并在设置name属性值时，输出this的值。

然后第一次调用Reflect.set()函数，修改age属性的值为24，操作成功。

第二次调用Reflect.set()函数，修改name属性的值为'ming'，此时并未传递第四个参数，所以this指向第一个参数obj，执行成功后obj的值为“{ _name: 'ming', name: [Getter/Setter],age: 24 }”。

第三次调用Reflect.set()函数，修改name属性值为'ming2'，此时传递了第四个参数为一个对象receiver，则**this就指向这个新对象receiver**，而不再是obj对象。**因此在设置name时，执行了this._name = name，实际是为receiver对象新增了一个_name属性，值为'ming2'**；在执行完后，obj对象的值依然不变，而receiver对象的值变为“{ test: 'test', _name: 'ming2'}”。

#### Reflect与Proxy👍👍👍
ES6在设计的时候就将Reflect对象和Proxy对象绑定在一起了，Reflect对象的函数与Proxy对象的函数一一对应，因此在Proxy对象中调用Reflect对象对应的函数是一个明智的选择。

例如使用Proxy对象拦截属性的读取、设置和删除操作、并配合Reflect对象实现时，可以编写如下所示的代码。
```js
let target = {
    name: 'ming'
};
const proxy = new Proxy(target, {
    get(target, prop) {
        console.log(`读取属性${prop}的值为${target[prop]}`);
        return Reflect.get(target, prop);
    },
    set(target, prop, value) {
        console.log(`设置属性${prop}的值为${value}`);
        return Reflect.set(target, prop, value);
    },
    deleteProperty(target, prop) {
        console.log('删除属性: ' + prop);
        return Reflect.deleteProperty(target, prop);
    }
});

proxy.name; // 读取属性name的值为'ming'
proxy.name = 'ming2'; // 设置属性name的值为'ming2'
delete proxy.name; // 删除属性: name
```
在上面的代码中，在Proxy对象的get()函数、set()函数、deleteProperty()函数中分别调用Reflect.get()函数、Reflect.set()函数、Reflect.deleteProperty()函数。

最后的测试代码验证了使用Reflect对象的准确性。

那么两者的配合使用能实现什么样的功能呢？
**实现观察者模式**

观察者模式的表现是：一个目标对象管理所有依赖于它的观察者对象，当自身的状态有变更时，会主动向所有观察者发出通知。

按照观察者模式的表现，可以设想这样一个场景：有一个目标对象和两个观察者对象，在修改目标对象的属性时通知所有的观察者，其中一个观察者获得修改后的值“开心地笑了”，另一个观察者获得修改后的值“伤心地哭了”。

如果采用Proxy对象和Reflect对象的实现方式，其中必须包含以下元素。
- Proxy代理的对象为观察者模式中的目标对象。
- 拥有一个Set集合，包含所有的观察者对象。
- 观察者对象由用户自定义，本实例中有两个观察者，实际为两个函数。
- 通过Proxy的set()函数实现属性拦截，在set()函数中调用Reflect.set()函数设置属性值，然后执行通知的函数，即调用观察者对象代表的函数。
- 定义为目标对象添加观察者的函数。
- 通过Proxy构造函数生成代理的实例。
```js
// 目标对象
const target = {
  name: 'ming'
}
// 观察着队列，包含所有的观察者对象
const queueObservers = new Set();
// 第一个观察者对象
function observer1(prop, value) {
  console.log(`目标对象的${prop}属性值变为${value}，观察者1开心地笑了`);
}
// 第二个观察者对象
function observer2(prop, value) {
  console.log(`目标对象的${prop}属性值变为${value}，观察者2伤心地哭了`);
}
// Proxy的set()函数，用于拦截目标对象属性修改的操作
function set(target, prop, value) {
  // 使用Reflect.set()函数修改属性
  const result = Reflect.set(target, prop, value);
  // 执行通知函数，通知所有的观察者
  result ? queueObserver.forEach(fn => fn(prop, value)) : '';
  return result;
}
// 为目标对象添加观察者
const observer = fn => queueObservers.add(fn);
// 通过Proxy生成目标对象的代理的函数
const observable = target => new Proxy(target, { set });
// 获取代理
const proxy = observable(target); // const proxy = new Proxy(target, { set });

observer(observer1);
observer(observer2);

proxy.name = 'ming2';
```
当最后执行proxy.name = 'ming2'后，进入了Proxy的set()函数中，成功地修改了name属性值，并且通知观察者执行各自的操作，第一个观察者输出的结果如下所示。
```bash
目标对象的name属性值变为ming2，观察者1开心地笑了
目标对象的name属性值变为ming2，观察者2伤心地哭了
```
## Promise
### 诞生的原因
Promise诞生以前，在处理一个异步请求时，通常是在回调函数中做处理，例如处理一个Ajax请求的代码如下所示。
```js
$.ajax({
    url: 'testUrl',
    success: function () {
        // 回调函数
    }
});
```
假如在一个行为中，需要执行多个异步请求，每一个请求又需要依赖上一个请求的结果，按照回调函数的处理方法，代码如下所示。
```js
// 第一个请求
$.ajax({
    url: 'url1',
    success: function () {
        // 第二个请求
        $.ajax({
            url: 'url2',
            success: function () {
                // 第三个请求
                $.ajax({
                    url: 'url3',
                    success: function () {
                        // 第四个请求
                        $.ajax({
                            url: 'url4',
                            success: function () {
                                // 成功地回调
                            }
                        })
                    }
                })
            }
        })
    }
})
```
事实上，一个行为所产生的异步请求可能比这个还要多，这就会导致代码的嵌套太深，引发“**回调地狱**”。
“回调地狱”存在以下几个问题。
- 代码臃肿，可读性差。
- 代码耦合度高，可维护性差，难以复用。
- 回调函数都是匿名函数，不方便调试。
### 生命周期
每一个Promise对象都有3种状态，即pending（进行中）、fulfilled（已成功）和rejected（已失败）。
Promise在创建时处于pending状态，状态的改变只有两种可能，
- 一种是在Promise执行成功时，由pending状态改变为fulfilled状态；
- 另一种是在Promise执行失败时，由pending状态改变为rejected状态。

> 状态一旦改变，就不能再改变，状态改变一次后得到的就是Promise的终态。

### 基本用法
Promise对象本身是一个构造函数，可以通过new操作符生成Promise的实例。
```js
const promise = new Promise((resolve, reject) => {
    // 异步请求处理
    if(/ 异步请求标识 /) {
        resolve();
    } else {
        reject();
    }
});
```
Promise执行的过程是：在接收的函数中处理异步请求，然后判断异步请求的结果。
- 如果结果为“true”，则表示异步请求执行成功，调用resolve()函数，resolve()函数一旦执行，Promise的状态就从pending变为fulfilled；
- 如果结果为“false”，则表示异步请求执行失败，调用reject()函数，reject()函数一旦执行，Promise的状态就从pending变为rejected。

resolve()函数和reject()函数可以传递参数，作为后续.then()函数或者.catch()函数执行时的数据源。

需要注意的是Promise在创建后会立即调用，然后等待执行resolve()函数或者reject()函数来确定Promise的最终状态。
```js
let promise = new Promise(function(resolve, reject) {
    console.log('Promise');
    resolve();
});
promise.then(function() {
    console.log('resolved');
});
console.log('Hello');
```
在上面的代码中，会先后输出“Promise”“Hello”“resolved”。
- 首先是Promise的创建，会立即执行，输出“Promise”。
- 然后是执行resolve()函数，这样的话就会触发then()函数指定回调函数的执行，但是它需要等当前线程中的所有同步代码执行完毕，因此会先执行最后一行同步代码，输出“Hello”。
- 最后是当所有同步代码执行完毕后，执行then()函数，输出“resolved”。

在拥有Promise异步解决方案后，实现原生get类型的Ajax请求的代码如下所示。
```js
// 封装原生get类型Ajax请求
function ajaxGetPromise(url) {
    const promise = new Promise(function (resolve, reject) {
        const handler = function () {
            if (this.readyState !== 4) {
                return;
            }
            // 当状态码为200时，表示请求成功，执行resolve()函数
            if (this.status === 200) {
            // 将请求的响应体作为参数，传递给resolve()函数
                resolve(this.response);
            } else {
                // 当状态码不为200时，表示请求失败，reject()函数
                reject(new Error(this.statusText));
            }
        };
        // 原生Ajax请求操作
        const client = new XMLHttpRequest();
        client.open("GET", url);
        client.onreadystatechange = handler;
        client.responseType = "json";
        client.setRequestHeader("Accept", "application/json");
        client.send();
    });
    return promise;
}
```
当一个Promise的实例创建好后，该如何进行成功或者失败的异步处理呢？这就需要调用then()函数和catch()函数了。
#### then()函数
Promise在原型属性上添加了一个then()函数，表示在Promise实例状态改变时执行的回调函数。
它接收两个函数作为参数，第一个参数表示的是Promise在执行成功后（即调用了resolve()函数），所需要执行的回调函数，函数参数就是通过resolve()函数传递的参数。第二个参数是可选的，表示的是Promise在执行失败后（即调用了reject()函数或抛出了异常），执行的回调函数。
```js
// 以上面封装Ajax请求的函数为例，看看then()函数的用法。
ajaxGetPromise('/testUrl').then((response) => {
    console.log(response);
});
```
ajaxGetPromise()函数在执行后会返回一个Promise实例，在执行then()函数时，回调函数中接收一个response参数，值为resolve()函数中传递的this.response，表示Ajax请求的响应。

then()函数返回的是一个新Promise实例，因此可以使用链式调用then()函数，在上一轮then()函数内部return的值会作为下一轮then()函数接收的参数值。
```js
const promise = new Promise((resolve, reject) => {
     resolve(1);
});
// then()函数链式调用
promise.then((result) => {
    console.log(result);  // 1
    return 2;
}).then((result) => {
    console.log(result);  // 2
    return 3;
}).then((result) => {
    console.log(result);  // 3
    return 4;
}).then((result) => {
    console.log(result);  // 4
});
```
基于then()函数的链式调用写法，可以解决本小节开头提到的“回调地狱”问题。
从代码风格上看，使用Promise的写法非常优雅。

> 需要注意的是，在then()函数中不能返回Promise实例本身，否则会出现Promise循环引用的问题，抛出异常。
```js
const promise = Promise.resolve()
    .then(() => {
        return promise;
    });
```
以上代码在运行后，会抛出如下所示的异常。
```bash
TypeError: Chaining cycle detected for promise #<Promise>
```
虽然then()函数能够处理rejected状态的Promise的回调函数，但是并不推荐这么做，而是推荐将它交给catch()函数来处理。
#### catch()函数
catch()函数与then()函数是成对存在的，then()函数是Promise执行成功之后的回调，而catch()函数是Promise执行失败之后的回调，它所接收的参数就是执行reject()函数时传递的参数。
```js
const promise = new Promise((resolve, reject) => {
    try {
        throw new Error('test');
    } catch(err) {
        reject(err);
    }
});
promise.catch((err) => {
    console.log(err); // Error: test
});
```
因为promise实例在创建后会立即执行，所以进入try语句后会抛出一个异常，从而被catch()函数捕获到，在catch()函数中调用reject()函数，并传递Error信息。一旦reject()函数被执行，就会触发promise实例的catch()函数，从而能在catch()函数的回调函数中输出err的信息。

事实上**只要在Promise执行过程中出现了异常，就会被自动抛出，并触发reject(err)**，而不用我们去使用try...catch，在catch()函数中手动调用reject()函数。

因此前面的代码可以改写成如下所示的代码。
```js
const promise = new Promise((resolve, reject) => {
    throw new Error('test');
});
promise
    .catch((err) => {
        console.log(err); // Error: test
    });
```
再拿一个空指针引用的异常来进行测试。
```js
const promise = new Promise((resolve, reject) => {
    null.name;
});
promise
    .catch((err) => {
        console.log(err); // TypeError: Cannot read property 'name' of null
    });
```
在Promise接收的函数体中引用null的name属性时，会抛出一个异常。这个异常会被自动捕获，而且会自动执行reject()函数，从而会触发catch()函数并传递异常值，在函数体中将其输出，得到以下的结果。
```bash
TypeError: Cannot read property 'name' of null
```
需要注意的是，如果一个Promise的状态已经变成fulfilled成功状态，再去抛出异常，是无法触发catch()函数的。这是因为Promise的状态一旦改变，就会永久保持该状态，不会再次改变。
```js
const promise = new Promise((resolve, reject) => {
    resolve(1);
    throw new Error('test');
});
promise
    .then((result) => {
        console.log(result);  // 1
    })
    .catch((err) => {
        console.log(err);
    });
```
在上面代码的Promise函数体中，调用resolve()函数，并传递一个参数1，会直接触发promise的then()函数，而不会执行下面的抛出异常的throw语句，从而输出“1”，整个Promise执行过程结束。

在ES6中不仅为Promise的原型对象添加了then()函数和catch()函数等异步处理函数，还为Promise对象自身添加了一系列的静态函数，用来处理多Promise实例同时运行的情况。

#### Promise.all()
then()函数和catch()函数是Promise原型链中的函数，因此每个Promise的实例可以进行共享，而all()函数是Promise本身的静态函数，用于将多个Promise实例包装成一个新的Promise实例。
```js
const p = Promise.all([p1, p2, p3]);
```
返回的新Promise实例p的状态由3个Promise实例p1、p2、p3共同决定，总共会出现以下两种情况。
- 只有p1、p2、p3全部的状态都变为fulfilled成功状态，p的状态才会变为fulfilled状态，此时p1、p2、p3的返回值组成一个数组，作为p的then()函数的回调函数的参数。
- 只要p1、p2、p3中有任意一个状态变为rejected失败状态，p的状态就变为rejected状态，此时第一个被reject的实例的返回值会作为p的catch()函数的回调函数的参数。
- 即p1 && p2 && p3
```js
const p1 = new Promise((resolve, reject) => {
    resolve('success');
}).then(result => result).catch(e => e);
const p2 = new Promise((resolve, reject) => {
    throw new Error('error');
}).then(result => result).catch(e => e);

Promise.all([p1, p2])
    .then(result => console.log(result)) // ['success', Error: error]
    .catch(e => console.log(e));
```
在上面代码的实例p2中抛出了一个异常，p2的状态变为rejected，但是由于p2有自己的catch()函数，所以这个异常会在p2实例内部被消化，并不会继续向外抛到Promise.all()函数中。
p2实例执行完catch()函数后，p2的状态实际是变为fulfilled，只不过它的返回值是Error的信息。
p1实例调用resolve()函数执行成功，因此p1的状态也是fulfilled，返回值为字符串'success'。
因此Promise.all()函数运行后的结果为输出一个包含p1、p2返回值的数组“ ['success',Error: error]”。
**如果想要Promise.all()函数能触发catch()函数，那么就不要在p1、p2实例中定义catch()函数。**
```js
const p1 = new Promise((resolve, reject) => {
    resolve('success');
}).then(result => result);
const p2 = new Promise((resolve, reject) => {
    throw new Error('error');
}).then(result => result);

Promise.all([p1, p2])
    .then(result => console.log(result))
    .catch(e => console.log(e)); // 抛出异常，Error: error
```
#### Promise.race()函数
Promise.all()函数作用于多个Promise实例上，返回一个新的Promise实例，表示的是如果多个Promise实例中有任何一个实例的状态发生改变，那么这个新实例的状态就随之改变，而最先改变的那个Promise实例的返回值将作为新实例的回调函数的参数。
```js
const p = Promise.race([p1, p2, p3]);
```
当p1、p2、p3这3个Promise实例中有任何一个执行成功或者失败时，由Promise.race()函数生成的实例p的状态就与之保持一致，并且最先那个执行完的实例的返回值将会成为p的回调函数的参数。

> 使用Promise.race()函数可以实现这样一个场景：假如发送一个Ajax请求，在3秒后还没有收到请求成功的响应时，会自动处理成请求失败。

实现的思路如下：
- 将Ajax请求处理成一个Promise，称之为p1。
- 创建一个自定义的Promise实例，称之为p2，在p2中通过setTimeout()函数控制3秒后抛出一个异常。
- 将p1和p2两个实例放入Promise.race()函数中，生成一个新的实例p，如果在3秒内接收到Ajax请求的返回值，表示实例p1执行成功，则p通过调用then()函数可以接收到p1的返回值；如果在3秒后还没有接收到Ajax请求的返回值，则会执行p2中的setTimeout()函数，抛出一个异常，表示p2执行失败，则p通过调用catch()函数可以接收到p2的返回值。
```js
// 根据以上分析，可以得到以下代码。
const p1 = ajaxGetPromise('/testUrl');
const p2 = new Promise(function (resolve, reject) {
      setTimeout(() => reject(new Error('request timeout')), 5000)
});
const p = Promise.race([p1, p2]);
p.then(console.log).catch(console.error);
```
#### Promise.resolve()函数
Promise提供了一个静态函数resolve()，用于将传入的变量转换为Promise对象，它等价于在Promise函数体内调用resolve()函数。
Promise.resolve()函数执行后，Promise的状态会立即变为fulfilled，然后进入then()函数中做处理。
```js
Promise.resolve('hello');
// 等价于
new Promise(resolve => resolve('hello'));
```
在Promise.resolve(param)函数中传递的参数param，会作为后续then()函数的回调函数接收的参数。
```js
Promise.resolve('success').then(result => console.log(result)); 
```
执行上面的代码后，会输出字符串“success”。
#### Promise.reject()函数
Promise.reject()函数用于返回一个状态为rejected的Promise实例，函数在执行后Promise的状态会立即变为rejected，从而会立即进入catch()函数中做处理，等价于在Promise函数体内调用reject()函数。
```js
const p = Promise.reject('出错了');
// 等价于
const p = new Promise((resolve, reject) => reject('出错了'));
```
在Promise. reject (param)函数中传递的参数param，会作为后续catch()函数的回调函数接收的参数。
```js
Promise.reject('fail').catch(result => console.log(result));
```
执行上面的代码后，会输出字符串“fail”。
### 用法实例
#### 场景1：Promise代码与同步代码在一起执行
```js
const promise = new Promise((resolve, reject) => {
    console.log(1);
    resolve();
    console.log(2);
});
promise.then(() => {
    console.log(3);
});
console.log(4);
```
在上面的代码中，考察的是对Promise对象执行时机的理解，大致会分为以下几个过程。
- Promise在创建后会立即执行，所有同步代码按照书写的顺序从上往下执行，包括Promise外的同步代码，因此会先输出“1 2 4”。
- resolve()函数或者reject()函数会在同步代码执行完毕后再去执行。
- 当resolve()函数或者reject()函数执行后，进入then()函数或者catch()函数中执行，实例中调用了resolve()函数，会进行到then()函数中，因此会再输出“3”。

代码的输出结果如下所示。
```bash
1 2 4 3
```
#### 场景2：同一个Promise实例内，resolve()函数和reject()函数先后执行
会在同一个Promise实例内连续多次执行resolve()函数和reject()函数，然后在then()函数和catch()函数中各自输出特定信息，看看最终的输出结果是什么。
```js
const promise2 = new Promise((resolve, reject) => {
    resolve('success1');
    reject('error');
    resolve('success2');
});

promise2
    .then((res) => {
        console.log('then: ', res);
    })
    .catch((err) => {
        console.log('catch: ', err);
    });
```
一个Promise的实例只能有一次状态的变更，当执行了resolve()函数后，后续其他的reject()函数和resolve()函数都不会执行，然后Promise进入then()函数中做处理。
因此在上面的代码中，执行了resolve('success1')后会立即进入then()函数中，输出“then:success1”，而不会再执行其他的reject()函数或者resolve()函数。

代码的输出结果如下所示。
```bash
then: success1
```
#### 场景3：同一个Promise实例自身重复执行
生成一个Promise的实例，针对这个实例重复调用then()函数，在then()函数中输出一个时间差值，看看最终的输出结果是什么。
```js
1  const promise3 = new Promise((resolve, reject) => {
2      setTimeout(() => {
3          console.log('once');
4          resolve('success');
5      }, 1000);
6  });
7  const start = Date.now();
8  promise3.then((res) => {
9      console.log(res, Date.now() - start);
10 });
11 promise3.then((res) => {
12     console.log(res, Date.now() - start);
13 });
```
同一个Promise的实例只能有一次状态变换的过程，在状态变换完成后，如果成功会触发所有的then()函数，如果失败会触发所有的catch()函数。

在上面的代码中，第1～6行生成promise3实例，通过setTimeout()函数延迟执行resolve()函数，会继续向下执行到第7行代码，得到一个start时间戳。

当等待一秒后，执行第2行的setTimeout()函数，首先输出一个字符串'once'，然后执行resolve()函数并传递字符串'success'，开始进入第8行的then()函数中，计算当前时间戳与start时间戳的差值。由
于Promise的状态只能改变一次，第10行的then()函数与第8行的then()函数都会执行，而且会接收相同的参数，然后重新计算时间戳的差值。

得到的结果如下所示。
```bash
once
success 1001
success 1002
```
#### 场景4：在then()函数中返回一个异常
会在一个Promise实例的then()函数中返回一个异常，然后链式调用then()函数和catch()函数，在函数中输出关键信息，看看最终的输出结果是什么。
```js
Promise.resolve()
    .then(() => {
        console.log(1);
        return new Error('error!!!'); // no throw, no catch
    })
    .then((res) => {
        console.log(2);
        console.log('then: ', res);
    })
    .catch((err) => {
        console.log(3);
        console.log('catch: ', err);
    });
```
得到的结果如下所示。
```bash
1
2
Error: error!!!
    at Promise.resolve.then (<anonymous>:4:16)
```
#### 场景5：then()函数接收的参数不是一个函数
then()函数接收的参数是函数的形式，如果then()函数接收的参数不是一个函数，会产生什么样的情况呢？
```js
Promise.resolve(1)
    .then(2)
    .then(Promise.resolve(3))
    .then(console.log);
```
很多人乍一看这段代码，会想当然地以为返回“3”，但是结果却不是这样的。

这段代码的运行结果是只输出一个“1”，为什么会这样呢？

在Promise的then()函数或者catch()函数中，接收的是一个函数，函数的参数是resolve()函数或者reject()函数的返回值。**而如果传入的值是非函数，那么就会产生值穿透现象**。

何为值穿透现象？简单点理解就是传递的值会被直接忽略掉，继续执行链式调用后续的函数。

场景5中，第一个then()函数接收一个值“2”，第二个then()函数接收一个Promise，都不是需要的函数形式，因此这两个then()函数会发生值穿透现象。
而第三个then()函数因为接收到console.log()函数，因此会执行，此时接收的是最开始的resolve(1)的值，因此场景5最终会输出“1”。
#### 场景6：两种方法处理rejected状态的Promise
**处理Promise失败的方法有两种，一种是使用then()函数的第二个参数，另一种是使用catch()函数。**
同时使用这两种方法处理抛出异常的Promise，可以通过输出的结果来看看两种方法的差异是什么。
```js
Promise.resolve()
    .then(function success (res) {
        throw new Error('error');
    }, function fail1 (e) {
        console.error('fail1: ', e);
    })
    .catch(function fail2 (e) {
        console.error('fail2: ', e);
    });
```
虽然这两种方法都能处理Promise状态变为rejected时的回调，但是then()函数的第二个函数却不能捕获第一个函数中抛出的异常，而catch()函数却能捕获到第一个函数中抛出的异常。
```bash
# 输出的结果如下所示。
fail2: Error: error
```
> 推荐使用catch()函数去处理Promise状态异常回调的原因。

## Iterator与for...of循环
### Iterator概述
Iterator称为遍历器，是ES6为不同数据结构遍历所新增的统一访问接口，它有以下几个作用。
- 为任何部署了Iterator接口的数据结构提供统一的访问机制。
- 使得数据结构的成员能够按照某种次序排列。
- 为新的遍历方式for...of提供基础。

一个合法的Iterator接口都会具有一个next()函数，在遍历的过程中，依次调用next()函数，返回一个带有value和done属性的对象。value值表示当前遍历到的值，done值表示迭代是否结束，true表示迭代完成，Iterator执行结束；false表示迭代未完成，继续执行next()函数，进入下一轮遍历中，直到done值为true。

先使用数组来模拟Iterator接口的实现。
```js
function makeIterator(array) {
    let index = 0;
    return {
        next: function () {
            if (index < array.length) {
                return { value: array[index++], done: false };
            } else {
                return { value: undefined, done: true };
            }
        }
    };
}
const arr = ['one', 'two'];
const iter = makeIterator(arr);
iter.next(); // { value: "one", done: false }
iter.next(); // { value: "two", done: false }
iter.next(); // { value: undefined, done: true }
```
在上面的代码中，将数组作为参数传递到makeIterator()函数中，用于生成一个带有next()函数的遍历器对象。

每次调用next()函数时，会返回一个带有value和done属性的对象，如果当前索引值index小于数组的长度，则value值为数组中对应索引位置的值，done值为false并且index值会递增；直到index的值等于数组的长度才结束遍历，此时value值为undefined，done值为true。

### 默认Iterator接口
只有部署了Iterator接口的数据结构才能使用for...of遍历，举例如下。
```js
// 对象默认不能使用for...of循环
const obj = {
    name: 'ming',
    age: 11
};
for (let key of obj) {
    console.log(key); // TypeError: obj[Symbol.iterator] is not a function
}
// 数组能正常使用for...of循环
const arr = ['one', 'two'];
for (let key in arr) {
    console.log(key); // 0, 1
}
```
对象类型的数据使用for...of循环时，会抛出异常，表示对象不支持使用for...of循环；而对数组类型的数据使用for...of循环时，可以正常输出结果，表示数组支持for...of循环。

原生具备Iterator接口（可直接使用for...of循环进行遍历）的数据结构有以下几个。
- Array。
- Map。
- Set。
- String。
- 函数的arguments对象。
- NodeList对象。

想要自定义一些可以使用for...of循环的数据结构，那么该怎么做呢？

方法就是为数据结构添加上Iterator接口，Iterator接口是部署在Symbol.iterator属性上的，它是一个函数，因此只需要对特定的数据结构加上Symbol.iterator属性即可。

在Symbol.iterator属性对应的函数中一定要返回一个带有next()函数的对象，在next()函数中需要返回带有value和done属性的对象，以此来满足Iterator的执行过程。

接下来就通过自定义的手段，为对象类型的数据添加Iterator接口，使得它也可以使用for...of循环，具体代码如下所示。
```js
function Person(name, age) {
    this.name = name;
    this.age = age;
}
// 在原型中添加[Symbol.iterator]属性
Person.prototype[Symbol.iterator] = function () {
    // 设置变量，记录遍历的次数
    let count = 0;
    // 通过Object.keys()函数获取实例自身的所有属性
    let propArr = Object.keys(this);
    return {
        next: function () {
            // 每执行一次遍历，count值加1
            // 当count值小于属性的长度时，表示仍然可以遍历，设置done值为false
            if (count < propArr.length) {
                let index = count++;
                return { value: propArr[index], done: false };
            } else {
                // 当count值等于属性的长度时，遍历结束，设置done值为true
                return { value: undefined, done: true };
            }
        }
    }
};
const person = new Person('ming', 12);
for (let key of person) {
    console.log(key, ':', person[key]);
}
```
在上面的代码中，将Symbol.iterator属性设置在Person的prototype原型上，这样每个实例都会共享这个Symbol.iterator()函数。

在每次执行next()函数时，先判断遍历的次数与属性长度是否相等，如果相等则表示遍历结束，设置done值为true；如果不相等，则表示仍然可以继续遍历，设置done值为false。

输出的结果如下所示。
```bash
name : ming
age : 12
```
### for...of循环
主要目的是为了统一所有数据结构的遍历方式。

如上文所讲到的，部署了Iterator接口的数据结构都可以使用for...of循环，因此数组、Set和Map、类数组对象等都可以直接使用for...of循环。

接下来就针对这些数据结构来看看它们在使用for...of循环时的表现是什么样的。

#### 数组结构
对于数组类型数据，for...of循环会返回数组中的每个值，而不是数组的索引。
```js
const arr = ['one', 'two', 'three'];
for (let key of arr) {
    console.log(key); // one, two, three
}
```
#### Set和Map数据结构
都原生具备Iterator接口，可以直接使用for...of循环。
```js
let set = new Set(['one', 'two', 'three']);
for (let key of set) {
    console.log(key); // one, two, three
}

let map = new Map();
map.set('name', 'ming');
map.set('age', 12);
map.set('address', 'beijing');
for (let prop of map) {
    console.log(prop);
    // [ 'name', 'ming' ]
    // [ 'age', 12 ]
    // [ 'address', 'beijing' ]
}
```
需要注意两点：
- 一个是for...of循环遍历的顺序与值添加进数据结构的顺序一致；
- 另一个是Set数据结构遍历的返回值只有一个，而Map数据结构遍历的返回值有两个，是由键、值组成的数组。

#### NodeList结构
```html
<p>这是第一个段落</p>
<p>这是第二个段落</p>
<p>这是第三个段落</p>

<script>
    const pList = document.querySelectorAll(‘p’);
    for (let p of pList) {
        console.log(p.innerText);
        // 这是第一个段落
        // 这是第二个段落
        // 这是第三个段落
    }
</script>
```
#### 函数参数arguments对象
```js
function foo() {
    for (let arg of arguments) {
        console.log(arg); // name age address
    }
}
foo('name', 'age', 'address');
```
#### 特定函数的返回值
> 对象类型的数据无法直接使用for...of循环进行遍历

借助ES6中Object对象新增的几个函数来间接地实现for...of循环，这几个函数如下所示。
- Object.entries()函数：返回一个遍历器对象，由键、值构成的对象数组。
- Object.keys()函数：返回一个遍历器对象，由所有的键构成的数组。
- Object.values()函数：返回一个遍历器对象，由所有的值构成的数组。

```js
const obj = {
    name: 'ming',
    age: 12,
    address: 'beijing'
};
for (let key of Object.keys(obj)) {
    console.log(key);  // name, age, address
}
for (let value of Object.values(obj)) {
    console.log(value); // ming, 12, beijing
}
for (let [key, value] of Object.entries(obj)) {
    console.log(key, ':', value);
}
// name : 'ming',
// age : 12,
// address : 'beijing'
```
### for...of循环与其他循环方式的比较
与`forEach()`函数循环和`for...in`循环进行比较。

forEach()函数循环的主要问题在于无法跳出循环，**不支持break和continue关键字**，如果使用了break或continue关键字则会抛出异常，使用return关键字会跳过当前循环，但仍会执行后续的循环。
```js
const arr = ['one', 'two', 'three'];
arr.forEach(function (item, index) {
    if (index === 1) {
        return item; // 这里如果使用break和continue关键字，会抛出异常，使用return 
                     // 关键字会跳过当前循环
    }
    console.log(item); // one three
});
```

for...in循环的主要问题在于，它主要是为遍历对象设计的，对数组遍历并不友好，主要存在以下两个问题。
- 第一个问题是，在使用for...in循环遍历数组时，返回的键是字符串表示的数组的索引，如“0” “1” “2”，并不是数组项的值。
- 第二个问题是，通过手动给数组实例添加的属性，同样会被遍历出来，而事实上并不希望这些额外的属性被遍历出来。
```js
const arr = ['one', 'two', 'three'];
arr.name = 'myArr';
for (let key in arr) {
    console.log(key, typeof key);
}
```
代码输出的结果如下所示。
```bash
0 string
1 string
2 string
name string
```
通过结果可以看出，输出的key值是数组的索引“0”“1”“2”并且是字符串类型，而且为数组新增的name属性同样被遍历输出，这并不是想要的结果。

相比于forEach()函数循环和for...in循环，for...of循环就有一些显著的优点。
1. 优点1：和for...in循环有同样的语法，但没有for...in循环的缺点，遍历数组时，返回的是数组每项的值，而且给数组实例新增的属性并不会被遍历出来。
```js
const arr = ['one', 'two', 'three'];
arr.name = 'myArr';
for (let key of arr) {
    console.log(key); // one two three
}
```
2. 优点2：在for...of循环中，可以使用break、continue和return等关键字。
```js
const arr = ['one', 'two', 'three'];
for (let key of arr) {
    if (key === 'two') {
        break;
    }
    console.log(key); // one
}
```
## Generator()函数
### 概述与特征
#### 概述
> 是ES6提供的一种异步编程解决方案。

从语法上可以理解为是一个状态机，函数内部维护多个状态，函数执行的结果返回一个部署了Iterator接口的对象，通过这个对象可以依次获取Generator()函数内部的每一个状态。
#### 特征
本质上也是一个函数，调用方法也与普通函数相同，但有以下两个明显的特征。
- function关键字与函数名之间有一个星号（*）。
- 函数体内部使用yield关键字来定义不同的内部状态。
```js
function* helloWorldGenerator() {
      yield 'hello';
      yield 'world';
}
const hw = helloWorldGenerator();
```
返回一个部署了Iterator接口的对象hw，直到调用next()函数时，才开始从函数头部向下执行，直到遇到yield表达式或者return语句才会停止。
```js
function* helloWorldGenerator() {
    console.log('Generator执行');
    yield 'hello';
    yield 'world';
}

const hw = helloWorldGenerator();
console.log('这是测试执行先后顺序的语句');
hw.next();
// 这是测试执行先后顺序的语句
// Generator执行
```
因为在调用helloWorldGenerator()函数时，并不会立即执行函数体，而是优先往下执行，输出“这是测试执行先后顺序的语句”，等到执行next()函数时，才开始执行函数体，输出“Generator执行”。

#### yield表达式与next()函数的关系
Generator()函数返回的是部署了Iterator接口的对象，而该对象是通过调用next()函数来遍历内部状态的，所以在没有调用下一轮next()函数时，函数处于暂停状态，而这个暂停状态就是通过yield表达式来体现的，**因此Generator()函数对异步的控制是通过yield表达式来实现的。**

通过Iterator接口的next()函数执行过程可以看出next()函数与yield表达式的关系。
- next()函数的返回值是一个具有value和done属性的对象，next()函数调用后，如果遇到yield表达式，就会暂停后面的操作，并将yield表达式执行的结果作为value值进行返回，此时done属性的值为false。
- 当再次执行next()函数时，会再继续往下执行，直到遇到下一个yield表达式。
- 当所有的yield语句执行完毕时，会直接运行至函数末尾，如果有return语句，将return语句的表达式值作为value值返回；如果没有return语句，则value以undefined值进行返回，这两种情况下的done属性的值都为true，遍历结束。
```js
function* helloWorldGenerator() {
    yield 'hello';
    yield 'world';
    return 'success';
}

const hw = helloWorldGenerator();
hw.next();  // {value: "hello", done: false}
hw.next();  // {value: "world", done: false}
hw.next();  // {value: "success", done: true}
```

##### next()函数参数的作用
```js
1  function* foo(x) {
2      let y = 3 * (yield (x + 2));
3      let z = yield (y / 4);
4      return (x + y + z);
5  }
6
7  let a = foo(5);
8  a.next(); // { value:7, done:false }
9  a.next(); // { value:NaN, done:false }
10 a.next(); // { value:NaN, done:true }
11
12 let b = foo(5);
13 b.next(); // { value:7, done:false }
14 b.next(8); // { value:6, done:false }
15 b.next(9); // { value:38, done:true }
```
第一组值（第7～10行代码）的计算过程：
- 第7行代码调用foo()函数，x值为5，获取一个部署了Iterator接口的对象a。
- 第8行代码执行next()函数时，遇到yield表达式，所以停止，此时为`yield 5 + 2 = yield 7`，因此第8行代码会输出“{ value:7,done:false }”。
- 第9行代码执行next()函数时，因为next()函数没有传递参数值，yield表达式的返回值为“undefined”，即y的值为`3 × undefined = NaN`，在计算y /4时，返回“NaN”。
- 同理第10行代码执行next()函数时，也会返回“NaN”。

第二组值（第12～15行代码）的计算过程。
- 第12行代码调用foo()函数，x值为5，获取一个部署了Iterator接口的对象b。
- 第13行代码执行next()函数时，遇到yield表达式，则停止，此时为`yield 5 + 2 = yield 7`，因此第13行代码执行next()函数时会输出“{ value:7, done:false }”。
- 第14行代码执行next()函数时，传递了参数8，表示上一轮yield的返回值为“8”，那么y = 3×8 = 24，执行到yield y / 4 =yield 6，第14行代码执行next()函数时的返回值为“{ value:6,done:false }”。
- 第15行代码执行next()函数时，传递了参数9，表示上一轮yield的返回值为“9”，即z = 9，x = 5，y = 24，x + y + z = 38，第15行代码执行next()函数时返回值为“{ value:38,done:true }”。
#### for...of循环遍历Generator()函数的返回值
Generator()函数的返回值是一个部署了Iterator接口的对象，可以使用for...of循环进行遍历，并且不需要手动调用next()函数，遍历的结果就是yield表达式的返回值。
```js
function* testGenerator() {
    yield 'hello';
    yield 'world';
}

const t = testGenerator();
for (let key of t) {
    console.log(key); // 先后输出"hello""world"
}
```
> 对象类型的值在默认情况下是不能使用for...of循环进行遍历的，但是借助于Generator()函数可以实现for...of循环的遍历。

主要思路是给对象的Symbol.iterator属性设置一个Generator()函数，在Generator()函数内通过yield控制遍历的返回值。
```js
function* propGenerator() {
    let propArr = Object.keys(this);
    for (let prop of propArr) {
     // 通过yield控制每轮循环的返回值为由属性名和属性值构成的数组
        yield [prop, this[prop]];
    }
}
let obj = {
    name: 'ming',
    age: 12
};
// 为obj对象添加Symbol.iterator属性
obj[Symbol.iterator] = propGenerator;
// 对yield的返回值
for (let [key, value] of obj) {
    console.log(key, ':', value);
}
```
### 注意事项
#### 默认情况下不能使用new关键字
```js
function* testGenerator() {
    yield 'test';
}
const tg = new testGenerator(); // TypeError: testGenerator is not a constructor
```
#### yield表达式会延迟执行
在Generator()函数中，yield表达式只有在调用next()函数时才会去执行，因此起到了延迟执行的效果。
```js
function* testGenerator() {
    yield 1 + 2;
}
const tg = testGenerator();
tg.next(); // {value: 3, done: false}
```
#### yield表达式只能在Generator()函数中调用
如果出现在普通函数或者匿名函数中则会抛出语法异常。
```js
function foo() {
    yield 'foo'; // 抛出SyntaxError异常
}
```
#### yield表达式需要小括号括起来
当一个yield表达式出现在其他表达式中时，需要用小括号将yield表达式括起来，否则会抛出语法异常。
```js
function* demo() {
    console.log('Hello' + yield 123); // 抛出SyntaxError异常
    console.log('Hello' + (yield 123)); // 正确
}
```
#### Generator()函数中的this特殊处理
在默认情况下，不能使用new关键字生成Generator的实例，因此Generator()函数中的this是无效的。
```js
function* testGenerator() {
    this.name = 'ming'; // 在this上绑定的name属性不会生效，访问的时候会返回“undefined”。
    yield 'hello';
    yield 'world';
}

const t = testGenerator();
t.next();
console.log(t.name);  // undefined
```
如果既想使用Generator()函数的特性，又想使用this的特性，那该怎么做呢？

使用call()函数改变Generator()函数的执行主体为Generator()函数的prototype属性，使得this指向原型属性，这样就可以访问到原型上添加的属性。
```js
function* testGenerator() {
    this.name = 'ming';
    yield 'hello';
    yield 'world';
}
// 使用call()函数改变执行主体为testGenerator的prototype属性
let t = testGenerator.call(testGenerator.prototype);
t.next();
console.log(t.name);  // ming
```
#### Generator()函数嵌套使用
在不使用yield* 语句的情况下，需要手动遍历上一个Generator()函数，并在遍历完成后进入当前Generator()函数中。

```js
// 一般的写法如下所示。
function* fn1() {
    yield 'test1';
}
function* fn2() {
    yield 'test2';
    // 手动遍历嵌套的Generator()函数 
    for(let key of fn1()) {
          console.log(key);
    }
    yield 'test3';
}

let f = fn2();
for (let key of f) {
    console.log(key);
}
```
当嵌套的Generator()函数层级很深时，写起来会非常麻烦。

为了解决这个问题，ES6提供了一种新的写法，那就是使用yield* 表达式，以支持Generator()函数的嵌套使用。

上面实例使用yield* 表达式的写法后的代码如下所示。
```js
function* fn1() {
    yield 'test1';
}
function* fn2() {
    yield 'test2';
    // 调用另外一个Generator()函数，使用yield*关键字
    yield* fn1();
    yield 'test3';
}

let f = fn2();
for (let key of f) {
    console.log(key);
}
```
执行结果
```bash
test2
test1
test3
```
## Class👍👍👍
### 基本用法
为了让JavaScript具有更接近面向对象语言的写法，ES6引入了Class（类）的概念，通过class关键字定义类。

不管是ES5还是ES6的写法，想要生成对象的实例，都需要通过new关键字调用构造函数，但是在具体实现上有一些差异。
ES5需要定义构造函数，在构造函数中定义实例属性，然后在prototype原型上添加原型属性或者函数。
ES6则使用class关键字定义类的名称，然后在类的constructor构造函数中定义实例属性，原型属性在class内部直接声明并赋值，原型函数的声明与构造函数处于同一层级，并且省略function关键字。
```js
// es5的写法
function Person1(name, age) {
  // 实例属性
  this.name = name;
  this.age = age;
}
// 原型属性
Person1.prototype.publicCount = 1;
// 原型函数
Person1.prototype.getName = function () {
  return this.name;
}
const p1 = new Person('ming', 22);
console.log(p1.getName()); // ming

// es6
class Person2 {
  // 原型属性
  publicCount = 1;
  constructor(name, age) {
    // 实例属性
    this.name = name;
    this.age = age;
  }
  getName() {
    return this.name;
  }
}
const p2 = new Person('ming', 22);
console.log(p2.getName()); // ming
```
class的本质还是一个函数，只不过是函数的另一种写法，这种写法可以让对象的原型属性和函数更加清晰。
```js
console.log(typeof Person2); // function
```
事实上，class中的所有属性和函数都是定义在prototype属性中的，但是却没有使用过prototype属性，这是为什么呢？
其实这是因为ES6将prototype相关的操作封装在了class中，避免我们直接去使用prototype属性。
```js
// p2实例的getName属性与Person2类原型中的getName属性是严格相等的。
console.log(p2.getName === Person2.prototype.getName); // true
```
#### 重点理解的内容
##### constructor()函数
是一个类必须具有的函数，可以手动添加，如果没有手动添加，则会自动隐式添加一个空的constructor()函数。
constructor()函数默认会返回当前对象的实例，即默认的this指向，可以手动修改返回值。
```js
class Person3 {
    constructor(name) {
        this.name = name;
        return {};
    }
    getName() {
        return this.name;
    }
}
const p = new Person3('ming');
console.log(p.getName()); // TypeError: p.getName is not a function
```
在上面的代码中，修改了constructor()函数的返回值为一个空对象“{}”，所以实例p实际为一个空对象，在调用getName()函数时会抛出一个引用异常。
##### 静态属性和函数
静态属性和函数同样存在于类内部，使用static关键字修饰时，静态属性和函数无法被实例访问，只能通过类自身使用。
```js
class Foo {
    static classProp = 'staticProp';
    static classMethod() {
        return 'hello';
    }
}
// 类自身可以正常访问静态属性和函数
Foo.classProp;  // 'staticProp'
Foo.classMethod(); // 'hello'

const foo = new Foo();
// 通过实例访问静态属性，返回undefined
foo.classProp; // undefined
// 通过实例访问静态函数，抛出异常
foo.classMethod(); // TypeError: foo.classMethod is not a function
```
**静态函数中的this指向的是类本身，而不是类的实例**，也正因为静态函数和实例函数中的this是隔离的，所以同一个类中可以存在函数名相同的静态函数和实例函数。
```js
class MyClassroom {
    constructor(number) {
        this.number = number;
    }
    // 静态函数，包含的this关键字指向的是类本身，而不是实例
    static get1() {
        return this.number;
    }
    // 实例函数，包含的this指向实例
    get1() {
        return this.number;
    }
}

console.log(MyClassroom.get1()); // undefined
// 为类本身添加变量
MyClassroom.number = 60;
console.log(MyClassroom.get1()); // 60

const classroom = new MyClassroom(20);
console.log(classroom.get1()); // 20
```
#### 使用示例
使用Class定义一个类，来完成一个简单的版本控制功能，主要有以下操作。
- 使用一个二维数组作为所有历史提交记录的集合，数组的每个元素为一个一维数组，表示某次commit时记录的信息。
- 使用一个一维数组装下用户所有的历史修改值，当调用commit()函数时，会将历史修改值添加至历史记录对应的二维数组中。
- 当调用revert()函数时，会回滚到最近一次commit的版本。
```js
class VersionedArray {
    constructor() {
        super();
        // 所有的历史提交值
        this.arr = [];
        // 初始状态空的二维数组
        this.history = [[]];
    }
    commit() {
        // 每次commit时，先执行slice()函数获取一次，然后添加到history二维数组中
        this.history.push(this.arr.slice());
    }
    revert() {
        // 执行revert()函数时，会将距离最近一次commit、新增的但是没有commit的内容全部清空
        // 返回到上一次commit的状态
        this.arr.splice(0, this.arr.length, ...this.history[this.history.
length - 1]);
    }
}

let x = new VersionedArray();

// 第一次修改了1
x.arr.push(1);

// 第二次修改了2
x.arr.push(2);
console.log(x.arr); // [1, 2]
// 此时并没有commit，历史记录仍然为空
console.log(x.history); // [[]]
// 执行commit()函数，添加至历史记录中
x.commit();
console.log(x.history); // [[], [1, 2]]

// 第三次修改了3
x.arr.push(3);
console.log(x.arr); // [1, 2, 3]
// 再次执行commit()函数，将当前arr值添加至历史记录中
x.commit();
console.log(x.history); // [ [], [ 1, 2 ], [ 1, 2, 3 ] ]

// 第四次修改了4
x.arr.push(4);
// 由于没有commit，直接回滚到最近的一个历史版本
x.revert();
console.log(x.arr); // [1, 2, 3]
```
#### 使用注意点
1. 只能与new关键字配合使用
```js
class Person {}

const p1 = new Person(); // 正常
const p2 = Person(); // TypeError: Class constructor Person cannot be invoked 
without 'new'
```
2. 不存在变量提升
let关键字和const关键字声明的变量不存在变量提升，class定义的类同样不存在变量提升，因此如果在定义类之前去使用它，会抛出引用异常。
```js
const p = new Person(); // ReferenceError: Person is not defined
class Person {}
```
3. 在类中声明函数时，不要加function关键字
```js
class Person3 {
    getName function() {  // SyntaxError: Unexpected token function
        return 'ming';
    }
}
```
4. this指向会发生变化
类内部的this默认指向的是类的实例，在调用实例函数时，一定要注意this的指向性问题。如果单独使用实例函数时，this的指向会发生变化，很容易带来一定的问题。
```js
class Person4 {
    constructor(name) {
        this.name = name;
    }
    getName() {
        return this.name;
    }
}
const p = new Person4('ming');
let { getName } = p; // 使用解构获取到getName()函数
getName(); // TypeError: Cannot read property 'name' of undefined
```
这是因为getName()函数是在全局环境中执行的，this指向的是全局环境，而在ES6的class关键字中使用了严格模式。**在严格模式下this不能指向全局环境，而是指向undefined**，所以getName()函数在执行时，this实际为undefined，通过undefined引用name属性就会抛出异常。
```js
// 为了解决上述问题，可以在构造函数中使用bind关键字重新绑定this。
class Person4 {
    constructor(name) {
        this.name = name;
        // 重新绑定getName()函数中this的指向为当前实例
        this.getName = this.getName.bind(this);
    }
    getName() {
        return this.name;
    }
}
const p = new Person4('ming');
let { getName } = p;
getName(); // ming
```
### class继承
ES6新增了extends关键字，可以快速实现类的继承。

在子类的constructor构造函数中，需要首先调用super()函数执行父类的构造函数，再执行子类的函数修饰this。
```js
// 父类
class Animal {
    constructor(type) {
        this.type = type;
    }
}
// 子类
class Cat extends Animal {
    constructor(name, type) { 
        // 优先调用super()函数执行父类构造函数
        super(type);
        this.name = name;
    }
    getName() {
        return this.name;
    }
}

const cat = new Cat('tom', 'cat');
console.log(cat.type); // cat
console.log(cat.getName()); // tom
```
使用extends关键字不仅可以继承自定义的类，还可以继承原生的内置构造函数。
```js
class MyArr extends Array {
    constructor() {
        super();
    }
    pushItem(item) {
        // 因为继承了Array()构造函数，所以可以直接通过this访问到数组的push()函数
        this.push(item);
    }
}

let arr = new MyArr();
arr.pushItem({ name: 'ming' });
```
父类的静态函数无法被实例继承，但可以被子类继承。子类在访问时同样是通过本身去访问，而不是通过子类实例去访问。
```js
class Parent {
    static staticMethod() {
        return 'hello';
    }
}
class Child extends Parent {}
// 通过子类本身可以访问到父类的静态函数，输出“hello”
console.log(Child.staticMethod());
```
## Module
### 概述
ES6提供了模块化的设计，可以将具有某一类特定功能的代码放在一个文件里，在使用时，只需要引入特定的文件，便可以降低文件之间的耦合性。

相比于早期制定的CommonJS规范，ES6的模块化设计有3点不同。
- CommonJS在运行时完成模块的加载，而ES6模块是在编译时完成模块的加载，效率要更高。
- CommonJS模块是对象，而ES6模块可以是任何数据类型，通过export命令指定输出的内容，并通过import命令引入即可。
- CommonJS模块会在require加载时完成执行，而ES6的模块是动态引用，只在执行时获取模块中的值。

ES6模块核心的内容在于export命令和import命令的使用，两者相辅相成，共同为模块化服务。
### export命令
export命令用于定义模块对外输出的内容，任何你想通过外部文件进行访问的内容，只需要通过export关键字就可以完成。
#### export命令的特性
1. export的是接口，而不是值
不能直接通过export输出变量值，而是需要对外提供接口，必须与模块内部的变量建立一一对应的关系，例如以下写法都是错误的。
```js
let obj = {};
let a = 1;
function foo() {}

export obj;  // 错误写法
export a;  // 错误写法
export foo; // 错误写法

// 需要修改成对象被括起来或者直接导出的形式。
let obj = {};
function foo() {}

export let a = 1; // 正确写法
export {obj}; // 正确写法
export {foo}; // 正确写法
```
2. export值的实时性
export对外输出的接口，在外部模块引用时，是实时获取的，并不是import那个时刻的值。

假如在文件中export一个变量，然后通过定时器修改这个变量的值，那么在其他文件中不同时刻使用import的变量，值也会不同。
```js
// 导出文件export1.js
const name = 'ming2';
// 一秒后修改变量name的值
setTimeout(() => name = 'ming3', 1000);
export { name };

// 导入文件import1.js
import { name } from './export1.js';
console.log(name); // ming2
setTimeout(() => {
  console.log(name); // 'ming3'
}, 1000);
```
### export命令的常见用法
1. 使用as关键字设置别名
如果不想对外暴露内部变量的真实名称，可以使用as关键字设置别名，同一个属性可以设置多个别名。
```js
const _name = 'ming';
export { _name as name };
export { _name as name2 };
```
在外部文件进行引入时，通过name和name2两个变量都可以访问到“ming”值。
2. 相同变量名只能够export一次
在同一个文件中，同一个变量名只能够export一次，否则会抛出异常。
```js
const _name = 'ming';
const name = 'ming';

export { _name as name };
export { name }; // 抛出异常，name作为对外输出的变量，只能export一次
```
3. 尽量统一export
如果文件export的内容有很多，建议都放在文件末尾处统一进行export，这样对export的内容能一目了然。
```js
const name = 'ming';
const age = 12;
const sayHello = function () {
    console.log('hello');
};

export { name, age, sayHello };
```
### import命令
一个模块中使用export命令导出的内容，通过import命令可以引到另一个模块中，两者可以相互配合使用。
如果想要在HTML页面中使用import命令，需要在script标签上使用代码type="module"。
```html
<script type="module"></script>
```
#### import命令的特性
1. 与export的变量名相同
import命令引入的变量需要放在一个大括号里，括成对象的形式，而且import的变量名必须与export的变量名一致。
这点特性在使用了export default命令时会有新的表现形式，在后面我们会具体讲到。
```js
// export.js
const _name = 'ming';
export { _name as name };

// import.js
import { _name } from './export.js'; // 抛出异常
import { name } from './export.js'; // 引入正常
```
2. 相同变量名的值只能import一次
```js
// export1.js
export const name = 'ming';

// export2.js
export const name = 'cat';

// 同时从两个模块中引入name变量，会抛出异常。
import { name } from './export1.js';
import { name } from './export2.js'; // 抛出异常
```
3. import命令具有提升的效果✨
会将import的内容提升到文件头部。
```js
// export.js
export const name = 'ming';

// import.js
console.log(name);  // ming
import {name} from './export.js';
```
在上面的代码中，import语句出现在输出语句的后面，但是仍然能正常输出。本质上是因为import是在编译期运行的，在执行输出代码之前已经执行了import语句。
4. 多次import时，只会一次加载
每个模块只加载一次，每个JS文件只执行一次，如果在同一个文件中多次import相同的模块，则只会执行一次模块文件，后续直接从内存读取。
```js
// export.js
console.log('开始执行');
export const name = 'ming';
export const age = 12;

// import.js
import { name } from './export.js';
import { age } from './export.js';
```
在上面的代码中，import两次export.js文件，但是最终只输出了一次“开始执行”，**可以理解为import导入的模块是个单例模式**。
5. import的值本身是只读的，不可修改
使用import命令导入的值，如果是基本数据类型，那么它们的值是不可以修改的，相当于一个const常量；如果是引用数据类型的值，那么它们的引用本身是不能修改的，只能修改引用对应的值本身。
```js
// export.js
const obj = {
    name: 'ming5'
};
const age = 15;

export { obj, age };

// import.js
import { obj, age } from './export.js';

obj.name = 'ming6'; // 修改引用指向的值，正常
obj = {}; // 抛出异常，不可修改引用指向
age = 15; // 抛出异常，不可修改值本身
```
#### import命令的常见用法
1. 设置引入变量的别名
同样可以使用as关键字为变量设置别名，可以用于解决上一部分中相同变量名import一次的问题。
```js
// export1.js
export const name = 'ming';

// export2.js
export const name = 'cat';

// 使用as关键字设置两个不同的别名，解决了问题
import { name as personName } from './export1.js';
import { name as animalName } from './export2.js';
```
2. 模块整体加载
当需要加载整个模块的内容时，可以使用星号（*）配合as关键字指定一个对象，通过对象去访问各个输出值。
```js
// export.js
const obj = {
    name: 'ming'
};

export const a = 1;
export { obj };

// import.js
import * as a from './export.js';
```
需要注意的是，使用了星号，就不能再使用大括号{}括起来。以下写法是错误的。
```js
import { * as a } from './export.js'; // 错误的写法
```
### export default命令
在之前的讲解中，使用import引入的变量名需要和export导出的变量名一样。在某些情况下，希望不设置变量名也能供import使用，import的变量名由使用方自定义，这时就要使用到export default命令了。
```js
// export.js
const defaultParam = 1;

export default defaultParam;

// import.js
import param from './export.js';
console.log(param); // 1
```
1. 单文件唯一性 
```js
let defaultParam = 1;

export default defaultParam;
export default 2;  // 抛出异常
```
2. import的内容不需要使用大括号括起来
```js
// 表示引入export.js中默认输出的值
import param from './export.js';  
// 表示引入export.js文件中输出的变量名为param的值
import { param } from './export.js文件中';
```
### Module加载的实质
> ES6模块的运行机制是这样的：当遇到import命令时，不会立马去执行模块，而是生成一个动态的模块只读引用，等到需要用到时，才去解析引用对应的值。

由于ES6的模块获取的是实时值，就不存在变量的缓存。
```js
// export.js
export let counter = 1;
export function incCounter() {
    counter++;
}

// import.js
import { counter, incCounter } from './export7.js';

console.log(counter); // 1
incCounter();
console.log(counter); // 2
```
这表明导入的值仍然与原来的模块存在引用关系，并不是完全隔断的。
```js
// 这个引用关系是只读的，不能被修改。
import {counter, incCounter} from './export7.js';
console.log(counter); // 1
counter++; // 抛出异常
```
如果在多个文件中引入相同的模块，则它们获取的是同一个模块的引用。

在export.js文件中定义一个Counter模块，并导出一个Counter的实例，代码如下所示。
```js
function Counter() {
    this.sum = 0;
    this.add = function () {
        this.sum += 1;
    };
    this.show = function () {
        console.log(this.sum);
    };
}

export let c = new Counter();
```
在另外两个模块中分别导入Counter模块，并进行不同处理。
```js
// import1.js
import {c} from './export.js';
c.add();

// import2.js
import {c} from './export.js';
c.show();
```
在一个html文件中引入两个import文件。
```js
import './import1.js';
import './import2.js';
```
通过控制台可以看到，结果输出为“1”。
因为在两个import文件中使用的c变量指向的是同一个引用，在import1.js文件中调用了add()函数，增加了sum变量的值，在import2.js文件中输出sum变量时，值也变为了1。
```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```

```js

```
