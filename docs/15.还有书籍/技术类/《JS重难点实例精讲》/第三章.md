# 函数👍👍👍👍👍

## 函数的定义与调用
### 函数的定义
#### 函数声明
```js
// 函数声明式
function sum(num1, num2) {
   return num1 + num2;
}
```

#### 函数表达式
```js
// 函数表达式
var sum = function (num1, num2) {
   return num1 + num2;
};
```
这个函数表达式没有名称，属于匿名函数表达式。
使用函数声明和匿名函数表达式定义的函数，在进行函数调用时，都只需要使用函数名，传入对应的实际参数（后文简称为实参）即可，示例如下。
```js
console.log(sum(1, 3)); // 4
```
需要注意的是，函数表达式也可以定义具有名称的函数，函数名称即跟在function关键字后的值。
```js
// 具有函数名的函数表达式
var sum = function foo(num1, num2) {
   return num1 + num2;
};
```
其中foo是函数名称，它实际是**函数内部的一个局部变量，在函数外部是无法直接调用**的，示例如下。
```js
console.log(foo(1, 3)); // ReferenceError: foo is not defined
```

#### Function()构造函数
使用new操作符，调用Function构造函数，传入对应的参数，也可以定义一个函数。
```js
// 其中的参数，除了最后一个参数是执行的函数体，其他参数都是函数的形参。
var add = new Function("a", "b", "return a + b");
```

> 相比于函数声明和函数表达式这两种方式，Function()构造函数的使用比较少，主要有以下两个原因。
> - 第一个原因是Function()构造函数每次执行时，都会解析函数主体，并创建一个新的函数对象，所以当在一个循环或者频繁执行的函数中调用Function()构造函数时，效率是非常低的。
> - 第二个原因是使用Function()构造函数创建的函数，并不遵循典型的作用域，它将一直**作为顶级函数执行**。所以在一个函数A内部调用Function()构造函数时，其中的函数体并**不能访问到函数A中的局部变量，而只能访问到全局变量**。

```js
var y = 'global'; // 全局变量
function constructFunction() {
  var y = 'local'; // 局部变量
  return new Function('return y'); // 无法获取局部变量的值
}
console.log(constructFunction()()); // global
```

#### 函数表达式的应用场景
##### 函数递归
通过函数表达式可以定义具有名称的函数，它作为函数内部的一个局部变量，指向函数自身，我们可以利用这一点很好实现递归的功能。
```js
// 斐波那契数列问题
// 通过函数声明实现
function fibonacci(num) {
  if (num === 1 || number === 2) {
    return 1;
  }
  return fibonacci(num - 2) + fibonacci(number - 1);
}
// 通过函数表达式实现
var fibonacci = function(num) {
  if (num === 1 || number === 2) {
    return 1;
  }
  return fibonacci(num - 2) + fibonacci(number - 1);
}
```

##### 代码模块化
在ES6以前，JavaScript中是没有**块级作用域**的，但是我们可以通过函数表达式来间接地实现模块化，将特定的模块代码封装在一个函数中，只对外暴露接口，使用者也不用关心具体细节，这样做可以很好地避免全局环境的污染。
```js
// 立即执行的匿名函数表达式
var person = (function() {
  var _name = "";
  return {
    getName: function() {
      return _name;
    },
    setName: function(newName) {
      _name = newName;
    }
  };
}());
person.setName('ming');
person.getName();
```
返回的是一个对象，只需要调用getName()函数和setName()函数，而不用关心person私有的_name属性。

#### 函数声明与函数表达式的区别
> JavaScript解释器在处理两者时却不一样

##### 函数名称
- 在使用函数声明时，是必须设置函数名称的，这个函数名称**相当于一个变量**，以后函数的调用也会通过这个变量进行。

- 而对于函数表达式来说，**函数名称是可选的**，我们可以定义一个匿名函数表达式，并赋给一个变量，然后通过这个变量进行函数的调用。

```js
// 函数声明，函数名称sum必须设置
function sum(num1, num2) {
  return num1 + num2;
}
// 没有函数名称的匿名函数表达式
var sum = function(num1, num2) {
  return num1 + num2;
}
// 具名函数名的函数表达式，其中foo为函数名称
var sum = function foo(num1, num2) {
  return num1 + num2;
}
```
##### 函数提升
- 对于**函数声明，存在函数提升**，所以即使函数的调用在函数的声明之前，仍然可以正常执行。
- 对于**函数表达式，不存在函数提升**，所以在函数定义之前，不能对其进行调用，否则会抛出异常。
```js
console.log(add(1, 2)); // 3
console.log(sub(5, 3)); // Uncaught TypeError: sub is not a function
// 函数声明
function add(a1, a2) {
  return a1 + a2;
}
// 函数表达式
var sub = function(a1, a2) {
  return a1 - a2;
}
``` 

### 函数的调用
#### 函数调用模式
函数调用模式是通过函数声明或者函数表达式的方式定义函数，然后直接通过函数名调用的模式。
```js
// 函数声明
function add(a1, a2) {
  return a1 + a2;
}
// 函数表达式
var sub = function(a1, a2) {
  return a1 - a2;
}
add(1, 3);
sub(4, 1);
```

#### 方法调用模式👍
方法调用模式会优先定义一个对象obj，然后在对象内部定义值为函数的属性property，通过对象obj.property()来进行函数的调用。
```js
// 定义对象
var obj = {
  name: 'ming',
  // 定义getName属性，值为一个函数
  getName: function() {
    return this.name;
  }
}
obj.getName(); // 通过对象进行调用
obj['getName'](); // 函数还可以通过中括号来调用，即对象名['函数名']。
```
**如果在某个方法中返回的是函数对象本身this**，那么可以利用链式调用原理进行连续的函数调用。
```js
var obj2 = {
  name: 'ming',
  getName: function() {
    console.log(this.name);
  },
  setName: function(name) {
    this.name = name;
    return this; // 在函数内部返回函数对象本身
  }
};
obj2.setName('ming').getName(); // 链式函数调用
```
#### 构造器调用模式
构造器调用模式会定义一个函数，在函数中定义实例属性，在原型上定义函数，然后通过new操作符生成函数的实例，再通过实例调用原型上定义的函数。
```js
// 定义函数对象
function Person(name) {
  this.name = name;
}
// 原型上定义函数
Person.prototype.getName = function() {
  return this.name;
}
// 通过new操作符生成实例
var p = new Person('ming');
// 通过实例进行函数的调用
p.getName();
```
#### call()函数、apply()函数调用模式👍👍👍
通过call()函数或者apply()函数可以**改变函数执行的主体**，使得某些不具有特定函数的对象可以直接调用该特定函数。
```js
function sum(num1, num2) {
  return num1 + num2;
}
var person = {};
// 通过call函数与apply函数调用sum
sum.call(person, 1, 2);
sum.apply(person, [2, 3]);
```
通过call()函数与apply()函数，使得没有sum()函数的person对象也可以直接调用sum()函数

#### 匿名函数调用模式
一种是通过函数表达式定义函数，并赋给变量，通过变量进行调用。
```js
// 通过函数表达式定义匿名函数，并赋给变量sum
var sum = function(num1, num2) {
  return num1 + num2;
}
// 通过sum函数进行匿名函数调用
sum(1, 2);
```
另一种是使用小括号()将匿名函数括起来，然后在后面使用小括号()，传递对应的参数，进行调用。
```js
(function (num1, num2) {
  return num1 + num2;
})(1, 2);
```
使用小括号括住的函数声明实际上是一个函数表达式，紧随其后的小括号表示会立即调用这个函数。
```js
function (num1, num2) {
  return num1 + num2;
}(1, 2); // Uncaught SyntaxError: Unexpected token (
```
因为JavaScript解释器在解析语句时，会将function关键字当作函数声明的开始，函数的声明是需要有函数名称的，而上面的代码却并没有函数名称，所以会抛出语法异常。
```js
// 写上呢
function sum(num1, num2) {
  console.log(num1 + num2);
}(1, 2); // 2
```
实际上，在函数声明后增加的小括号相当于一个分组操作符，两部分内容是完全独立的，并不会起到立即执行的作用，与下列语句等价。
```js
// 函数声明
function sum(num1, num2) {
   console.log(num1 + num2);
}
// (逗号)表达式
(1, 2); // 2
```
如何才可以呢？
```js
var sum = function(num1, num2) {
  return num1 + num2;
}(1, 2);
console.log(sum); // 3
// 这部分表示的是函数立即执行。
function(num1, num2) {
  return num1 + num2;
}(1, 2);
```
```js
// 实名立即调用函数
(function sum(num1, num2) {
   console.log(num1 + num2);
}(1, 2));
```

### 自执行函数
> 自执行函数即函数定义和函数调用的行为先后连续产生。
它需要以一个函数表达式的身份进行函数调用，
匿名函数调用也属于自执行函数的一种。
```js
function (x) {
  alert(x);
}(5); // Uncaught SyntaxError: Unexpected token (

var aa = function(x) {
  console.log(x);
}(1); // 1

true && function (x) {
  console.log(x);
}(2); // 2

0, function(x) {
  console.log(x);
}(3); // 3

!function(x) {
  console.log(x);
}(4); // 4

~function(x) {
  console.log(x);
}(5); // 5

-function(x) {
  console.log(x);
}(6); // 6

+function(x) {
  console.log(x);
}(7); // 7

new function() {
  console.log(8); // 8
};

new function(x) {
  console.log(x); 
}(9); // 9
```

## 函数参数
### 形参和实参
- 形参全称为形式参数，是在定义函数名称与函数体时使用的参数，目的是用来接收调用该函数时传入的参数。
- 实参全称为实际参数，是在调用时传递给函数的参数，实参可以是常量、变量、表达式、函数等类型。

#### 区别
1. 形参出现在函数的定义中，只能在函数体内使用，一旦离开该函数则不能使用；实参出现在主调函数中，进入被调函数后，实参也将不能被访问。
```js
function fn1() {
  var param = 'hello';
  fn2(param);
  console.log(arg); // 在主调函数中不能访问到形参arg，会抛出异常
}
function fn2(arg) {
  console.log(arg); // 在函数体内能访问到形参arg，输出'hello'
  console.log(params); // 在函数体内不能访问到实参param, 会抛出异常。
}
fn1();
```

2. 在**强类型语言**中，定义的形参和实参在数量、数据类型和顺序上要保持严格一致，否则会抛出“类型不匹配”的异常
3. 在函数调用过程中，数据传输是单向的，即只能把实参的值传递给形参，而不能把形参的值反向传递给实参。因此在函数执行时，形参的值可能会发生变化，但不会影响到实参中的值。
```js
var arg = 1;
function fn(param) {
  param = 2;
}
fn(arg);
console.log(arg); // 1，实参的值不变
```
4. 当实参是基本数据类型的值时，实际是将实参的值复制一份传递给形参，在函数运行结束时形参被释放，而实参中的值不会变化。当实参是引用类型的值时，实际是将实参的内存地址传递给形参，即实参和形参都指向相同的内存地址，此时形参可以修改实参的值，但是不能修改实参的内存地址。🚩
```js
var arg = { name: 'ming' };
function fn(param) {
  param.name = 'heisming'; // 改变实参的值
  param = {}; // 改变形参的地址
}
fn(arg);
console.log(arg); // { name: 'heisming' }
```
JavaScript是一门弱类型的语言，函数参数在遵循上述规则的基础上，还具有以下几个特性。
- 函数可以不用定义形参，可以在函数体中通过arguments对象获取传递的实参并进行处理。
- 在函数定义了形参的情况下，传递的实参与形参的个数并不需要相同，实参与形参会从前到后匹配，未匹配到的形参被当作undefined处理。
- 实参并不需要与形参的数据类型一致，因为形参的数据类型只有在执行期间才能确定，并且还存在隐式数据类型的转换。

### arguments对象的实质
> arguments对象是所有函数都具有的一个内置局部变量，表示的是函数实际接收的参数，是一个类数组结构(因为它除了具有length属性外，不具有数组的一些常用方法。)。
#### 函数外部无法访问
arguments对象存在于函数级作用域中，一个函数无法直接获取另一个函数的arguments对象。
```js
console.log(type arguments); // undefined
function foo() {
  console.log(arguments.length); // 3
  function foo2() {
    console.log(arguments.length); // 0
  }   
  foo2();
}
foo(1, 2, 3);
```
#### 可通过索引访问
arguments对象是一个类数组结构，可以通过索引访问，每一项表示对应传递的实参值，如果该项索引值不存在，则会返回“undefined”。
```js
function sum(num1, num2) {
   console.log(arguments[0]);  // 3
   console.log(arguments[1]);  // 4
   console.log(arguments[2]);  // undefined
}
sum(3, 4);
```
#### 由实参决定
> arguments对象的值由实参决定，而不是由定义的形参决定，形参与arguments对象占用独立的内存空间。

arguments对象与形参之间的关系，可以总结为以下几点。
- arguments对象的length属性在函数调用的时候就已经确定，不会随着函数的处理而改变。
- 指定的形参在传递实参的情况下，arguments对象与形参值相同，并且可以相互改变。
- 指定的形参在未传递实参的情况下，arguments对象对应索引值返回“undefined”。
- 指定的形参在未传递实参的情况下，arguments对象与形参值不能相互改变。
```js
function foo(a, b, c) {
  console.log(arguments.length); // 2
  arguments[0] = 11;
  console.log(a); // 1
  b = 12;
  console.log(arguments[1]); // 12
  arguments[2] = 3;
  console.log(c); // undefined
  c = 13;
  console.log(arguments[2]); // 3
  console.log(arguments.length); // 2
}
foo(1, 2);
```
#### 特殊的arguments.callee属性👍👍👍👍👍
表示的是当前正在执行的函数，在比较时是严格相等的。
```js
function foo() {
  console.log(arguments.callee === foo); // true
}
foo();
```
通过arguments.callee属性获取到函数对象后，可以直接传递参数重新进行函数的调用，这个属性在匿名的递归函数中非常有用。
```js
function create() {
  return function(n) {
    if (n <= 1) {
      return 1;
    }
    return n * arguments.callee(n - 1);
  }
}
var result = create()(5); // return 120 (5 * 4 * 3 * 2 * 1)
```
不推荐广泛使用arguments.callee属性，其中有一个主要原因是使用arguments.callee属性后会改变函数内部的this值。
```js
var sillyFunction = function (recursed) {
  if(!recursed) {
    console.log(this); // Window {}
    return arguments.callee(true);
  }
  console.log(this); // Arguments {}
}
sillyFunction();
```
如果需要在函数内部进行递归调用，推荐使用函数声明或者使用函数表达式，给函数一个明确的函数名。
#### arguments对象的应用
##### 实参的个数判断
```js
function f(x, y, z) {
   // 检查传递的参数个数是否正确
   if (arguments.length !== 3) {
       throw new Error("期望传递的参数个数为3，实际传递个数为" + arguments.length);
   }
   // ...do something
}
f(1, 2); // Uncaught Error: 期望传递的参数个数为3，实际传递个数为2
```
##### 任意个数的参数处理
定义一个函数，该函数只会特定处理传递的前几个参数，对于后面的参数不论传递多少个都会统一处理，这种场景下我们可以使用arguments对象。
```js
function joinStr(seperator) {
  // arguments对象是一个类数组结构，可以通过call函数间接调用slice函数，得到一个数组
  var strArr = Array.prototype.slice.call(arguments, 1);
  // strArr数组直接调用join函数
  return strArr.join(seperator);
}
joinStr('-', 'orange', 'apple', 'banana');
joinStr(',', 'orange', 'apple', 'banana');
```
##### 模拟函数重载
在函数名相同的情况下，通过函数形参的不同参数类型或者不同参数个数来定义不同的函数。

在JavaScript中是没有函数重载的，主要有以下几点原因。
- JavaScript是一门弱类型的语言，变量只有在使用时才能确定数据类型，通过形参是无法确定数据类型的。
- 无法通过函数的参数个数来指定调用不同的函数，函数的参数个数是在函数调用时才确定下来的。
- 使用函数声明定义的具有相同名称的函数，后者会覆盖前者。
```js
function sum(num1, num2) {
  return num1 + num2;
}
function sum(num1, num2, num3) {
  return num1 + num2 + num3;
}
sum(1, 2); // 1 + 2 + undefined = NaN
sum(1, 2, 3); // 6
```
使用arguments对象处理传递的参数。
```js
// 通用的求和函数
function sum() {
  // 通过call函数间接调用数组的slice函数得到函数参数的数组
  var arr = Array.prototype.slice.call(arguments);
  // 调用数组的reduce函数进行多个值的求和
  return arr.reduce(function (pre, cur) {
    return pre + cur;
  }, 0)
}
sum(1, 2); // 3
sum(1, 2, 3); // 6
sum(1, 2, 3, 4); // 10
```
## 构造函数
当我们创建对象的实例时，通常会使用到构造函数，例如对象和数组的实例化可以通过相应的构造函数Object()和Array()完成。

构造函数与普通函数在语法的定义上没有任何区别，主要的区别体现在以下3点。
- 构造函数的函数名的第一个字母通常会大写。
- 在函数体内部使用this关键字，表示要生成的对象实例，构造函数并不会显式地返回任何值，而是默认返回“this”。
```js
function Person(name) {
  this.name = name;
}
var p = new Person('ming');
console.log(p); // Person { name: "ming" }
```
- 作为构造函数调用时，必须与new操作符配合使用。
一个函数只有在配合new操作符调用时才能当作一个构造函数，如果不使用new操作符，则只是一个普通函数。
```js
// 一个函数在当作构造函数使用时，能通过new操作符创建对象的实例，并通过实例调用对应的函数。
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayName = function() {
    alert(this.name);
  };
}
var person = new Person('ming', 22);
person.sayName(); // 'ming'
// 一个函数在当作普通函数使用时，函数内部的this会指向window。
Person('ming', 12)
window.sayName(); // ming
```
构造函数在执行创造对象实例时会执行以下4步。
- 通过new操作符创建一个新的对象，在内存中创建一个新的地址。
- 为构造函数中的this确定指向。
- 执行构造函数代码，为实例添加属性。
- 返回这个新创建的对象。

以前面生成person实例的代码为例。
第一步：为person实例在内存中创建一个新的地址。
第二步：确定person实例的this指向，指向person本身。
第三步：为person实例添加name、age和sayName属性，其中sayName属性值是一个函数。
第四步：返回这个person实例。

缺点：即对函数的处理。
在构造函数中为this添加了一个sayName属性，它的值为一个函数，这样在每次创建一个新的实例时，都会给实例新增一个sayName属性，而且不同实例中的sayName属性是不同的。
```js
var person1 = new Person();
var person2 = new Person();
console.log(person1.sayName === person2.sayName); // false
```
> 设置全局访问函数会污染作用域，使用原型即可解决。
## 变量提升与函数提升
一个函数体内，变量在定义之前就可以被访问到，而不会抛出异常。
```js
function fn() {
  console.log(a); // undefined
  var a = 1;
}
```
函数也有类似的表现，函数在定义之前就可以被调用，而不会抛出异常。
```js
fn();
function fn() {
  console.log('out'); // out
}
```
### 作用域
在JavaScript中，一个变量的定义与调用都是会在一个固定的范围中的，这个范围我们称之为作用域。
作用域可以分为全局作用域、函数作用域和块级作用域(ES6：let/const)。
- 全局作用域：如果变量定义在全局环境中，那么在任何位置都可以访问到这个变量；
- 函数作用域：如果变量定义在函数内部，那么只能在函数内部访问到这个变量；
- 块级作用域：如果变量定义在一个代码块中，那么只能在代码块中访问到这个变量。
```js
// 全局作用域内的变量a
var a = 'global variable';
function foo() {
  // 函数作用域内的变量b
  var b = 'function variable';
  console.log(a); // global variable
  console.log(b); // function variable
}
// 块级作用域内的变量c
{
  let c = 'block variable';
  console.log(c); // block variable
}
console.log(c); // Uncaught ReferenceError: c is not defined
```
在函数内部**使用var定义的变量**
#### 代码1
```js
var v = 'Hello World';
(function() {
  console.log(v); // Hello World
})();
```
#### 代码2
```js
var v = 'Hello World';
(function() {
  // var v;
  console.log(v); // undefined
  var v = 'Hello JM'; // v = 'Hello JM'
})();
```
### 变量提升
变量提升（必须是通过var关键字）是将变量的声明提升到函数顶部的位置，而**变量的赋值并不会被提升**。
```js
(function () {
  console.log(v); // Uncaught ReferenceError: v is not defined
  v = 'Hello JM';
})
```
#### [代码1的执行过程](#代码1)
在全局对象window上定义一个变量v，并赋值为Hello World。然后定义一个立即执行函数，这个立即执行函数的作用域为window。在函数内部引用变量v，然后会顺着作用域寻找，最终会在window上找到这个变量v，因此输出“Hello World”。
#### [代码2的执行过程](#代码2)
出现了变量提升，在立即执行函数的内部，变量v的定义会提升到函数顶部，实际执行过程的代码如下所示。
```js
var v = 'Hello World';
(function () {
  var v;   // 变量的声明得到提升  
  console.log(v);
  v = 'Hello JavaScript';  // 变量的赋值并未提升
})();
```
### 函数提升
使用函数声明方式定义的函数也会出现提升。
```js
foo(); // foo()函数被提升至作用域顶部
function foo() {
  console.log('I am come from foo');
}
// 相当于
function foo() {
   console.log("我来自 foo");
}
foo();  // 我来自 foo
```
> 需要注意的是函数提升会将整个函数体一起进行提升，包括里面的执行逻辑。
> 而对于函数表达式，是不会进行函数提升的。
```js
foo();  // Uncaught TypeError: foo is not a function
var foo = function () {
  console.log('我自来 foo');
};
```
两者同时使用时的情况
```js
show(); // hello
var show;
// 函数声明，会被提升
function show() {
  console.log('hello');
}
// 函数表达式，不会被提升
show = function() {
  console.log('world');
}
```
### 变量提升与函数提升的应用
#### 关于函数提升
```js
function foo() {
  function bar() {
    return 3;
  }
  return bar();
}
function bar() {
  return 8;
}
console.log(foo()); // 3

function foo() {
  function bar() {
    return 3;
  }
  return bar();
  function bar() {
    return 8;
  }
}
console.log(foo()); // 8
```
由于变量提升的存在，两段代码都会被提升至foo()函数的顶部，而且后一个函数会覆盖前一个bar()函数，因此最后输出值为“8”。
#### 变量提升和函数提升同时使用
```js
var a = true;
foo(); // 函数提升正常调用
function foo() {
  if (a) {
    var a = 10;
  }
  console.log(a); // undefined
}
// 执行过程
var a;
a = true;
function foo() {
  var a;
  if (a) {
    a = 10;
  }
  console.log(a); // undefined
}
foo();
```
#### 变量提升和函数提升优先级👍👍👍
```js
function fn() {
  console.log(typeof foo); // function
  // 变量提升
  var foo = 'variable';
  // 函数提升
  function foo() {
    return 'function';
  }
  console.log(typeof foo); // string
}
fn();
```
**变量提升的优先级要比函数提升的优先级高**，因此实际执行过程可以改写为以下代码段。
```js
function fn() {
  // 变量提升至函数顶部
  var foo;
  // 函数提升，但是优先级低，出现在变量声明后面，则foo是一个函数
  function foo() {
    return 'function';
  }
  console.log(typeof foo); // function
  foo = 'variable';
  console.log(typeof foo); // string
}
```
#### 变量提升和函数提升整体应用👍👍👍
```js
function foo() {
  var a = 1;
  function b() {
    a = 10;
    return;
    function a() {} // 变量a的函数声明，则会进行提升
  }
  b();
  console.log(a); // 1
}
foo();
```
整体执行过程可以改写为以下代码段。
```js
function foo() {
  // 变量a的提升
  var a;
  // 函数声明b的提升
  function b() {
    // 内部的函数声明a的提升
    function a() {}
    a = 10;
    return;
  }
  a = 1;
  b();
  console.log(a); // 1
}
foo();
```
> `以上知识点没啥卵用`，无论变量还是函数，都做到先声明后使用。
```js
// 定义变量
var name = 'Scott';
// 先定义函数
var sayHello = function(guest) {
   console.log(name, 'says hello to', guest);
};
// 预先定义将要使用到的变量
var i;
var guest;
var guests = ['John', 'Tom', 'Jack'];
for (i = 0; i < guests.length; i++) {
   // 使用变量
   guest = guests[i];
   // 使用预先定义的sayHello()函数
  sayHello(guest);
}
```
ES6
```js
const name = 'Scott';
let sayHello = function(guest) {
   console.log(name, 'says hello to', guest);
};

let guests = ['John', 'Tom', 'Jack'];

for (let i = 0; i < guests.length; i++) {
   let guest = guests[i];
   sayHello(guest);
}
```
## 闭包
在正常情况下，如果定义了一个函数，就会产生一个函数作用域，在函数体中的局部变量会在这个函数作用域中使用。一旦函数执行完成，函数所占空间就会被回收，存在于函数体中的局部变量同样会被回收，回收后将不能被访问到。
期望在函数执行完成后，函数中的局部变量仍然可以被访问到，这能不能实现呢？
### 执行上下文环境👍👍👍👍👍
JavaScript每段代码的执行都会存在于一个执行上下文环境中，而任何一个执行上下文环境都会存在于整体的执行上下文环境中。根据栈先进后出的特点，全局环境产生的执行上下文环境会最先压入栈中，存在于栈底。当新的函数进行调用时，会产生的新的执行上下文环境，也会压入栈中。当函数调用完成后，这个上下文环境及其中的数据都会被销毁，并弹出栈，从而进入之前的执行上下文环境中。

处于活跃状态的执行上下文环境只能同时有一个：
全局上下文环境  === 压栈 ===> 函数上下文环境or全局上下文环境 === 出栈（销毁） ===> 全局上下文环境
```js
1  var a = 10;    // 1.进入全局执行上下文环境
2  var fn = function (x) {
3      var c = 10;
4      console.log(c + x);
5  };
6  var bar = function (y) {
7      var b = 5;
8      fn(y + b);  // 3.进入fn()函数执行上下文环境
9  };
10 bar(20);  // 2.进入bar()函数执行上下文环境
```
从第1行代码开始，进入全局执行上下文环境，此时执行上下文环境中只存在全局执行上下文环境。
```js
     执行上下文环境
|                     |
|                     |
|                     |
|   全局执行上下文环境  |  <---- 活跃状态的上下文环境
 ____________________
```
当代码执行到第10行时，调用bar()函数，进入bar()函数执行上下文环境中。
```js
    执行上下文环境
|                        |
|                        |
|  bar()函数执行上下文环境 |   <---- 活跃状态的上下文环境
|    全局执行上下文环境    |
 ______________________
```
执行到第8行时，调用fn()函数，进入fn()函数执行上下文环境中。
```js
     执行上下文环境
|                        |
|   fn函数执行上下文环境   |   <---- 活跃状态的上下文环境
|   bar函数执行上下文环境  |
|    全局执行上下文环境    |
 ______________________
```
进入fn()函数中，执行完第5行代码后，fn()函数执行上下文环境将会被销毁，从而弹出栈。
```js
     执行上下文环境
|                        |
|                        |
|   bar函数执行上下文环境  |   <---- 活跃状态的上下文环境
|    全局执行上下文环境    |
 ______________________
```
fn()函数执行上下文环境被销毁后，回到bar()函数执行上下文环境中，执行完第9行代码后，bar()函数执行上下文环境也将被销毁，从而弹出栈
```js
     执行上下文环境
|                     |
|                     |
|                     |
|   全局执行上下文环境  |  <---- 活跃状态的上下文环境
 ____________________
```
最后全局上下文环境执行完毕，栈被清空，流程执行结束。
像上面这种代码执行完毕，执行上下文环境就会被销毁的场景，是一种比较理想的情况。
有另外一种情况，虽然代码执行完毕，但执行上下文环境却被无法干净地销毁，这就是我们要讲到的闭包。

> 个人理解有点像--(-(-(-)-)-)-->洋葱圈模型。

### 闭包的概念
> 官方通用的解释：一个拥有许多变量和绑定了这些变量执行上下文环境的表达式，通常是一个函数。

闭包有两个很明显的特点。
- 函数拥有的外部变量的引用，在函数返回时，该变量仍然处于活跃状态。
- 闭包作为一个函数返回时，其执行上下文环境不会被销毁，仍处于执行上下文环境中。

在JavaScript中存在一种内部函数，即函数声明和函数表达式可以位于另一个函数的函数体内，在内部函数中可以访问外部函数声明的变量，当这个内部函数在包含它们的外部函数之外被调用时，就会形成闭包。
```js
1  function fn() {
2      var max = 10;
3      return function bar(x) 
4          if (x > max) {
5              console.log(x);
6          }
7      };
8  }
9  var f1 = fn();
10 f1(11);  // 11
```
代码开始执行后，生成全局上下文环境，并将其压入栈中。
```js
    执行上下文环境
|                    |
|                    |
|                    |
|  全局执行上下文环境  |  <---- 活跃状态的上下文环境
 ____________________
```
代码执行到第9行时，进入fn()函数中，生成fn()函数执行上下文环境，并将其压入栈中。
```js
     执行上下文环境
|                       |
|                       |
|  fn函数执行上下文环境   |   <---- 活跃状态的上下文环境
|   全局执行上下文环境    |
 ______________________
```
fn()函数返回一个bar()函数，并将其赋给变量f1。

当代码执行到第10行时，调用f1()函数，注意此时是一个关键的节点，因为f1()函数中包含了对max变量的引用，而max变量是存在于外部函数fn()中的，此时fn()函数执行上下文环境并不会被直接销毁，依然存在于执行上下文环境中。
```js
      执行上下文环境
|                         |
|   bar函数执行上下文环境   |   <---- 活跃状态的上下文环境
|   fn函数执行上下文环境    |   
|   全局执行上下文环境      |
 ___________________________
```
等到第10行代码执行结束后，bar()函数执行完毕，bar()函数执行上下文环境才会被销毁，同时因为max变量引用会被释放，fn()函数执行上下文环境也一同被销毁。
最后全局上下文环境执行完毕，栈被清空，流程执行结束。
> 从分析就可以看出闭包所存在的最大的一个问题就是消耗内存，如果闭包使用越来越多，内存消耗将越来越大。
### 闭包的用途
> 写出一些更加简洁优雅的代码，并且能在某些方面提升代码的执行效率。
#### 结果缓存
假如有一个处理很耗时的函数对象，每次调用都会消耗很长时间。
可以将其处理结果在内存中缓存起来。这样在执行代码时，如果内存中有，则直接返回；如果内存中没有，则调用函数进行计算，更新缓存并返回结果。
因为闭包不会释放外部变量的引用，所以能将外部变量值缓存在内存中。
```js
var cachedBox = (function () {
  // 缓存的容器
  var cache = {};
  return {
    searchBox: function (id) {
      // 如果在内存中，则直接返回
      if (id in cache) {
        return '查找的结果为：' + cache[id];
      }
      // 经过一段很耗时的dealFn()函数处理
      var result = dealFn(id);
      // 更新缓存的结果
      cache[id] = result;
      // 返回计算的结果
      return '查找的结果为：' + result;
    }
  };
})();

// 很耗时的函数
function dealFn(id) {
  console.log('耗时操作');
  return id;
}
console.log(cachedBox.searchBox(1)); // 耗时操作 查找的结果为：1
console.log(cachedBox.searchBox(1)); // 查找的结果为：1
```
在上面的代码中，末尾两次调用searchBox(1)()函数，在第一次调用时，id为1的值并未在缓存对象cache中，因为会执行很耗时的函数，输出的结果为“1”。

而第二次执行searchBox(1)函数时，由于第一次已经将结果更新到cache对象中，并且该对象引用并未被回收，因此会直接从内存的cache对象中读取，直接返回“1”，最后输出的结果为“1”。
#### 封装
在JavaScript中提倡的模块化思想是希望将具有一定特征的属性封装到一起，只需要对外暴露对应的函数，并不关心内部逻辑的实现。
```js
var stack = (function () {
  // 使用数组模仿栈的实现
  var arr = [];
  // 栈
  return {
    // 只对外暴露出表示入栈和出栈的push()函数和pop()函数，以及表示栈长度的size()函数。
    push: function (value) {
      arr.push(value);
    },
    pop: function () {
      return arr.pop();
    },
    size: function () {
      return arr.length;
    }
  };
})();
stack.push('abc');
stack.push('def');
console.log(stack.size()); // 2
stack.pop();
console.log(stack.size()); // 1
```
上面的代码中存在一个立即执行函数，在函数内部会产生一个执行上下文环境，最后返回一个表示栈的对象并赋给stack变量。在匿名函数执行完毕后，其执行上下文环境并不会被销毁，因为在对象的push()、pop()、size()等函数中包含了对arr变量的引用，arr变量会继续存在于内存中，所以后面几次对stack变量的操作会使stack变量的长度产生变化。
##### ul中有若干个li，每次单击li，输出li的索引值
```html
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
</ul>
<script>
  var list = document.getElementsByTagName('ul')[0].children;
  for (var i = 0; i < list.length; i++) {
    list[i].onclick = function () {
      console.log(i); // 5
    }
  }
// 因为在我们单击li，触发li的click事件之前，for循环已经执行结束了，而for循环束的条件就是最后一次i++执行完毕，此时i的值为5，所以每次单击li后返回的都是“5”。
</script>
```
使用闭包解决
```js
var list = document.getElementsByTagName('ul')[0].children;
for (var i = 0; i < list.length; i++) {
  (function(index) {
    list[index].onclick = function () {
      console.log(index); // 1 ~ 5
    };
  })(i);
}
// 在每一轮的for循环中，我们将索引值i传入一个匿名立即执行函数中，在该匿名函数中存在对外部变量lis的引用，因此会形成一个闭包。而闭包中的变量index，即外部传入的i值会继续存在于内存中，所以当单击li时，就会输出对应的索引index值。
```
##### 定时器问题
```js
var arr = ['one', 'two', 'three'];
for (var i = 0; i < arr.length; i++) {
  setTimeout(function (){
    console.log(arr[i]); // undefined
  }, i * 1000); // 1000
}
```
setTimeout()函数与for循环在调用时会产生两个独立执行上下文环境，当setTimeout()函数内部的函数执行时，for循环已经执行结束，而for循环结束的条件是最后一次i++执行完毕，此时i的值为3，所以实际上setTimeout()函数每次执行时，都会输出arr[3]的值。而因为arr数组最大索引值为2，所以会间隔一秒输出“undefined”。
```js
// 使用闭包
var arr = ['one', 'two', 'three'];
for (var i = 0; i < arr.length; i++) {
  (function(index){
    setTimeout(function (){
      console.log(arr[index]); // one two three
    }, index * 1000); // 0 1000 2000 
  })(i);
}
```
通过立即执行函数将索引i作为参数传入，在立即函数执行完成后，由于setTimeout()函数中有对arr变量的引用，其执行上下文环境不会被销毁，因此对应的i值都会存在内存中。所以每次执行setTimeout()函数时，i都会是数组对应的索引值0、1、2，从而间隔一秒输出“one”“two”“three”。
##### 作用域链问题
> 闭包往往会涉及作用域链问题，尤其是包含this属性时。
```js
var name = 'outer';
var obj = {
  name: 'inner',
  method: function () {
    return function () {
      return this.name;
    }
  }
}
console.log(obj.method()()); // outer
```
在调用obj.method()函数时，会返回一个匿名函数，而该匿名函数中返回的是this.name，因为引用到了this属性，在匿名函数中，this相当于一个外部变量，所以会形成一个闭包。

**在JavaScript中，this指向的永远是函数的调用实体**，而匿名函数的实体是全局对象window，因此会输出全局变量name的值“outer”。

```js
// 再看看
var name = 'outer';
var obj = {
  name: 'inner',
  method: function () {
    // 用self保存obj中的this
    var self = this;
    return function () {
      return self.name;
    }
  }
}
console.log(obj.method()()); // inner
```
在method()函数中利用_this变量保存obj对象中的this，在匿名函数的返回值中再去调用_this.name，此时_this就指向obj对象了，因此会输出“inner”。
##### 多个相同函数名问题👍👍👍
```js
// 第一个foo()函数
// 首先最外层的foo()函数是一个具名函数，返回的是一个具体的对象。
function foo(a, b) {
   console.log(b);
   return {
      // 第二个foo()函数
      // 第二个foo()函数是最外层foo()函数返回对象的一个属性，该属性指向一个匿名函数。
       foo: function (c) {
          // 第三个foo()函数
          // 第三个foo()函数是一个被返回的函数，该foo()函数会沿着原型链向上查找，而foo()函数在局部环境中并未定义，最终会指向最外层的第一个foo()函数，因此第三个和第一个foo()函数实际是指向同一个函数。
          return foo(c, a);
       }
   }
}
var x = foo(0); x.foo(1); x.foo(2); x.foo(3);
var y = foo(0).foo(1).foo(2).foo(3);
var z = foo(0).foo(1); z.foo(2); z.foo(3);
```
在上面的代码中，出现了3个具有相同函数名的foo()函数，返回的第三个foo()函数中包含了对第一个foo()函数参数a的引用，因此会形成一个闭包。

具体的执行过程。
```js
var x = foo(0); x.foo(1); x.foo(2); x.foo(3); // 第一行输出结果为“undefined，0，0，0”。
```
（1）在执行foo(0)时，未传递b值，所以输出“undefined”，并返回一个对象，将其赋给变量x。
在执行x.foo(1)时，foo()函数闭包了外层的a值，就是第一次调用的0，此时c=1，因为第三层和第一层为同一个函数，所以实际调用为第一层的的foo(1, 0)，此时a为1，b为0，输出“0”。
执行x.foo(2)和x.foo(3)时，和x.foo(1)是相同的原理，因此都会输出“0”。
```js
var y = foo(0).foo(1).foo(2).foo(3); // 第二行输出结果为“undefined，0，1，2”。
```
（2）在执行foo(0)时，未传递b值，所以输出“undefined”，紧接着进行链式调用foo(1)，其实这部分与（1）中的第二部分分析一样，实际调用为foo(1, 0)，此时a为1，b为0，会输出“0”。
foo(1)执行后返回的是一个对象，其中闭包了变量a的值为1，当foo(2)执行时，实际是返回foo(2, 1)，此时的foo()函数指向第一个函数，因此会执行一次foo(2, 1)，此时a为2，b为1，输出“1”。
foo(2)执行后返回一个对象，其中闭包了变量a的值为2，当foo(3)执行时，实际是返回foo(3, 2)，因此会执行一次foo(3,2)，此时a为3，b为2，输出“2”。
```js
var z = foo(0).foo(1); z.foo(2); z.foo(3);  // 第三行输出结果为“undefined，0，1，1”。
```
前两步foo(0).foo(1)的执行结果与（1）、（2）的分析相同，输出“undefined”和“0”。
foo(0).foo(1)执行完毕后，返回的是一个对象，其中闭包了变量a的值为1，当调用z.foo(2)时，实际是返回foo(2, 1)，因此会执行foo(2, 1)，此时a为2，b为1，输出“1”。
执行z.foo(3)时，与z.foo(2)一样，实际是返回foo(3, 1)，因此会执行foo(3, 1)，此时a为3，b为1，输出“1”。

#### 总结
闭包如果使用合理，在一定程度上能提高代码执行效率；如果使用不合理，则会造成内存浪费，性能下降。接下来说说闭包的优点和缺点。
##### 闭包的优点
- 保护函数内变量的安全，实现封装，防止变量流入其他环境发生命名冲突，造成环境污染。
- 在适当的时候，可以在内存中维护变量并缓存，提高执行效率。
##### 闭包的缺点
- 消耗内存：通常来说，函数的活动对象会随着执行上下文环境一起被销毁，但是，由于闭包引用的是外部函数的活动对象，因此这个活动对象无法被销毁，这意味着，闭包比一般的函数需要消耗更多的内存。
- 泄漏内存：在IE9之前，如果闭包的作用域链中存在DOM对象，则意味着该DOM对象无法被销毁，造成内存泄漏。
```js
function closure () {
  var element = document.getElementById('elementId');
  element.onclick = function () {
    console.log(element.id);
  }
}
```
在closure()函数中，给一个element元素绑定了click事件，而在这个click事件中，输出了element元素的id属性，即在onclick()函数的闭包中存在了对外部元素element的引用，那么该element元素在网页关闭之前会一直存在于内存之中，不会被释放。
如果这样的事件处理的函数很多，将会导致大量内存被占用，进而严重影响性能。

对应的解决办法是：先将需要使用的属性使用临时变量进行存储，然后在事件处理函数时使用临时变量进行操作；此时闭包中虽然不直接引用element元素，但是对id值的调用仍然会导致element元素的引用被保存，此时应该手动将element元素设置为null。
```js
function closure () {
  var element = document.getElementById('elementId');
  // 使用临时变量存储
  var id = element.id;
  element.onclick = function () {
    console.log(element.id);
  }
  // 手动将元素设置为null
  element = null;
}
```
## this的使用
当创建一个构造函数的实例时，需要使用new操作符，函数执行完成后，函数体中的this就指向了这个实例，通过下面这个实例可以访问到绑定在this上的属性。
```js
function Person(name) {
   this.name = name;
}
var p = new Person('ming');
console.log(p.name);  // 'ming'
```
假如我们将Person()函数当作一个普通的函数执行，函数体中的this指向了window对象。 
```js
function Person(name) {
  this.name = name; // this指向window
}
Person('ming'); // 当做普通的功函数执行
console.log(window.name) // ming
```
在java、c++等面向对象的语言中，this指向的是当前类的实例对象。
==而在JavaScript中，this的指向是随着宿主环境的变化而变化的，在不同的地方调用，返回的可能是不同的结果。==

在大多数场景中，随着函数的执行，就会产生一个this值，这个this存储着调用该函数的对象的值。因此可以结论先行，`在JavaScript中，this指向的永远是函数的调用者`。
### this指向全局对象
当函数没有所属对象而直接调用时，this指向的是全局对象
```js
var value = 10; // window.value = 10。
var obj = {
  value: 100,
  method: function () {
    var foo = function () {
      console.log(this.value); // 10
      console.log(this); // Window对象
    }
    foo();
    return this.value;
  };
}
console.log(obj.method()); // 100
```
- 首先定义一个全局的value属性为10，相当于window.value = 10。
- 然后定义一个obj对象，设置了value属性值为100，然后设置method属性为一个函数，其method属性中定义了一个函数表达式foo，并执行了foo()函数，最终返回value属性。
- 当调用obj.method()函数时，foo()函数被执行，但是此时foo()函数的执行是没有所属对象的，因此this会指向全局的window对象，在输出this.value时，实际是输出window.value，因此输出“10”。
- 而method()函数的返回值是this.value，method()函数的调用体是obj对象，此时this就指向obj对象，而obj.value = 100，因此调用obj.method()函数后会返回“100”。

### this指向所属对象
obj.method()函数的返回值是this.value，method()函数的调用体是obj对象，此时this就指向obj对象，而obj.value =100，因此会输出“100”。
```js
console.log(obj.method()); // 100
```
### this指向对象实例
当通过new操作符调用构造函数生成对象的实例时，this指向该实例。
```js
var number = 10; // 全局变量
function Person() {
  number = 20; // 复写全局变量
  this.number = 30; // 实例变量
}
// 原型函数
Person.prototype.getNumber = function () {
  return this.number;
}
// 通过new操作符获取对象的实例
var p = new Person();
console.log(p.getNumber()); // 30
```
在上面这段代码中，定义了全局变量number和实例变量number，通过new操作符生成Person对象的实例p后，在调用getNumber()操作时，其中的this就指向该实例p，而实例p在初始化的时候被赋予number值为30，因此最后会输出“30”。
### this指向call()函数、apply()函数、bind()函数调用后重新绑定的对象
通过call()函数、apply()函数、bind()函数可以改变函数执行的主体，如果函数中存在this关键字，则this也将会指向call()函数、apply()函数、bind()函数处理后的对象。
```js
var value = 10; // 全局变量
var obj = {
   value: 20
};
// 全局函数
var method = function () {
   console.log(this.value);
};

method();  // 10
method.call(obj);  // 20
method.apply(obj); // 20

var newMethod = method.bind(obj);
newMethod();  // 20
```
- 在上面这段代码中，定义了全局变量value和带有value属性的obj对象，即window.value = 10、obj.value = 20，同时定义了一个全局method匿名函数表达式，相当于window.method = function(){}。
- 在直接调用method()函数时，没有所属的对象，method()函数中的this指向的是全局window对象，输出window.value值，因此输出“10”。
- 而在调用method.call(obj)时，将method()函数调用的主体改为obj对象，此时this指向的是obj对象，输出obj.value值，因此输出“20”。
- apply()函数和bind()函数都会产生同样的效果，将函数指向的实体改为obj对象，因此后两个输出值也为“20”。
- call()函数、apply()函数在改变函数的执行主体后，**会立即调用该函数**；
- 而bind()函数在改变函数的执行主体后，并没有立即调用，而是可以在任何时候调用，上述代码中是通过手动执行newMethod()函数来进行调用的。

在处理DOM事件处理程序中的this时，call()函数、apply()函数、bind()函数显得尤为有用
```js
var user = {
  data: [
    { name: 'he', age: 11 },
    { name: 'ming', age: 12 },
  ],
  clickHandler: function (event) {
    // 随机生成整数0或1
    var randomNum = ((Math.random() * 2 | 0) + 1) - 1;
    // 从data数组随机获取值
    console.log(this.data[randomNum].name + "" + this.data[randomNum].age);
  }
}
var button = document.getElementById('btn');
button.onclick = user.clickHandler;
// 单击button按钮，会抛出异常。
// Uncaught TypeError: Cannot read property '1' of undefined
```
这是为什么呢？
异常信息栈分析：调用了一个undefined对象属性名为1的值，就是代码中this.data[1]的部分，间接可以表示出data为undefined。
这是因为当单击button按钮，触发click回调函数时，**clickHandler()函数中的this指向的是button对象，而不是user对象**，而button对象中是没有data属性的，因此data为undefined，从而抛出异常。
```js
// click回调函数中的this指向改变为user对象
button.onclick = user.clickHandler.bind(user);
```
### 闭包中的this
> 函数的this变量只能被自身访问，其内部函数无法访问。因此在遇到闭包时，闭包内部的this关键字无法访问到外部函数的this变量。
```js
1  var user = {
2      sport: 'basketball',
3      data: [
4          {name: "he", age: 11},
5          {name: "ming", age: 12}
6      ],
7      clickHandler: function () {
8        // 此时的this指向的是user对象
9          this.data.forEach(function (person) {
10             console.log(this);  // [object Window]
11             console.log(person.name + ' is playing ' + this.sport); 
12         })
13     }
14 };
15 user.clickHandler();
```
- 在调用user.clickHandler()函数时，会执行到第9行代码，此时的this会指向user对象，因此可以访问到data属性，并进行forEach循环。forEach循环实际是一个匿名函数，用于接收一个person参数，表示每次遍历的数组中的值。
- 在执行到第10行代码时，输出了this，此时在一个匿名函数中输出this时，它会指向全局对象window。
- 在执行到第11行代码时，输出了person.name属性和this.sport属性，person指向的是data数值中的对象，而this指向的依然是全局对象window，在window对象中没有sport属性，即为undefined。
```js
// he is playing undefined
// ming is playing undefined
```
解决方案：可以使用临时变量将clickHandler()函数的this提前进行存储，对其使用user对象，而在匿名函数中，使用临时变量访问sport属性，而不是直接用this访问。
```js
var user = {
   sport: 'basketball',
   data: [
       {name: "he", age: 11},
       {name: "ming", age: 12}
   ],
   clickHandler: function () {
       // 使用临时变量self保存this
       var self = this;
       this.data.forEach(function (person) {
           // 通过self访问sport属性
           console.log(person.name + ' is playing ' + self.sport);
       })
   }
};
user.clickHandler();
// he is playing basketball
// ming is playing basketball
```
再来一个
```js
function f(k) {
  this.m = k;
  return this;
}

var m = f(1);
var n = f(2);

console.log(m.m); // 1 ❌ undefined ✔
console.log(n.m); // 2
```
- 在执行f(1)的时候，因为f()函数的调用没有所属对象，所以this指向window，然后this.m=k语句执行后，相当于window.m = 1。**通过return语句返回“window”**，而又将返回值“window”赋值给全局变量m，因此变成了window.m =window，覆盖前面的window.m = 1。
- 在执行f(2)的时候，this同样指向window，此时window.m已经变成2，即window.m = 2，覆盖了window.m = window。通过return语句将window对象返回并赋值给n，此时window.n=window。
- 先看m.m的输出，m.m=(window.m).m，实际为2.m，2是一个数值型常量，并不存在m属性，因此返回“undefined”。再看n.m的输出，n.m=(window.n).m=window.m=2，因此输出“2”。
## call()函数、apply()函数、bind()函数的使用与区别
在JavaScript中，每个函数都包含两个非继承而来的函数apply()和call()
### call()函数的基本使用
call()函数调用一个函数时，会将该函数的执行对象上下文改变为另一个对象。
```js
function.call(thisArg, arg1, arg2, ...)
```
- function为需要调用的函数。
- thisArg表示的是新的对象上下文，函数中的this将指向thisArg，如果thisArg为null或者undefined，则this会指向全局对象
- arg1, arg2, ...表示的是函数所接收的参数列表
```js
// 定义一个add函数
function add(x, y) {
  return x + y;
}
// 通过call函数进行add函数的调用
function myAddCall(x, y) {
  // 调用add函数的call函数
  return add.call(this, x, y);
}
console.log(myAddCall(10, 20)) // 30
```
myAddCall()函数自身是不具备运算能力的，但是我们在myAddCall()函数中，通过调用add()函数的call()函数，并传入this值，将执行add()函数的主体改变为myAddCall()函数自身，然后传入参数x和y，这就使得myAddCall()函数拥有add()函数计算求和的能力。在实际计算时，就为10 + 20 = 30。
### apply()函数的基本使用
apply()函数的作用域与call()函数是一致的，只是在传递参数的形式上存在差别。其语法格式如下。
```js
function.apply(thisArg, [argsArray])
```
- function为需要调用的函数。
- [argsArray]表示的是参数会通过数组的形式进行传递，如果argsArray不是一个有效的数组或者arguments对象，则会抛出一个TypeError异常。
```js
//定义一个add()函数
function add(x, y) {
   return x + y;
}
// 通过apply()函数进行add()函数的调用
function myAddApply(x, y) {
   // 调用add()函数的apply()函数
   return add.apply(this, [x, y]);
}
console.log(myAddApply(10, 20));    //输出“30”
```
与call()函数相比，apply()函数只需要将add()函数接收的参数使用数组的形式传递即可，即使用[x, y]的形式，运行后的结果为10 + 20 = 30。
### bind()函数的基本使用
bind()函数创建一个新的函数，在调用时设置this关键字为提供的值，在执行新函数时，将给定的参数列表作为原函数的参数序列，从前往后匹配。其语法格式如下。
```js
function.bind(thisArg, arg1, arg2, ...) // bind()函数与call()函数接收的参数是一样的。
```
其返回值是原函数的副本，并拥有指定的this值和初始参数。
```js
//定义一个add()函数
function add(x, y) {
   return x + y;
}
// 通过bind()函数进行add()函数的调用
function myAddBind(x, y) {
   // 通过bind()函数得到一个新的函数
   var bindAddFn = add.bind(this, x, y);
   // 执行新的函数
   return bindAddFn();
}
console.log(myAddBind(10, 20));    //输出“30”
```
### call()函数、apply()函数、bind()函数的比较
三者的相同之处是：都会改变函数调用的执行主体，修改this的指向。
不同之处表现在以下两点：
- 关于函数立即执行，call()函数与apply()函数在执行后会立即调用前面的函数，而bind()函数不会立即调用，它会返回一个新的函数，可以在任何时候进行调用。
- 关于参数传递，call()函数与bind()函数接收的参数相同，第一个参数表示将要改变的函数执行主体，即this的指向，从第二个参数开始到最后一个参数表示的是函数接收的参数；而对于apply()函数，第一个参数与call()函数、bind()函数相同，第二个参数是一个数组，表示的是接收的所有参数，如果第二个参数不是一个有效的数组或者arguments对象，则会抛出一个TypeError异常。
### call()函数、apply()函数、bind()函数的巧妙用法、
#### 求数组中的最大项和最小项
Array数组本身没有max()函数和min()函数，无法直接获取到最大值和最小值，但是Math却有求最大值和最小值的max()函数和min()函数。可以使用apply()函数来改变Math.max()函数和Math.min()函数的执行主体，然后将数组作为参数传递给Math.max()函数和Math.min()函数。
```js
var arr = [3, 5, 7, 2, 9, 11];
// 求最大
console.log(Math.max.apply(null, arr)); // 11
// 求最小
console.log(Math.min.apply(null, arr)); // 2
```
- apply()函数的第一个参数为null，这是因为没有对象去调用这个函数，只需要这个函数帮助运算，得到返回结果。
- 第二个参数是数组本身，就是需要参与max()函数和min()函数运算的数据，运算结束后得到返回值，表示数组的最大值和最小值。

#### 类数组对象转换为数组对象
函数的参数对象arguments是一个类数组对象，自身不能直接调用数组的方法，但是我们可以借助call()函数，让arguments对象调用数组的slice()函数，从而得到一个真实的数组，后面就能调用数组的函数。
```js
// 任意个数字的求和
function sum() {
   // 将传递的参数转换为数组
   var arr = Array.prototype.slice.call(arguments);
   // 调用数组的reduce()函数
   return arr.reduce(function (pre, cur) {
       return pre + cur;
   }, 0)
}
sum(1, 2);       // 3
sum(1, 2, 3);    // 6
sum(1, 2, 3, 4); // 10
```
#### 用于继承
```js
// 父类
function Animal(age) {
  // 属性
  this.age = age;
  // 实例函数
  this.sleep = function() {
    return this.name = '正在睡觉！';
  }
}
// 子类
function Cat(name, age) {
  // 使用Call函数实现继承
  Animal.call(this, age);
  this.name = name || 'tom';
}
var cat = new Cat('tony', 11);
console.log(cat.sleep()); // tony正在睡觉！
console.log(cat.age); // 11
```
其中关键的语句是子类中的Animal.call(this, age)，在call()函数中传递this，表示的是将Animal构造函数的执行主体转换为Cat对象，从而在Cat对象的this上会增加age属性和sleep函数，子类实际相当于如下代码。
```js
function Cat(name, age) {
  // 来源于对父类的继承
  this.age = age;
  this.sleep = function () {
    return this.name + '正在睡觉！';
  }
  // Cat自身的实例属性
  this.name = name || 'tom';
}
```
#### 执行匿名函数
假如存在这样一个场景，有一个数组，数组中的每个元素是一个对象，对象是由不同的属性构成，现在我们想要调用一个函数，输出每个对象的各个属性值。
可以通过一个匿名函数，在匿名函数的作用域内添加print()函数用于输出对象的各个属性值，然后通过call()函数将该print()函数的执行主体改变为数组元素，这样就可以达到目的了。
```js
var animals = [
  { species: 'Lion', name: 'King' },
  { species: 'Whale', name: 'Fail' },
];
for (var i = 0; i < animals.length; i++) {
  (function(i) {
    this.print = function() {
      console.log('#' + i + '' + this.species + ':' + this.name);
    };
    this.print();
  // 在call()函数中传入animals[i]，这样匿名函数内部的this就指向animals[i]，在调用print()函数时，this也会指向animals[i]，从而能输出speices属性和name属性。
  }).call(animals[i], i);
}
```
#### bind()函数配合setTimeout
在默认情况下，使用setTimeout()函数时，this关键字会指向全局对象window。当使用类的函数时，需要this引用类的实例，可能需要显式地把this绑定到回调函数以便继续使用实例。
```js
// 定义一个函数
function LateBloomer() {
  this.petalCount = Math.ceil(Math.random() * 12) + 1;
}
// 定义一个原型函数
LateBloomer.prototype.bloom = function () {
  // 在一秒后调用实例的declare函数
  window.setTimeout(this.declare.bind(this), 1000);
};
// 定义原型上的declare函数
LateBloomer.prototype.declare = function () {
  console.log('I am a beautiful flower with' + this.petalCount + ' petals!');
};
// 生成LateBloomer的实例
var flower = new LateBloomer();
flower.bloom(); // 1秒后，调用declare()函数
```
在上面的代码中，关键的语句在bloom()函数中，我们期望通过一个定时器，设置在1秒后，调用实例的declare()函数。
```js
// 很多人可能会写出下面这样的代码。
LateBloomer.prototype.bloom = function () {
   window.setTimeout(this.declare, 1000);
};
```
此时，当调用setTimeout()函数时，由于其调用体是window，因此在setTimeout()函数内部的this指向的是window，而不是对象的实例。这样在1秒后调用declare()函数时，其中的this将无法访问到petalCount属性，从而返回“undefined”，输出结果如下所示。
```js
//  I am a beautiful flower with undefined petals!
```
因此我们需要手动修改this的指向，而通过bind()函数能够达到这个目的。
通过bind()函数传入实例的this值，这样在setTimeout()函数内部调用declare()函数时，declare()函数中的this就会指向实例本身，从而就能访问到petalCount属性。
```js
LateBloomer.prototype.bloom = function () {
  window.setTimeout(this.declare.bind(this), 1000); // I am a beautiful flower with 4 petals!
};
```
