## 跨域问题解决及登陆验证逻辑



### 一、跨域问题深入思考及问题解决

####  （1）跨域问题产生的原因

> 浏览器安全是基于同源策略的，所谓同源策略就是三相同：
>
> - 协议相同，http or https
> - 域名相同
> - 端口相同
>
> 同源策略在保证浏览器安全的同时，也导致了我们使用 ajax 跨域请求数据，无法拿到数据。
>
> 那么？如何保证浏览器安全，又能实现跨域请求接口数据呢？下面我们使用 JsonP、cors、Proxy 三种方式来解决跨域问题



#### （2）前后端实现 jsonp 

> 1. JSONP 实现的基本思想
>
>    src 属性向服务器端请求数据不受同源策略影响，比如：script、img、iframe 标签的 src 属性。
>
>    使用 script 标签的 src 向服务器请求数据，然后服务器将相应的数据放入指定的「回调函数」中，返回给前端即可实现跨域请求信息。

> 2. 使用 Node.js 模拟后端接口服务，体验 jsonp 工作模式
>
> ```js
> const http = require("http");
> const url = require("url");
> 
> const app = http.createServer((req, res) => {
>   // 设置 html 返回模式，使用中文编码
>   res.writeHead(200, {
>     "content-type": "text/html;charset=utf8",
>   });
>   let urlObj = url.parse(req.url, true)
>   switch (urlObj.pathname) {
>     case "/api":
>       // res.end(`alert('hello')`);
>       // res.end(`console.log('你好')`)
>       res.end(`todo('吃饭')`)
>       break;
>     default:
>       res.end("亲，你的页面走丢了！404！");
>       break;
>   }
> });
> app.listen(8080, () => {
>   console.log("localhost:8080");
> });
> ```

> 3. 启动前端页面调用后端返回的数据
>
> ```html
> <!DOCTYPE html>
> <html lang="en">
> <head>
>     <meta charset="UTF-8">
>     <meta http-equiv="X-UA-Compatible" content="IE=edge">
>     <meta name="viewport" content="width=device-width, initial-scale=1.0">
>     <title>Test</title>
> </head>
> <body>
>     <script>
>         function todo( someThing ){
>             console.log( someThing)
>         }
>     </script>
>     <script src="http://localhost:8080/api"></script>
> </body>
> </html>
> ```

> 4. 优化 jsonp 实现方式
>
> ```js
> // 后端接口修改成为动态传递 callback 参数
> res.end(`
> 	${urlObj.query.callback}({
> 		"name": "buhe",
> 		"like": "sing"
> 	})
> `);
> 
> // 前端调用主动传递 callback 来获取对应函数方法
> function userTodo( userInfo ){
> 	console.log( userInfo)
> }
> <script src="http://localhost:8080/api?callback=userTodo"></script>
> ```



#### （3）Node.js 配置 CORS 实现跨域请求

> ```js
> const http = require("http");
> const url = require("url");
> const querystring = require("querystring");
> 
> const app = http.createServer((req, res) => {
> let urlObj = url.parse(req.url, true);
> res.writeHead(200, {
>  "content-type": "application/json;charset=utf-8",
> 		// 核心代码 配置跨域请求允许白名单    
>  "Access-Control-Allow-Origin": "*",
> });
> switch (urlObj.pathname) {
>  case "/api/login":
>    res.end(
>      JSON.stringify({
>        message: "用户登录成功",
>      })
>    );
>    break;
>  case "/api/register":
>    res.end(
>      JSON.stringify({
>        message: "用户注册成功",
>      })
>    );
>    break;
>  default:
>    res.end("Page Not Found!");
>    break;
> }
> });
> app.listen(8080, () => {
> console.log("localhost:8080");
> });
> ```
>
> ```js
> fetch("http://localhost:8080/api/login").then(response => {
> 	console.log(response)
> 	return response.json()
> }).then(data => {
> 	console.log(data)
> })
> ```
>



#### （4）Node.js 中间件 middleWare 实现跨域效果

> 1. 服务器和服务器之间是不存在跨域问题的，所以，可以使用中间件，做一个本地「代理服务器」，由本地代理服务器向 web 服务器爬取数据，然后再交由本地代理服务器提供数据给本地前端程序使用即可。
> 2. 使用中间件 middleWare 解决跨域问题，是前端开发工程师最常用的使用方式。
> 3. 具体实现代码
>
> ```js
> const http = require("http");
> const { createProxyMiddleware } = require("http-proxy-middleware");
> http
>   .createServer((req, res) => {
>     let url = req.url;
>     if (/^\/api\/v2/.test(url)) {
>       res.writeHead(200, {
>         "content-type": "application/json;charset=utf-8",
>         // 核心代码 配置跨域请求允许白名单
>         "Access-Control-Allow-Origin": "*",
>       });
>       let apiProxy = createProxyMiddleware("/api/v2", {
>         target: "http://47.115.83.135",
>         changeOrigin: true
>       });
>       // http-proy-middleware 在Node.js中使用的方法
>       apiProxy(req, res);
>     } else {
>       res.writeHead(200, {
>         "content-type": "text/html;charset=utf8",
>       });
>       switch (url) {
>         case "/index.html":
>           res.end("首页 - 千锋教育");
>           break;
>         case "/search.html":
>           res.end("搜索 - 课程搜索");
>           break;
>         default:
>           res.end("千锋 - 页面未找到 404");
>       }
>     }
>   })
>   .listen(8080);
> ```



### 二、实现用户注册基础功能

> 1. 构建用户数据库 Model 层模块，及对应 MongoDB  mongoose.Schema
>
> ```js
> // 文件路径 model/person.js
> const mongoose = require("mongoose");
> // 创建数据表模型，该文件的名字，即 person，就是数据表的名字
> // 下面给 person 表声明两个字段 nickname 和 password
> let personSchema = new mongoose.Schema({
>   nickname: String,
>   password: String,
>   registerDate: Date,
> });
> // 通过建 model 给 person 赋予增删改查等读写的功能
> module.exports = mongoose.model("Person", personSchema);
> ```
>
> ```js
> // 连接数据库 app.js
> const mongoose = require("mongoose");
> mongoose.connect("mongodb://127.0.0.1:27017/test", {
>   useNewUrlParser: true,
>   useUnifiedTopology: true,
> });
> ```

> 2. 构建 controll 层页面路由 get 页面及 POST 服务接口，并注册到 app 实例上
>
> ```js
> // 文件路径 router/user.js
> const Router = require("koa-router")();
> Router.prefix("/user");
> // 引入mongo模型
> const Person = require("../model/person");
> Router.get("/register", async (ctx) => {
>   await ctx.render("register");
> }).post("/register", async (ctx) => {
>   // 创建实例
>   let nickname = ctx.request.body.nickname;
>   let password = ctx.request.body.password；
>   const person = new Person({
>     nickname,
>     password,
>     registerDate: new Date(),
>   });
>   ctx.set("Content-Type", "application/json");
>   try {
>     await person.save();
>     ctx.body = JSON.stringify({
>       status: "ok",
>       msg: "用户注册成功",
>       nickname,
>       password,
>     });
>   } catch (e) {
>     ctx.body = JSON.stringify({
>       status: "err",
>       msg: "用户注册失败",
>     });
>   }
> });
> ```
>
> ```js
> // POST 请求体解析中间件，可以通过 ctx.request.body 获取 post 的数据 app.js
> const bodyparser = require("koa-bodyparser");
> app.use(
>   bodyparser({
>     enableTypes: ["json", "form", "text"],
>   })
> );
> // 使用模块的方式构建路由模块，再导入系统
> const user = require("./router/user");
> app.use(user.routes(), user.allowedMethods());
> ```

> 3. 使用 ejs 模板引擎，构建 View 层前端页面，调用 ajax 实现注册逻辑实现
>
> ```js
> // 静态资源文件服务再调用静态资源，注意路径规则 app.js
> const koaStatic = require("koa-static");
> app.use(koaStatic(__dirname + "/static"));
> 
> // 模板引擎解析规则
> const views = require("koa-views");
> app.use(
>   views(__dirname + "/views", {
>     extension: "ejs",
>   })
> );
> ```
>
> ```html
> <!-- 文件路径 views/register.ejs -->
> <!DOCTYPE html>
> <html lang="en">
> <head>
>     <meta charset="UTF-8">
>     <meta http-equiv="X-UA-Compatible" content="IE=edge">
>     <meta name="viewport" content="width=device-width, initial-scale=1.0">
>     <title>全栈学习 - 用户注册</title>
> </head>
> <body>
>     <h2>用户注册</h2>
>     <p>昵称：<input type="text" name="" id="nickname"></p>
>     <p>密码：<input type="password" name="" id="password"></p>
>     <p><button id="register">注册</button></p>
> </body>
> <script src="/js/jquery.js"></script>
> <script>
>     $("#register").on("click", function(){
>         $.ajax({
>             url:"/user/register",
>             type: "POST",
>             data:{
>                 nickname:$("#nickname").val(),
>                 password:$("#password").val()
>             },
>             success:function(data){
>                 console.log(data)
>                 window.location.href = "/user/login"
>             }
>         })
>     })
> </script>
> </html>
> ```

> 4. 注册时利用 bcrypt 模块对用户密码进行加密，非明文保存密码，确保账号体系安全性
>
> ```js
> const crypto = require("crypto");
> Router.post("/register", async (ctx) => {
>   // 创建实例
>   let nickname = ctx.request.body.nickname;
>   let password = crypto
>     .createHash("md5")
>     .update(ctx.request.body.password)
>     .digest("buhe");
>   const person = new Person({
>     nickname,
>     password,
>     registerDate: new Date(),
>   });
>   ctx.set("Content-Type", "application/json");
>   try {
>     await person.save();
>     ctx.body = JSON.stringify({
>       status: "ok",
>       msg: "用户注册成功",
>       nickname,
>       password,
>     });
>   } catch (e) {
>     ctx.body = JSON.stringify({
>       status: "err",
>       msg: "用户注册失败",
>     });
>   }
> });
> ```

> 5. 当然，我们还可以进行安全兼容性判定，比如：
>
> - 已经存在的注册用户，不允许注册
> - 用户昵称、密码合法性前端校验
> - 追加手机号码填写
> - 追加手机号码模拟 验证码 进行校验 
> - 等等





### 三、基于多种方式实现登陆验证业务逻辑实现

#### （1）用户登录功能逻辑介绍

> 1. 我们使用 koa get login 路由渲染用户登陆页面，输入并获取用户名和密码
> 2. koa post login 路由，后台接收账号和密码，通过 ctx 获取 post 信息数据
> 3. 对 Post 中的密码 Password 进行 bcrypt 加密，注意这个加密规则和注册时的规则一致
> 4. 构建 mongoose.Schema user model 层，验证用户名和密码，存在则代表登陆成功
> 5. 登陆成功后，需要和客户端进行交互，后续操作，仍能确保处于安全状态
> 6. 使用 session or token 两种方式来进行安全策略开发



#### （2）session 的概念

> Session 和 Cookie 是两个很相似的东西，都是字符串，只不过 Session 是保存在服务器上的，而 Cookie 是保存在本地的，所以 Cookie 是不能用作身份验证的。Session 故名思议，肯定和客户端与服务器间建立的会话相关，Session 的工作过程也是如此，每当客户端和服务器上的一个站点建立了会话后，就会生成Session在服务器上。
>
> 在一般的 Web 应用上，如果要实现用户登陆，最常用，也是最简单的方法就是使用 Session，基本的思路是在Session 中保留一些用户身份信息，然后每次在 Session 中取，如果信息不正确或不存在，那么身份验证失败，正确则成功。
>
> ![session](https://tva1.sinaimg.cn/large/008i3skNly1gvhkzp2t8kj31520u0myf.jpg)



#### （3）利用 express-session 创建 session 实现用户登录验证

> 1. 调用 session 中间件
>
> ```js
> // 使用 session 中间件 app.js
> const session = require("koa-session");
> app.keys = ["mySecret"];
> const CONFIG = {
>   key: "koa:sess", //cookie key (default is koa:sess)
>   maxAge: 86400000, // cookie的过期时间 maxAge in ms (default is 1 days)
>   overwrite: true, //是否可以overwrite    (默认default true)
>   httpOnly: true, //cookie是否只有服务器端可以访问 httpOnly or not (default true)
>   signed: true, //签名默认true
>   rolling: false, //在每次请求时强行设置cookie，这将重置cookie过期时间（默认：false）
>   renew: false, //(boolean) renew session when session is nearly expired,
> };
> app.use(session(CONFIG, app));
> ```
>
> 2. 登录成功后设置 session
>
> ```js
> Router.post("/login", async (ctx) => {
>   // 创建实例
>   let nickname = ctx.request.body.nickname;
>   let password = crypto
>     .createHash("md5")
>     .update(ctx.request.body.password)
>     .digest("buhe");
>   ctx.set("Content-Type", "application/json");
>   let res = await Person.find({
>     nickname,
>     password,
>   });
>   if (Array.isArray(res) && res.length > 0) {
>     // 用户登录成功以后，可以配合 session 来进行登录成功验证
>     ctx.session.nickname = nickname;
>     ctx.body = JSON.stringify({
>       status: "ok",
>       msg: "用户登录成功",
>       token,
>     });
>   } else {
>     ctx.body = JSON.stringify({
>       status: "err",
>       msg: "用户登录失败",
>     });
>   }
> });
> ```
>
> 3. 调用对应的路由时，如果需要权限，则判断 session 是否存在
>
> ```js
> Router.get("/getuserlistbysession", async (ctx) => {
>   ctx.set("Content-Type", "application/json");
>   // 根据 session 是否存在，判断是否可以进行对应的权限逻辑操作
>   if (!!ctx.session.nickname) {
>     let res = await Person.find();
>     if (Array.isArray(res) && res.length > 0) {
>       ctx.body = JSON.stringify(res);
>     } else {
>       ctx.body = JSON.stringify({
>         status: "nouser",
>         msg: "用户数据查找失败",
>       });
>     }
>   } else {
>     ctx.body = JSON.stringify({
>       status: "err",
>       msg: "用户未登录",
>     });
>   }
> })
> ```



#### （4）token 实现登录验证的方式，JSON WEB TOKEN 规范

> JSON Web Token（JWT）是一个开放规范（RFC7519），该规范为安全的信息传递定义了一个紧凑自包含的方式。由于信息是被数字签名的，所以信息是可以被认证和信任的。
>
> 在认证中，当用户使用它们的凭证成功登录时，将会返回一个 JWT 令牌，并且这个令牌将会被保存在本地（通常在本地 locaStorage 存储，也可以使用 cookies 保存），而不是像传统途径一样在服务器上创建一个 session 并且返回一个 cookie。
>
> ![token](https://tva1.sinaimg.cn/large/008i3skNly1gvhk3hjspqj617w0ocq4c02.jpg)



#### （5）使用 Token 实现用户登陆验证

> 1. 在 app.js 中 调用 koa-jwt 中间件
>
> ```js
> // 使用 token 中间件
> const koaJwt = require("koa-jwt");
> //设置 token 中间件，验证路由状态，并设置不需要路由验证的相关路由
> app.use(
>   koaJwt({
>     secret: "yoursecret",
>   }).unless({
>     path: [
>       "/",
>       /\/getuserlistbysession/,
>       /\/register/,
>       /\/login/,
>       /\/js/,
>       /\/css/,
>     ], // 使用 正则表达式来祛除不需要验证的接口
>   })
> );
> ```
>
> 2. 创建一个 middleWare checkToken 中间件，需要注意 token 的 Bearer 前缀
>
> ```js
> // 文件路径 middle/checkToken.js
> // 单独的创建一个中间件，然后在app.js中注册使用
> const jwt = require("jsonwebtoken");
> async function check(ctx, next) {
>   // 否则获取到token
>   let token = ctx.request.headers["authorization"];
>   if (token) {
>     // 如果有token的话就开始解析
>     const tokenItem = jwt.verify(token.split(" ")[1], "yoursecret"); 
>     // 将token的创建的时间和过期时间结构出来
>     const { time, timeout } = tokenItem;
>     
>     // 拿到当前的时间
>     let now = new Date().getTime();
>     console.log(now - time)
>     // 判断一下如果当前时间减去token创建时间小于或者等于token过期时间，说明还没有过期，否则过期
>     if (now - time <= timeout * 1000) {
>       // token没有过期
>       await next();
>     } else {
>       ctx.body = {
>         status: 405,
>         message: "token 已过期，请重新登陆",
>       };
>     }
>   } else {
>     await next();
>   }
> }
> module.exports = check;
> ```
>
> 3. 在 app.js 调用该验证中间件
>
> ```js
> const checkToken = require("./middleware/checkToken");
> app.use(checkToken);
> ```
>
> 4. 在登录 router 中签名 jsw，需要注意 token 的 Bearer 前缀
>
> ```js
> Router.get("/login", async (ctx) => {
>   await ctx.render("login");
> }).post("/login", async (ctx) => {
>   // 创建实例
>   let nickname = ctx.request.body.nickname;
>   let password = crypto
>     .createHash("md5")
>     .update(ctx.request.body.password)
>     .digest("buhe");
>   ctx.set("Content-Type", "application/json");
>   let res = await Person.find({
>     nickname,
>     password,
>   });
>   if (Array.isArray(res) && res.length > 0) {
>     // 用户登录成功以后，也可以设置 token 以用来进行登录状态判断
>     const token = "Bearer " + jwt.sign(
>       {
>         //token的创建日期
>         time: Date.now(),
>         //token 的过期时间，以 s 为单位
>         timeout: 10,
>         nickname,
>       },
>       "yoursecret"
>     );
>     ctx.body = JSON.stringify({
>       status: "ok",
>       msg: "用户登录成功",
>       token,
>     });
>   } else {
>     ctx.body = JSON.stringify({
>       status: "err",
>       msg: "用户登录失败",
>     });
>   }
> });
> ```
>
> 5. 在登录成功的时候，将 token 保存在 localStorage 中，以下次使用
>
> ```js
> $("#login").on("click", function () {
>   $.ajax({
>     url: "/user/login",
>     type: "POST",
>     data: {
>       nickname: $("#nickname").val(),
>       password: $("#password").val(),
>     },
>     success: function (data) {
>       console.log(data.token);
>       window.localStorage.setItem("token", data.token);
>       window.location.href = "/";
>     },
>   });
> });
> ```
>
> 6. 在前端页面调用接口的时候，设置 headers authorization
>
> ```js
> $("#get-users").on("click", function () {
>     $.ajax({
>         url: "/user/getuserlistbytoken",
>         type: "POST",
>         headers: {
>             authorization: window.localStorage.getItem("token")
>         },
>         success: function (data) {
>             console.log(data);
>         }
>     })
> })
> ```
>
> 7. 直接调用该接口，即可完成 auth 权限认证
>
> ```js
> Router.post("/getuserlistbytoken", async (ctx) => {
>   console.log("Token，验证成功！getuserlistbytoken 路由被调用了!");
>   ctx.set("Content-Type", "application/json");
>   let res = await Person.find({
>     nickname: "buhe",
>   });
> 
>   if (Array.isArray(res) && res.length > 0) {
>     ctx.body = JSON.stringify(res);
>   } else {
>     ctx.body = JSON.stringify({
>       status: "nouser",
>       msg: "用户数据查找失败",
>     });
>   }
> });
> ```
