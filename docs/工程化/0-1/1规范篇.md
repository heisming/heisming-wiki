# 规范篇
> 熟悉模块/代码/提交三大开发阶段规范，通过规范约束自己，保障工作质量与提升开发效率


## 模块规范

部署Node的ESM开发环境

模块化让JS也能拥有自己的模块化效果，在实际开发中，**一个模块就是一个文件**。模块化的核心包括以下特性，基本都是围绕如何处理文件(模块)。
- **拆分**：将代码根据功能拆分为多个可复用模块
- **加载**：通过指定方式加载模块并执行与输出模块
- **注入**：将一个模块的输出注入到另一个模块
- **管理**：因为工程模块数量众多需管理模块间的依赖关系

模块化作用
- 隔离作用域
- 提供重复性
- 提高可维护性
- 解决命名冲突
- 抽离公共代码

### 模块方案
以前引用js文件都会使用多个`<script>`顺序处理，曾见过一个老旧项目多达12个`<script>`，这会导致很多问题，例如以下情况。
- **请求过多**：每个`<script>`都有一个src必然会增加HTTP请求次数
- **依赖模糊**：每个`<script>`的摆放顺序都有可能影响前后脚本加载错误
- **难以维护**：每个`<script>`的变量命名与函数作用域都有可能互相影响

在JS发展历程中，主要有六种常见模块方案，分别是`IIFE`、`CJS`、`AMD`、`CMD`、`UMD`和`ESM`。
每个模块方案的特性可知，
**同步加载**包括`IIFE`与`CJS`，
**异步加载**包括`AMD`、`CMD`和`ESM`。
浏览器可兼容`IIFE`与`AMD`，
**服务器可兼容**`CJS`，
**浏览器与服务器都兼容**`CMD`、`UMD`和`ESM`。

目前只需关注CJS与ESM
| -   | CJS	| ESM |
| ----| ----| ----|
语法类型	| 动态 | 静态
关键声明	| require |	export与import
加载方式	| 🚩运行时加载 | 🎉编译时加载
加载行为	| 同步加载 | 异步加载
书写位置	| 任何位置 | 顶层位置
指针指向	| this指向当前模块 | this指向undefined
执行顺序	| 首次引用时加载模块<br />再次引用时读取缓存 | 引用时生成只读引用<br />执行时才是正式取值
属性引用 | 基本类型属于复制不共享<br />引用类型属于浅拷贝且共享 | 所有类型属于动态只读引用
属性改动 | 工作空间可修改引用的值	|工作空间不可修改引用的值<br />但可通过引用的方法修改

Node开发习惯使用`CJS`编码，但本章将改用`ESM`编码，因此在后续编码时可能会出现一些难以解释的问题，例如循环引用与前置引用，而了解它们的加载方式与行为可帮助你理解这些问题。
- **🚩运行时加载**指整体加载模块生成一个对象，再从对象中获取所需的属性方法去加载。最大特性是`全部加载`，只有运行时才能得到该对象，无法在编译时做静态优化。
- **🎉编译时加载**指直接从模块中获取所需的属性方法去加载。最大特性是`按需加载`，在编译时就完成模块加载，效率比其他方案高，无法引用模块本身(本身不是对象)，但可拓展JS高级语法(宏与类型校验)。

### 现状：ESM能否在Node环境中运行
随着主流浏览器逐步支持ESM，越来越多目光投注于Node对于ESM的支持上。目前Node使用CJS作为官方模块方案，虽然内置模块方案促进Node的流行，但也阻碍了ESM的引入。

#### 原生支持ESM
2017年10月31日，Node发布了v8.9.0，从此只要在命令中加上`--experimental-modules`，Node就可象征性地支持ESM了。

```bash
node --experimental-modules index.js
```
接着Node发布了v13.2.0带来一些新特性，正式取消`--experimental-modules`启动参数。当然并不是删除`--experimental-modules`，而是在其原有基础上实现对ESM的实验性支持并默认启动。
`--experimental-modules`特性包括以下方面。
- 使用type指定模块方案
  - 在`package.json`中指定type为commonjs，则使用CJS
  - 在`package.json`中指定type为module，则使用ESM
- 使用--input-type指定入口文件的模块方案，与type一样
  - 命令中加上`--input-type=commonjs`，则使用CJS
  - 命令中加上`--input-type=module`，则使用ESM
- 支持新文件后缀`.cjs`
  - 文件后缀使用`.cjs`，则使用CJS
- 使用`--es-module-specifier-resolution`指定文件名称引用方式
  - 命令中加上`--es-module-specifier-resolution=explicit`，则引用模块时必须使用文件后缀(默认)
  - 命令中加上`--es-module-specifier-resolution=node`，则引用模块时无需使用文件后缀
- 使用main根据type指定模块方案加载文件
  - 在`package.json`中指定main后会根据type指定模块方案加载文件

#### CJS/ESM判断方式
Node要求使用ESM的文件采用`.mjs`后缀，只要文件中存在import/export命令就必须使用`.mjs`后缀。
若不希望修改文件后缀，可在package.json中指定type为module。基于此，若其他文件使用CJS，就需将其文件后缀改成`.cjs`。
若在package.json中未指定type或指定type为commonjs，则以.js为后缀的文件会被解析为CJS。

简而言之，**mjs文件使用ESM解析**，**cjs文件使用CJS解析**，js文件使用基于package.json指定的type解析(type=commonjs使用CJS，type=module使用ESM)。

那Node是如何区分CJS与ESM？
Node会将以下情况视为ESM。
- 文件后缀为`.mjs`
- 文件后缀为`.js`且在package.json中指定type为module
- 命令中加上--input-type=module
- 命令中加上--eval cmd

### 方案：部署Node的ESM开发环境
将Node v13.2.0作为高低版本分界线，当版本>=13.2.0则定为高版本，当版本<13.2.0则定为低版本。高版本使用Node原生部署方案，低版本使用Node编译部署方案。

在部署Node的ESM开发环境前需初始一个示例，以下所有代码都基于该项目进行。

在根目录中创建package.json并执行npm i安装项目依赖。
```json
{
	"name": "node-esm",
	"version": "1.0.0",
	"main": "src/index.js",
	"scripts": {
		"start": "node src/index.js"
	},
	"dependencies": {
		"@yangzw/bruce-us": "1.0.3"
	}
}

```

创建src/index.js文件，加入以下内容。示例引用我开源的@yangzw/bruce-us，其中NodeType()用于获取Node相关信息。
```js
import { NodeType } from "@yangzw/bruce-us/dist/node";

console.log(NodeType());
```

这一步完成就需分情况讨论了。

#### Node原生部署方案

假设Node是v13.2.0以上版本，执行npm start，输出以下信息表示运行失败。
