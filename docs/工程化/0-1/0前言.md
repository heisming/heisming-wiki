# 前端工程化的特性

## 模块化
> 将一个复杂应用根据预设规范封装为多个块并组合起来，对内实现数据私有化，对外暴露接口与其它模块通信。

模块化是前端工程化的重中之重。

表现为：在文件层面上对代码与资源实现拆分与组装，将一个大文件拆分为互相依赖的小文件，再统一拼装与加载。

对于一个完善的Web项目，一般是`SPA/MPA`，推荐使用以下目录结构将整个项目划分为各种通用模块。

```
project
├─ dist          # 输出目录
│  ├─ prod         # 生产环境执行代码
│  └─ test         # 测试环境执行代码
├─ src           # 源码目录
│  ├─ apis         # 接口模块：包括全局接口请求的功能，控制数据定向转换
│  ├─ assets       # 资源模块：包括样式、脚本、字体、图像、音频、视频等资源文件
│  ├─ components   # 组件模块：包括全局通用的基础组件、皮肤主题和字体图标
│  ├─ layouts      # 布局模块：包括以布局为最小粒度的组件集合，由至少一个基础组件组成
│  ├─ flows        # 流程模块：包括以流程为最小粒度的组件集合，由至少一个基础组件组成
│  ├─ pages        # 页面模块：包括以页面为最小粒度的组件集合，由至少一个基础组件组成
│  ├─ routes       # 路由模块：包括全局页面跳转的功能，控制页面自由切换
│  ├─ stores       # 数据模块：包括全局数据状态的功能，控制数据驱动视图
│  ├─ views        # 视图模块：包括以视图为最小粒度的组件集合，由至少一个基础组件组成
│  ├─ utils        # 工具模块：包括全局通用的常量与方法
│  ├─ index.html   # 模板入口文件
│  ├─ index.js     # 脚本入口文件
│  └─ index.scss   # 样式入口文件
└─ package.json
```

对于一个完善的Node项目，一般是接口系统，推荐使用以下目录结构将整个项目划分为各种通用模块。
```
project
├─ dist          # 输出目录
│  ├─ prod         # 生产环境执行代码
│  └─ test         # 测试环境执行代码
├─ src           # 源码目录
│  ├─ assets       # 资源模块：包括样式、脚本、字体、图像、音频、视频等资源文件
│  ├─ models       # 模型模块：包括全局数据模型的功能
│  ├─ routes       # 路由模块：包括全局接口请求的功能
│  ├─ utils        # 工具模块：包括全局通用的常量与方法
│  └─ index.js     # 脚本入口文件
└─ package.json
```

> 为了让目录结构更突出其功能，就不包括那些杂七杂八的工具链配置文件了。

## 组件化

> 将一个具备通用功能的交互设计划分为模板、样式和逻辑组成的功能单元，对内管理内部状态满足交互需求，对外提供属性接口扩展用户需求。

组件化是前端工程化的重要基础。

它实现了代码更高层次的复用性，提升开发效率。组件的封装也是对象的封装，同样要做到高内聚低耦合，组件化的项目不仅利于单元测试的进行，同样也利于需求迭代的推进。

优秀的组件化遵循以下设计哲学。
- 将设计图划分为最小组件层级
- 使用预设规范创建组件静态版本
- 确定组件内部最小且完整的状态的表示方式
- 确定组件内部最小且完整的状态的存放方式
- 实现数据流的正向传递与反向传递

**模块化着重在文件层面上对代码与资源实现拆分与组装，组件化着重在功能层面上对交互与设计实现拆分与组装。**

## 规范化
> 指将一系列预设规范接入工程各个阶段，通过各项指标标准化开发者的工作流程，引导开发者在团队协作中往更好的方向发展。

规范化是前端工程化的重要部分

它有效地将一盘松散的规范通过指定标准凝聚在一起，将所有工作流程标准化，协同所有开发者以标准化的方式定义工作流程，同时也影响着代码、文档和日志，甚至影响着每个开发者及其团队发展方向，因此每个成熟的前端团队都有一套身经百战的规范化方案。

## 自动化

> 将一系列繁琐重复的工作流程交由程序根据预设脚本自动处理，整个工作流程无需人工参与，以解放开发者双手让其更专注业务需求的开发。

自动化是前端工程化的**智能部分**。

常见自动化场景包括但不限于`自动化构建`、`自动化测试`、`自动化打包`、`自动化发布`和`自动化部署`，更高级的自动化场景包括但不限于`持续集成`、`持续交付`和`持续部署`。

以自动化构建为例，又可将其划分为以下子任务，这些子任务分布在自动化构建不同阶段，在不同阶段的最佳时刻会调用相关工具处理相关流程。

| 任务 | 职责 |
| ---- | ---- |
Stylelint |	校验样式代码
Eslint |	校验脚本代码
Postcss |	Postcss → CSS
Sass |	SASS → CSS
Less |	LESS → CSS
Babel |	ES6 → ES5
TypeScript |	TS → JS

自动化整体重心偏向于构建，构建为工程服务，工程又为用户服务，因此一个项目会演化出至少两种运行环境，分别是**开发环境与生产环境**。其中开发环境工程为开发者服务，生产环境工程为用户服务。

通过以下方面思考
- **前后分离**：前端应自成体系且与后端分离，包括但不限于规范、服务、环境、构建、组织和部署方面
- **技术选型**：不能以一个框架满足所有业务场景，需制定多套框架解决方案避免技术瓶颈的出现
- **重构封装**：新生技术不断涌现就要避免改头换面式的重构，重复需求不断出现就要学会举一反三的封装
- **工程设计**：解决方案要合理分层且互相独立，随时应对各种变化，任何一层可低成本被替换与淘汰

