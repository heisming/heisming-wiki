# 时间类
[](https://segmentfault.com/a/1190000004292140)

## 时间格式
### 基本概念
以前的人们通过观察太阳的位置来决定时间（比如：使用日晷），这就使得不同经纬度的地区时间是不一样的。后来人们进一步规定以子午线为中心，向东西两侧延伸，每 15 度划分一个时区，刚好是 24 个时区。然后因为一天有 24 小时，地球自转一圈是 360 度，360 度 / 24 小时 = 15 度/小时，所以每差一个时区，时间就差一个小时。

最开始的标准时间（子午线中心处的时间）是英国伦敦的皇家格林威治天文台的标准时间（因为它刚好在本初子午线经过的地方），这就是我们常说的 GMT（Greenwich Mean Time）。然后其他各个时区根据标准时间确定自己的时间，往东的时区时间晚（表示为 GMT+hh:mm）、往西的时区时间早（表示为 GMT-hh:mm）。**比如，中国标准时间是东八区，我们的时间就总是比 GMT 时间晚 8 小时，他们在凌晨 1 点，我们已经是早晨 9 点了。**

但是 GMT 其实是根据地球自转、公转计算的（太阳每天经过英国伦敦皇家格林威治天文台的时间为中午 12 点），不是非常准确，于是后面提出了根据原子钟计算的标准时间 UTC（Coordinated Universal Time）。

一般情况下，GMT 和 UTC 可以互换，但是实际上，GMT 是一个时区，而 UTC 是一个时间标准。

所以，当我们“展示”某个时间时，明确时区就变得非常重要了。不然你只说现在是 2016-01-11 19:30:00，然后不告诉我时区，我其实是没法准确知道时间的（当然，我可以认为这个时间是我所在时区的当地时间）。如果你说现在是 2016-01-11 19:30:00 GMT+0800，那我就知道这个时间是东八区的时间了。如果我在东八区，那时间就是 19:30，如果我在 GMT 时区，那时间就是 11:30（减掉 8 小时）。

### JavaScript 中的“时间”

#### [Date对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date)
> 创建一个 JavaScript Date 实例，该实例呈现时间中的某个时刻。Date 对象则基于 [Unix Time Stamp](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16)，即自 **1970 年 1 月 1 日（UTC）** 起经过的毫秒数。

```js
const date1 = new Date('December 17, 1995 03:24:00');
// Sun Dec 17 1995 03:24:00 GMT...

const date2 = new Date('1995-12-17T03:24:00');
// Sun Dec 17 1995 03:24:00 GMT...

console.log(date1 === date2);
// expected output: false;

console.log(date1 - date2);
// expected output: 0
```

##### Date 构造器
构造时间的方法有下面几种：
```js
new Date();           // 当前时间
new Date(value);      // 自 1970-01-01 00:00:00 UTC 经过的毫秒数
new Date(dateString); // 时间字符串
new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);
```
>❗ 需要注意的是：构造出的日期用来显示时，会被转换为本地时间（调用 toString 方法）：
```js
> new Date()
Mon Jul 11 2022 20:46:52 GMT+0800 (中国标准时间)
```
打印出的本地时间。后面的 `GMT+0800` 表示是 **“东八区”**，`CST` 表示是 **“中国标准时间（China Standard Time）”**。

如果我们直接使用 Date，而不是 new Date，得到的将会是字符串，而不是 Date 类型的对象：
```js
> typeof Date()
'string'
> typeof new Date()
'object'
```

##### 时间字符串
我们先说最复杂的时间字符串形式。它实际上支持两种格式：
- 一种是 RFC-2822 的标准
- 另一种是 ISO 8601 的标准(主要)

###### [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
ISO 8601的标准格式是：`YYYY-MM-DDTHH:mm:ss.sssZ`，分别表示：

|  字符串 | 中文  | 数值 |
|  ----  | ----  | ---- |
| YYYY  | 年份 | 0000 ~ 9999  |
| MM  | 月份 | 01 ~ 12 |
| DD  | 日   | 01 ~ 31 |
| T  | 分隔日期和时间 |   \   |
| HH  | 小时 | 00 ~ 24 |
| mm  | 分钟 | 00 ~ 59 |
| ss  | 秒 | 00 ~ 59 |
| .sss  | 毫秒 |      |
| Z  | 时区 | Z（UFC）、+HH:mm、-HH:mm |

除了 `T`, `.sss`, `Z`, 其它都是老生常谈了，就不解释了
###### T
T 是分隔日期和时间的符号
```js
> new Date('1970-01-01 00:00:00')
Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间)
> new Date('1970-01-01T00:00:00')
Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间)
```
上面的例子其实结果是一样的。
> ✨时间字符串这种形式有一个特殊的逻辑：如果不提供“时间”（也就是 T 分隔后的内容），得到的其实是 `UTC` 时间。比如：
```js
> new Date('1970-01-01')
Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)
> new Date('1970-01-01T00:00')
Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间)
```

###### Z
Z 用来表示传入时间的时区（zone）, 指定 Z 时表示 UTC 时间，不指定时表示的是本地时间。
```js
// 是东八区时间，显示的时间和传入的时间一致（因为我本地时区是东区）
> new Date('1970-01-01T00:00:00')
Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间)
// 指定了 Z（也就是 UTC 零时区），显示的时间会加上本地时区的偏移（8 小时）。
> new Date('1970-01-01T00:00:00Z')
Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)
```

###### [RFC-2822](https://datatracker.ietf.org/doc/html/rfc2822#page-14)
RFC-2822 的标准格式大概是这样：`Wed Mar 25 2015 09:56:24 GMT+0100`。其实就是上面显示时间时使用的形式：
```js
> new Date('Thu Jan 01 1970 00:00:00 GMT+0800 (CST)')
Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间)
```
除了能表示基本信息，还可以表示星期，但是一点也不容易读，不建议使用。

##### 时间戳
Date 构造器还可以接受整数，表示想要构造的时间自 UTC 时间 1970-01-01 00:00:00 经过的毫秒数。比如下面的代码：
```js
> new Date(1000 * 1)
Thu Jan 01 1970 08:00:01 GMT+0800 (中国标准时间)
```
传入 1 秒，等价于：`1970-01-01 00:00:01Z`，显示的时间加上了本地时区的偏移（8 小时）。

**多参数**
Date 构造器还支持传递多个参数，这种方法就没办法指定时区了，都当做本地时间处理。比如下面的代码：
```js
> new Date(1970, 0, 1, 0, 0, 0)
Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间)
```
显示时间和传入时间一致，均是本地时间。注意：月份是从 0 开始的。

##### Date.parse
> Date.parse 接受一个时间字符串，如果字符串能正确解析就返回自 UTC 时间 1970-01-01 00:00:00 经过的毫秒数，否则返回 NaN：
```js
/**
 * 本地时间差8h
 * -28800000 换算后刚好是 8 小时表示的毫秒数，
 * 28800000 / (1000 * 60 * 60)，
 * 传入的是本地时区时间，等于 UTC 时间的 1969-12-31 16:00:00，
 * 和 UTC 时间 1970-01-01 00:00:00 相差刚好 -8 小时。
 */
> Date.parse('1970-01-01 00:00:00')
-28800000 
// 刚好
> new Date(-28800000)
Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间) 
// 等同
> new Date(Date.parse('1970-01-01 00:00:00'))
Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间)

// 加上T分隔日期和时间的符号
> Date.parse('1970-01-01T00:00:00')
-28800000
> new Date(Date.parse('1970-01-01T00:00:00'))
Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间)

// 结尾的Z表示 UTC 时间
> Date.parse('1970-01-01 00:00:00Z')
0
```

##### Date.UTC
> Date.UTC 接受的参数和 Date 构造器多参数形式一样，然后返回时间自 UTC 时间 1970-01-01 00:00:00 经过的毫秒数：
```js
// 表示 UTC 时间
> Date.UTC(1970,0,1,0,0,0)
0
// 本地时间差8h
> Date.parse('1970-01-01T00:00:00')
-28800000

// 结尾的Z表示 UTC 时间
> Date.parse('1970-01-01 00:00:00Z')
0
```
Date.UTC 进行的是一种“绝对运算”，传入的时间就是 UTC 时间，不会转换为当地时间。

##### Date.now
> Date.now 返回当前时间距 UTC 时间 1970-01-01 00:00:00 经过的毫秒数：
```js
> Date.now()
1657545712428
> new Date(Date.now())
Mon Jul 11 2022 21:21:57 GMT+0800 (中国标准时间)
> new Date()
Mon Jul 11 2022 21:22:02 GMT+0800 (中国标准时间)
```





## [Day.js](https://day.js.org/zh-CN/)
>Day.js 可以运行在浏览器和 Node.js 中。

### TypeScript
在 NPM 包中已经包含 Day.js 的 TypeScript 类型定义文件。
通过 NPM 安装
```BASH
npm i dayjs
```
在 TypeScript 项目中导入并使用
```js
import * as dayjs from 'dayjs'
dayjs().format()
```
导入本地化语言和插件
在使用本地化语言和插件，首先需要导入它们。
```js
import * as dayjs from 'dayjs'
import * as isLeapYear from 'dayjs/plugin/isLeapYear' // 导入插件
import 'dayjs/locale/zh-cn' // 导入本地化语言

dayjs.extend(isLeapYear) // 使用插件
dayjs.locale('zh-cn') // 使用本地化语言
```

### 解析
Day.js 并`没有对原生 Date.prototype 做任何修改`， 而是给 Date 对象做了一层封装。 使用支持的数据格式调用 dayjs() 即可取到这个封装的对象。

Day.js 对象是不可变的，所有的 API 操作都将返回一个全新的实例。

#### 当前时间
```js
var now = dayjs()
// 等同
var now = dayjs(undefined)
// 无效
var now = dayjs(null)
```
等同于 `dayjs(new Date())` 的调用。

#### 字符串
解析传入的 [ISO 8601](#iso-8601) 格式的字符串并返回一个 Day.js 对象实例。
```js
dayjs('2018-04-04T16:00:00.000Z');
```
> 为了保证结果一致，当解析除了 ISO 8601 格式以外的字符串时，应该使用 String + Format。

#### 字符串 + 格式
```js
// customParseFormat插件
dayjs.extend(customParseFormat)
dayjs("12-25-1995", "MM-DD-YYYY")
```
如果想解析包含本地化语言的日期字符串，可以传入第三个参数。
```js
require('dayjs/locale/zh-cn')
dayjs('2018 三月 15', 'YYYY MMMM DD', 'zh-cn')
```
最后一个参数可传入布尔值来启用严格解析模式。 严格解析要求格式和输入内容完全匹配，包括分隔符。
```js
dayjs('1970-00-00', 'YYYY-MM-DD').isValid() // true
dayjs('1970-00-00', 'YYYY-MM-DD', true).isValid() // false
dayjs('1970-00-00', 'YYYY-MM-DD', 'es', true).isValid() // false
```
不知道输入字符串的确切格式，但知道它可能是几种中的一种，可以使用数组传入多个格式。
```js
dayjs("12-25-2001", ["YYYY", "YYYY-MM-DD"], 'es', true);
```
###### 支持的解析占位符列表
| 输入 | 例子 | 详情 |
| ---- | ---- | ---- |
| `YY` | 01  | 两位数的年份 |
| `YYYY` | 2001  | 四位数的年份 |
| `M`	 | 1-12	  | 月份，从 1 开始|
| `MM`	 | 01-12	  | 月份，两位数|
| `MMM` | Jan-Dec	| 缩写的月份名称|
| `MMMM`|	January-December|	完整的月份名称
| `D`	 |  1-31	|月份里的一天|
| `DD`	 |01-31	  |月份里的一天，两位数|
| `H`	 |  0-23	|小时|
| `HH`	 |00-23	  |小时，两位数|
| `h`	 |  1-12	|小时, 12 小时制|
| `hh`	 |01-12	  |小时, 12 小时制, 两位数|
| `m`	 |  0-59	|分钟|
| `mm`	 |00-59	  |分钟，两位数|
| `s`	 |  0-59	|秒|
| `ss`	 |00-59	  |秒 两位数|
| `S`	 |  0-9	  |毫秒，一位数|
| `SS`	 |00-99	  |毫秒，两位数|
| `SSS` |000-999	|毫秒，三位数|
| `Z`	 |-05:00	|UTC 的偏移量|
| `ZZ`	 |-0500	  |UTC 的偏移量，两位数|
| `A`	 |  AM PM	|上午 下午 大写|
| `a`	 |  am pm	|上午 下午 小写|
| `Do`	 |1st... 31st	| 带序数词的月份里的一天|
| `X`	 |  1410715640.579|	Unix 时间戳|
| `x`	 |  1410715640579|	Unix 时间戳|

#### Unix 时间戳 (毫秒)
解析传入的一个 Unix 时间戳 (13 位数字，从1970年1月1日 UTC 午夜开始所经过的毫秒数) 创建一个 Day.js 对象。
```js
// 传入的参数必须是 number
dayjs(1318781876406)
dayjs(Date.now())
```
#### Unix 时间戳 (秒)
解析传入的一个 Unix 时间戳 (10 位数字，从1970年1月1日 Utc 午夜开始所经过的秒数) 创建一个 Day.js 对象。
```js
dayjs.unix(1318781876)
```
这个方法是用 dayjs( timestamp * 1000) 实现的，所以传入时间戳里的小数点后面的秒也会被解析。
```js
dayjs.unix(1318781876.721)
```
#### Date 对象
使用原生 Javascript Date 对象创建一个 Day.js 对象。
```js
var d = new Date(2018, 8, 18)
var day = dayjs(d)
```
这将克隆 Date 对象。 
对传入的 Date 对象做进一步更改不会影响 Day.js 对象，反之亦然。

#### 对象{ Object }
您可以传入包含单位和数值的一个对象来创建 Dayjs 对象。
```js
// objectSupport插件
dayjs.extend(objectSupport)
dayjs({ hour:15, minute:10 });
dayjs.utc({ y:2010, M:3, d:5, h:15, m:10, s:3, ms: 123});
dayjs({ year :2010, month :3, day :5, hour :15, minute :10, second :3, millisecond :123});
dayjs({ years:2010, months:3, date:5, hours:15, minutes:10, seconds:3, milliseconds:123});
```
- `day` 和 `date` 都表示月份里的日期。
- `dayjs({})` 返回当前时间。
> ❗ 注意类似new Date(year, month, date)，月份从 0 开始计算。

#### 数组[Array]
您可以传入一个数组来创建一个 Dayjs 对象，数组和结构和 new Date() 十分类似。
```js
// arraySupport插件
dayjs.extend(arraySupport)
dayjs([2010, 1, 14, 15, 25, 50, 125]); // February 14th, 3:25:50.125 PM
dayjs.utc([2010, 1, 14, 15, 25, 50, 125]);
dayjs([2010]);        // January 1st
dayjs([2010, 6]);     // July 1st
dayjs([2010, 6, 10]); // July 10th
```
`dayjs([])` 返回当前时间。
注意类似`new Date(year, month, date)`, 月份从 0 开始计算。

#### [UTC](#utc)
默认情况下，Day.js 会把时间解析成本地时间。
如果想使用 UTC 时间，您可以调用 `dayjs.utc()` 而不是 dayjs()。
在 UTC 模式下，所有显示方法将会显示 UTC 时间而非本地时间。
```js
// UTC插件
dayjs.extend(utc)
// 默认是当地时间
dayjs().format() //2022-07-11T22:00:00+08:00
// UTC 时间
dayjs.utc().format() // 2019-03-06T00:00:00Z
```
此外，在 UTC 模式下， 所有 getters 和 setters 将使用 Date#getUTC* 和 Date#setUTC* 方法而不是 Date#get* 和 Date#set* 方法。
```js
dayjs.utc().seconds(30).valueOf()// => new Date().setUTCSeconds(30)
dayjs.utc().seconds()// => new Date().getUTCSeconds()
```

#### Dayjs对象复制
所有的 Day.js 对象都是 不可变的。 但如果有必要，使用 dayjs#clone 可以复制出一个当前对象。
```js
var a = dayjs()
var b = a.clone()
// a 和 b 是两个独立的 Day.js 对象
```
在 dayjs() 里传入一个 Day.js 对象也会返回一个复制的对象。
```js
var a = dayjs()
var b = dayjs(a)
```
#### 验证 isValid()
返回 **布尔值** 表示 Dayjs的日期是否通过校验。
- 不严格的校验
只检查传入的值能否被解析成一个时间日期
```js
dayjs('2022-01-33').isValid();
// true, parsed to 2022-02-02
dayjs('some invalid string').isValid();
// false
```
- 严格校验
检查传入的值能否被解析，且是否是一个有意义的日期。 最后两个参数 format 和 strict 必须提供。
```js
dayjs.extend(customParseFormat)
dayjs('2022-02-31', 'YYYY-MM-DD', true).isValid();
// false
```



### 操作
Day.js 支持像这样的链式调用：
```js
dayjs('2019-01-25').add(1, 'day').subtract(1, 'year').year(2009).toString()
```

#### Add
返回增加一定时间的复制的 Day.js 对象。
```js
dayjs().add(7, 'day')
```
各个传入的单位对大小写不敏感，支持缩写和复数。 
请注意，缩写是区分大小写的。

##### 支持的单位列表
| 单位 |	缩写	| 详情|
|----| ----| ----|
|day|	d	|日|
|week	|w|	周|
|month|	M|	月|
|quarter|	Q	|季度 ( 依赖 QuarterOfYear 插件 )|
|year|	y	|年|
|hour|	h	|小时|
|minute|	m|	分钟|
|second	|s	|秒|
|millisecond|	ms|	毫秒|

Vue3中使用
```js
import quarterOfYear from 'dayjs/plugin/quarterOfYear';
dayjs.extend(quarterOfYear);
```
#### Subtract
返回减去一定时间的复制的 Day.js 对象。
```js
dayjs().subtract(7, 'year')
```
各个传入的单位对大小写不敏感，支持缩写(ZH, DD)和复数。

[支持的单位列表](#支持的单位列表)

#### Start of Time
返回复制的 Day.js 对象，并设置到一个时间的开始。
```js
dayjs().startOf('year')
```
各个传入的单位对大小写不敏感，支持缩写和复数。
##### startOf支持的单位列表
|单位	 |缩写|	详情|
|----|----|----|
|year	 | y	|今年一月1日上午 00:00|
|quarter|	Q	|本季度第一个月1日上午 00:00 ( 依赖 QuarterOfYear 插件 )|
|month	|M	|本月1日上午 00:00|
|week	|w|	本周的第一天上午 00:00 (取决于国际化设置)|
|isoWeek	| \ |	本周的第一天上午 00:00 (根据 ISO 8601) ( 依赖 IsoWeek 插件 )|
|date	|D	|当天 00:00|
|day|	d	|当天 00:00|
|hour	|h|	当前时间，0 分、0 秒、0 毫秒|
|minute	|m	|当前时间，0 秒、0 毫秒|
|second	|s|	当前时间，0 毫秒|

#### End of Time
返回复制的 Day.js 对象，并设置到一个时间的末尾。

```js
dayjs().endOf('month')
```

各个传入的单位对大小写不敏感，支持缩写和复数。
[EndOf支持的单位列表](#startOf支持的单位列表)

#### Local
返回一个在当前时区模式下的 Day.js 对象。
```js
dayjs.extend(utc)

var a = dayjs.utc()
a.format() // 2019-03-06T00:00:00Z
a.local().format() //2019-03-06T08:00:00+08:00
```
#### UTC
返回一个在 UTC 模式下的 Day.js 对象。
```js
dayjs.extend(utc)

var a = dayjs()
a.format() //2019-03-06T08:00:00+08:00
a.utc().format() // 2019-03-06T00:00:00Z
```
传入 true 将只改变 UTC 模式而不改变本地时间。
```js
dayjs('2016-05-03 22:15:01').utc(true).format() 
// 2016-05-03T22:15:01Z
```



## [Moment.js](http://momentjs.cn/)


