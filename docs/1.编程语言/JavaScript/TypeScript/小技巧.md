# 用法技巧


## 什么是 ？（问号）操作符？

>在TypeScript里面，有**4**个地方会出现问号操作符，他们分别是

### 三元运算符
```js
// 当 isNumber(input) 为 True 是返回 ? : 之间的部分； isNumber(input) 为 False 时
// 返回 : ; 之间的部分
const a = isNumber(input) ? input : String(input);
```
### 参数
```js
// 这里的 ？表示这个参数 field 是一个可选参数
function getUser(user: string, field?: string) {
}
```
### 成员
```js
// 这里的？表示这个name属性有可能不存在
class A {
  name?: string
}

interface B {
  name?: string
}
```
### 安全链式调用
```js
// 这里 Error对象定义的stack是可选参数，如果这样写的话编译器会提示
// 出错 TS2532: Object is possibly 'undefined'.
return new Error().stack.split('\n');

// 我们可以添加?操作符，当stack属性存在时，调用 stack.split。若stack不存在，则返回空
return new Error().stack?.split('\n');

// 以上代码等同以下代码,
const err = new Error();
return err.stack && err.stack.split('\n');
```

## 什么是！（感叹号）操作符？
>在TypeScript里面有**3**个地方会出现感叹号操作符，他们分别是
### 一元运算符
```js
// ! 就是将之后的结果取反，比如：
// 当 isNumber(input) 为 True 时返回 False； isNumber(input) 为 False 时返回True
const a = !isNumber(input);
```

### !!(双)取Boolean值
```js
const bool = !!'boolean'
```

### 成员
```js
// 因为接口B里面name被定义为可空的值，但是实际情况是不为空的，那么我们就可以
// 通过在class里面使用！，重新强调了name这个不为空值
class A implemented B {
  name!: string
}

interface B {
  name?: string
}
```

### 强制链式调用
```js
// 这里 Error对象定义的stack是可选参数，如果这样写的话编译器会提示
// 出错 TS2532: Object is possibly 'undefined'.
new Error().stack.split('\n');

// 我们确信这个字段100%出现，那么就可以添加！，强调这个字段一定存在
new Error().stack!.split('\n');
```

## 什么是 +（加号）操作符？
 
### 快速转 Number
```js
var a = '1'

console.log(typeof a)
console.log(typeof Number(a)) // 普通写法
console.log(typeof +a) // 优雅写法
```

### 与!!混写
>先转为 Number 再转为 Boolean
```js
var a = '0'

console.log(!!a) // 直接转将得到 true，不符合预期
console.log(!!+a) // 先转为 Number 再转为 Boolean，符合预期
```


## 连续解构
>从数组第一个对象元素中提取某个属性，比如：err 对象中包含一个 errors 数组，errors 数组每一个对象都包含一个 msg 属性
```js
err = {
  errors: [
    {
      msg: 'this is a message'
    }
  ]
}
```
快速的提取方法为：
```js
const [{ msg }] = err.errors
```
如果不用解构写法为：
```js
const msg = err.errors[0].msg
```