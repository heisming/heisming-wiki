# 🏭工厂模式

## 定义
工厂模式是由一个方法来决定到底要创建哪个类的实例，而这些实例经常都拥有相同的接口。这种模式主要用在所实例化的类型在编译期并不能确定，而是在执行期决定的情况。

## 生活中的例子
试想你去麦当劳买一个汉堡。你只需要告诉收银员要一个xx汉堡。过一会就会有一个此类型的汉堡被制作出来。而你完全不需要知道这个汉堡是怎么被制作出来的。这个例子中你就是客户端代码，麦当劳就是工厂，负责生产汉堡。汉堡是接口，而具体的某一种汉堡，比如说香辣鸡腿堡，就是实现了汉堡接口的类。

## 分类
- 简单工厂
- 工厂方法

## 区别
简单工厂是将创建对象的步骤放在父类进行，工厂方法使延迟到子类在进行，它们两者都可以总结为：`根据传入的字符串来选择对应的类`

## 实现
### 简单工厂
```js
var UserFactory = function(role) {
  function Admin() {
    this.name = "管理员"
    this.viewpage = ["首页", "查询", "权限管理"]
  }
  function User() {
    this.name = "普通用户"
    this.viewPage = ["首页"， "查询"]
  }
  switch(role) {
    case: 'admin':
      return new Admin();
      break;
    case: 'user':
      return new User();
      break;
    default:
      throw new Error('参数错误，可选参数: admin、user');
  }
}
// admin.name可以修改值，这样是不安全的
var admin = UserFactory('admin');
var user = UserFactory('user');
```

### 工厂方法
```js
// 安全模式创建的工厂方法函数
var UserFactory = function(role) {
  if(this instanceof UserFactory) {
    var s = new this[role]();
    return s;
  } else {
    return new UserFactory(role);
  }
}
// 工厂方法函数的原型中设置所有对象的构造函数
UserFactory.prototype = {
   Admin: function() {
     this.name = "管理员"
     this.viewpage = ["首页", "查询", "权限管理"]
   },
   User: function() {
     this.name = "用户"
     this.viewpage = ["首页", "查询"]
   }
}
// 执行上下文是window对象
var admin = UserFactory('Admin')
var user = UserFactory('User')
admin instanceof UserFactory // false
```

### 再来一个TS的
```ts
interface Product {
  operation(): string;
}

abstract class Creator {
  public abstract factoryMethod(): Product
  public someOperation(): string {
    // this指向？
    const product = this.factoryMethod();
    return `Creator: The same creator's code has just worked with ${product.operation()}`;
  }
}

class ConcreteCreator1 extends Creator {
  public factoryMethod(): Product {
    return new ConcreteProduct1();
  }
}

class ConcreteCreator2 extends Creator {
  public factoryMethod(): Product {
    return new ConcreteProduct2();
  }
}

class ConcreteProduct1 implements Product{
  public operation(): string {
    return '{Result of the ConcreteProduct1}';
  }
}

class ConcreteProduct2 implements Product{
  public operation(): string {
    return '{Result of the ConcreteProduct2}';
  }
}

function clientCode(creator: Creator) {
  // ...
  console.log('Client: I\'m not aware of the creator\'s class, but it still works.');
  console.log(creator.someOperation());
  // ...
}

console.log('App: Launched with the ConcreteCreator1.');
clientCode(new ConcreteCreator1());
console.log('');

console.log('App: Launched with the ConcreteCreator2.');
clientCode(new ConcreteCreator2());
```

## 适合应用场景
- 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。

工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。
例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。

## ✔Demo（循序渐进）
### 音乐推荐器1.0版本
需求：是能够根据用户选择的音乐风格，推荐不同风格的歌曲清单。
```ts
class RecommendMusicService {
  recommend(style: string): Array<string> {
    const recommendMusicList: string[] = []
    switch(style) {
      case 'metal':
        recommendMusicList.push("Don't cry")
        break;
      case 'country':
        recommendMusicList.push("Hotel california")
        break;
      case 'grunge':
        recommendMusicList.push("About a girl")
        break;
      default:
        recommendMusicList.push("My heart will go on")
        break;
    }
    return recommendMusicList
  }
}
```
recommed 方法太长了，重构下，把每种音乐风格的推荐逻辑封装到相应的方法中。这样推荐方法就可以复用了。
```ts
class RecommendMusicService {
  recommend(style: string): Array<string> {
    const recommendMusicList: string[] = []
    switch(style) {
      case 'metal':
        this.recommendMetal(recommendMusicList)
        break;
      case 'country':
        this.recommendCountry(recommendMusicList)
        break;
      case 'grunge':
        this.recommendGrunge(recommendMusicList)
        break;
      default:
        this.recommendPop(recommendMusicList)
        break;
    }
    return recommendMusicList
  }

  private recommendPop(recommendMusicList: Array<string>): void {
    recommendMusicList.push("My heart will go on")
    recommendMusicList.push("Beat it")
  }
  private recommendGrunge(recommendMusicList: Array<string>): void {
    recommendMusicList.push("About a girl")
    recommendMusicList.push("Smells like teen spirit")
  }
  private recommendCountry(recommendMusicList: Array<string>): void {
    recommendMusicList.push("Hotel california")
    recommendMusicList.push("Take Me Home Country Roads")
  }
  private recommendMetal(recommendMusicList: Array<string>): void {
    recommendMusicList.push("Don't cry")
    recommendMusicList.push("Fade to black")
  }
}
```
现在好了，但是违反了设计模式6大原则的开闭原则----对扩展开放，对修改关闭。
面对新风格推荐的需求，我们一直都在修改 RecommendMusicService 这个类。以后每次有新风格推荐要添加，都会导致修改 RecommendMusicService 。
那么如何做到实现新的风格推荐需求时，满足开闭原则呢？

### 音乐推荐器2.0版本
添加新需求时，如何做到不修改，去扩展？是不是想到了单一职责？是的，类的职责越单一，那么它就越稳定。RecommendMusicService 类的职责太多了，负责n种风格的推荐。OK，那么我们第一件事就是要减少 RecommendMusicService 类的职责，把每种不同风格的推荐提取到不同的类当中。
比如MetalMusicRecommendService、PopMusicRecommendService、CountryMusicRecommendService。这些类都可以通过 recommed 方法生成推荐的歌曲清单。而 RecommendMusicService 类只是通过调用不同 MusicRecommendService 的 recommed 方法来实现推荐。代码如下：

```ts
class CountryMusicRecommendService {
  recommend(): Array<string> {
    const recommendMusicList: string[] = []
    recommendMusicList.push("Hotel california")
    recommendMusicList.push("Take Me Home Country Roads")
    return recommendMusicList
  }
}

class GrungeMusicRecommendService {
  recommend(): Array<string> {
    const recommendMusicList: string[] = []
    recommendMusicList.push("About a girl")
    recommendMusicList.push("Smells like teen spirit")
    return recommendMusicList
  }
}

class PopMusicRecommendService {
  recommend(): Array<string> {
    const recommendMusicList: string[] = []
    recommendMusicList.push("My heart will go on")
    recommendMusicList.push("Beat it")
    return recommendMusicList
  }
}

class MetalMusicRecommendService {
  recommend(): Array<string> {
    const recommendMusicList: string[] = []
    recommendMusicList.push("Don't cry")
    recommendMusicList.push("Fade to black")
    return recommendMusicList
  }
}

class RecommendMusicService {
  private countryMusicRecommendService = new CountryMusicRecommendService()
  private grungeMusicRecommendService = new GrungeMusicRecommendService()
  private popMusicRecommendService = new PopMusicRecommendService()
  private metalMusicRecommendService = new MetalMusicRecommendService()

  recommend(style: string) {
    let recommendMusicList: string[] = []
    switch(style) {
      case 'metal':
        recommendMusicList = this.metalMusicRecommendService.recommend()
        break;
      case 'country':
        recommendMusicList = this.countryMusicRecommendService.recommend()
        break;
      case 'grunge':
        recommendMusicList = this.grungeMusicRecommendService.recommend()
        break;
      default:
        recommendMusicList = this.popMusicRecommendService.recommend()
        break;
    }
    return recommendMusicList;
  }
}

console.log(new RecommendMusicService().recommend(""));
```
改造后，如果有了新音乐风格推荐的需求，只需要增加相应的 xxxMusicRecommendService 类。然后在 RecommendMusicService 中增加相应分支即可。这样就做到了开闭原则。那么还有什么违背设计原则的地方吗？RecommendMusicService 是不是依赖的 xxMusicRecommendService 类太多了？
没错，而且这么多类，实际上都是做推荐的事情，且都是通过 recommend 方法提供推荐结果。这完全可以抽象出接口，比如 MusicRecommendInterface。那么 RecommendMusicService 依赖 MusicRecommendInterface 就可以了。这解决了依赖反转问题----**应该依赖接口，而不是依赖具体实现**。
单一职责和依赖反转原则。依赖 MusicRecommendInterface 没问题，但是不同的音乐风格，怎么能实例化 MusicRecommendInterface 的某个具体实现呢？工厂模式于是就应运而生了！

### 音乐推荐器3.0版本
工厂模式解决的是类的实例化。无论你需要哪种风格的 MusicRecommendService，只需要告诉工厂，工厂会给你实例化好你需要的具体实现。而工厂能做到这些是基于继承和多态。
RecommendMusicService 只需要依赖 MusicRecommendInterface，具体需要哪个MusicRecommendService 的实现，只需要告诉 RecommendServiceFactory 即可。MusicRecommendService 拿到具体的实现后调用它的 recommand 方法，就可以得到相应风格的推荐歌曲清单。
首先我们需要定义所有 MusicRecommendService 要实现的接口，很简单，只有一个 recommend 方法：

```ts
interface MusicRecommendInterface {
  recommend() : Array<string>;
}

class CountryMusicRecommendService implements MusicRecommendInterface {
  recommend(): Array<string> {
    const recommendMusicList: string[] = []
    recommendMusicList.push("Hotel california")
    recommendMusicList.push("Take Me Home Country Roads")
    return recommendMusicList
  }
}

class GrungeMusicRecommendService implements MusicRecommendInterface {
  recommend(): Array<string> {
    const recommendMusicList: string[] = []
    recommendMusicList.push("About a girl")
    recommendMusicList.push("Smells like teen spirit")
    return recommendMusicList
  }
}

class PopMusicRecommendService implements MusicRecommendInterface {
  recommend(): Array<string> {
    const recommendMusicList: string[] = []
    recommendMusicList.push("My heart will go on")
    recommendMusicList.push("Beat it")
    return recommendMusicList
  }
}

class MetalMusicRecommendService implements MusicRecommendInterface {
  recommend(): Array<string> {
    const recommendMusicList: string[] = []
    recommendMusicList.push("Don't cry")
    recommendMusicList.push("Fade to black")
    return recommendMusicList
  }
}

// 工厂模式中的工厂代码了
class MusicRecommendServiceFactory {
  createMusicRecommend(style: string): MusicRecommendInterface {
    switch (style) {
      case 'metal':
        return new MetalMusicRecommendService()
      case 'country':
        return new CountryMusicRecommendService()
      case 'grunge':
        return new GrungeMusicRecommendService()
      default:
        return new PopMusicRecommendService()
    }
  }
}

console.log(new MusicRecommendServiceFactory().createMusicRecommend("").recommend())
```
>工厂模式解决的是类的实例化问题。

![](assets/images/0.png)