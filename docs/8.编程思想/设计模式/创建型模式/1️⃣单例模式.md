# 1️⃣单例模式
## 定义
保证一个类仅有一个实例，并提供一个访问它的全局访问点。
## 生活中的例子
## 应用场景
- 比如全局缓存、浏览器中的window对象等。
- 当我们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。


## 概念
> 一个对象/实例只能被创建一次，创建之后缓存起来，以后继续使用；即，一个系统中只有一个。
举例：
- 登录框，遮罩层，一个系统只有一个即可，多了无用。
- Vuex Redux的store、EventBus等,一个系统中只能有一个，多了会出错。

伪代码：
```ts
class LoginModal {}
// A
const modal1 = new LoginModal()
// B
const modal2 = new LoginModal()
// C
const modal3 = new LoginModal()


class Store {}
// A
const store1 = new Store()
// B
const store2 = new Store()
// A和B不是一个实例，数据无法进行数据交互
```

非单例：
```ts
class Foo {
    name: string
    constructor(name: string) {
        this.name = name
    }
    getName() {
        return this.name
    }
    // 静态
    static flag: string = 'xxx'
    static getFlag() {
      return this.flag
    }
}

const f1 = new Foo('zhangsan')
f1.name // zhangsan
f1.getName() // zhangsan

const f2 = new Foo('lisi')
f2.name // lisi
f2.getName() // lisi

// 静态属性
Foo.flag
Foo.getFlag()
```

ts单例：
```ts
class SingleTon {
    name: string
    // private 无法在外面实例化new
    private constructor(name: string) {
        this.name = name
    }
    // 单例的对象。无法在外面获取实例
    private static instance: SingleTon | null
    // 获取单例 
    static getInstance(name: string): SingleTon {
        if(SingleTon.instance == null) {
            // 这里也可以写成 this.instance，注意和实例方法中的this的区别.
            SingleTon.instance = new SingleTon(name);
        }
        return SingleTon.instance; // 单例模式
    }
}

export default SingleTon.getInstance('xyz') // 正确获取单例对象的方式

const s1 = SingleTon.getInstance('xyz');
const s2 = SingleTon.getInstance('xyz')
console.log(s1 === s2); // true;
SingleTon.instance // 错误

// 漏洞, 用private修饰构造方法即可
const s1 = new SingleTon('xxx')
const s2 = new SingleTon('uuu')
```
[单例模式](./assets/drowio/singleton.drawio ':include :type=code')

使用js闭包实现单例模式
```js
function genGetInstance() {
    let instance // 闭包

    class Singleton {}

    return () => {
        if (instance == null) {
            this.instance = new Singleton()
        }
        return instance;
    }
}

const getInstance = genGetInstance()
// 为啥不直接执行 const s = genGetInstance()
const s1 = getInstance();
const s2 = getInstance();

console.log(s1 === s2)
```
或使用模块化闭包
```js
// getInstance.js文件
let instance 
class Singleton {}

export default () => {
    if (instance == null) {
        instance = new Singleton()
    }
    return instance
}
```
main.js
```js
import getInstance from './getInstance.js'
const s1 = getInstance()
const s2 = getInstance()
```

是否符合设计原则？
- 内部封装 getInstance,高内聚,低耦合
- JS是单线程语言，如果是java等多线程语言，单例模式需要加线程锁

### 场景
登录框
```ts
class LoginForm {
    private state: string = 'hide' // 'hide' | 'show'

    private constructor() {}
    show() {
        if (this.state === 'show') {
            console.log('show already')
            return 
        }
        console.log('show LoginForm')
        this.state = 'show'
    }
    hide() {
        if (this.state === 'hide') {
            console.log('hide LoginForm')
            return 
        }
        console.log('hide LoginForm')
        this.state = 'hide'
    }
    private static instance: LoginForm | null = null
    static getInstance() : LoginForm {
        if(this.instance == null) {
            this.instance = new LoginForm()
        }
        return this.instance
    }
}

const loginForm1 = LoginForm.getInstance()
const loginForm2 = LoginForm.getInstance()

console.log(loginForm1 === loginForm2) // true
```
自定义事件EventBus全局唯一
store

demo
```ts
// i did
class Axios {
  private static instance: Axios | null = null 
  private constructor () {}
  static getInstance() {
    if (this.instance == null) {
      return this.instance = new Axios();
    }
    return this.instance
  }
}

const axios1 = Axios.getInstance();
const axios2 = Axios.getInstance();

console.log(axios1 === axios2)
console.log(axios1 === Axios.getInstance())
```
