# 设计模式原则
> 目前是六大原则

## 单一职责原则（Single Responsibility Principle）
一个程序只做好一件事，如果功能过于复杂就拆分开，每个部分保持独立。

## 开放封闭原则(Open-Closed Principle, OCP)💗
对修改封闭，对扩展开放，`**软件设计的终极目标**`，即要设计一种机制，当需求发生变化时，根据这种机制扩展代码，而不是修改原有的代码。

## 里(李)氏代换原则(Liskov Substitution Principle, LSP)
子类能覆盖父类，父类能出现的地方子类就能出现————前端应用较少

## 接口隔离原则(Interface Segregation Principle, ISP)
保持接口的单一独立，避免出现“胖接口”。类似于单一职责原则，只不过前者说的比较同一，后者是对单独接口的规定。JS中没有接口，因此体现较少。

## 依赖倒置原则（Dependence Inversion Principle，DIP）
面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。
```ts
function fn(p: Student) {} // 依赖具体的类（依赖于具体）
function fn(p: IPerson) {} // 依赖接口（依赖于抽象）
```

## 迪米特法则(Law of Demeter, LoD) or 最少知识原则（The Least Knowledge Principle）
一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话
```ts
// 加载图片
function loadImg(src: string) {
  const promise = new Promise((resolve, reject) => {
    const img = document.createElement('img')
    img.onload = () => {
      resolve(img)
    }
    img.onerror = () => {
      reject('图片加载失败')
    }
    img.src = src
  })
  return promise
}

const src = "www.baidu.com"

const result = loadImg(src)
result.then((img: HTMLImageElement) => {
  console.log('img.width', img.width);
  return img
}).then((img: HTMLImageElement) => {
  console.log('img.height', img.height);
  return img
}).catch((err) => {
  console.log(err);
})
```
- 单一职责原则：每个`then`中的逻辑只做好一件事，如果要做多个就用多个`then`
- 开放封闭原则：如果这个需求要修改，那去扩展（增加）`then`即可，现有的逻辑不用修改，即对扩展开放、对修改封闭。
引申两点：
- 其是S和O是相辅相成的，互相依赖
- 开放封闭原则的好处不止于此，从整个软件开发流程看，减少现有逻辑的更改，也会减少测试的成本。
