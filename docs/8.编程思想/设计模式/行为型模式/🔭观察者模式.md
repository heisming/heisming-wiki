# 🔭观察者模式(发布/订阅)
> UI编程最常用

DOM事件和Vue/React生命周期都是。
```html
<button id="btn">btn</button>
<script>
  const $btn = $('#btn')
  $btn.click(function() {
    console.log(1)
  })
  $btn.click(function() {
    console.log(2)
  })
  $btn.click(function() {
    console.log(3)
  })
</script>
```

## 示例
```ts
class Subject {
    private state: number = 0 
    private observers: Observer[] = []
    getState(): number {
        return this.state
    }
    setState(newState: number) {
        this.state = newState
        this.notify()
    }
    attach(observer: Observer) {
        this.observers.push(observer)
    }
    private notify() {
        this.observers.forEach(observer => {
            observer.update(this.state)
        })
    }
}
// 1:n
class Observer {
    name: string
    constructor(name: string) {
        this.name = name
    }
    update(state: number) {
        console.log(`My name is ${this.name}, my state is ${state}`)
    }
} 

const sub = new Subject();
const observer1 = new Observer('barry');
sub.attach(observer1);
const observer2 = new Observer('merry');
sub.attach(observer2);

sub.setState(19960402)
```

[SO](./assets/drowio/Subject_Observer.drawio ':include :type=code')


是否符合设计原则
- Observer和Subject**分离，解耦**
- Observer可自由扩展
- Subject可自由扩展

## `场景`
DOM事件
Vue/React组件生命周期
![](https://cn.vuejs.org/assets/lifecycle.16e4c08e.png)
Vue-watch和watchEffect
[watch](https://cn.vuejs.org/guide/essentials/watchers.html)
Vue组件更新过程
> PS: React组件的更新过程不是，是主动通过`setState`触发的，而非响应式监听。

![Vue](https://ask.qcloudimg.com/http-save/yehe-3656368/4e2f2a5c51723b209f9a28bdeaebb0a4.png?imageView2/2/w/1620)
各种异步回调
- 定时器setTimeout setInterval
- Promise.then
- Nodejs - stream readline httpServer
- MutationObserver

**Node**
```js
const fs = require('fs')
const readStream = fs.createReadStream('../README.md')
// 文字的字符长度
let length = 0
readStream.on('data', function(chunk) {
  // 每次最大读取65536个字符
  const currentLength = chunk.toString().length;
  console.log('current length', currentLength)
  length += currentLength
})
readStream.on('end', function() {
  console.log(length)
})
```
修改为按照行数来
```js
const readline = require('readline')
const fs = require('fs')
const rl = readline.createInterface({
  input: fs.createReadStream('./README.md')
})
// 文件有多少行
let lineNum = 0
rl.on('line', function(line) {
  lineNum++
})
rl.on('close', function() {
  console.log('lineNum', lineNum)
})
```

http.server
```js
const http  = require('http')

// http
function serverCallback(req, res) {
  console.log('url', req.url)
  res.end('hello')
}

http.createServer(serverCallback).listen(8080)
console.log('listen 8080 port')
```


**MutationObserver监听DOM变化**
```html
<html>
  <head></head>
  <title></title>
  <body>
    <div class="container">
      <h1>test</h1>
      <p>demo</p>
      <p>good</p>
    </div>
  </body>
</html>
```
```js
// mutationObserver的回调函数
function callback(records: MutationRecord[], observer: MutationObserver) {
  for (let record of records) {
    console.log('record', record);
  }
}

const observer = new MutationObserver(callback); // nodejs httpserver

const elem = document.getElementById('container')
if (elem) {
  // 开始启动监听
  observer.observe(elem, {
    attributes: true, // 监听属性变化
    attributeOldValue: true, // 变化之后，记录旧的属性值
    childList: true,  // 监听子节点的变化（增加，删除）
    characterData: true, // 监听节点的内容或文本变化
    subtree: true, // 递归监听下级所有节点
  })
}

// 停止监听
// observe.disconnect()
```
操作验证监听：在浏览器控制台
```js
// 操作一
const container = document.getElementById('container')
container.innerHtml = 'come on'
// 操作二
const p1 = document.createElement('p')
p1.innerHtml = 'beStrong'
container.appendChild(p1)
```

## 观察者VS发布订阅
- 发布订阅不属于传统的23种设计模式
- 是观察者模式的另一种实现形式
- 观察者：S和O直接绑定，无中介媒介
  - 如`addEventListener`绑定事件
- 发布订阅：P和O互相不认识，中介有媒介
  - 如`event`自定义事件

> 最明显的差别就是P/O需要手动触发`emit`

```js
// 绑定
event.on('event-key', () => {
// 事件1
})
event.on('event-key', () => {
// 事件2
})
// 触发执行【区别✔】
event.emit('event-key')
```
[发布订阅VS观察者](./assets/drowio/compare.drawio ':include :type=code')


### 场景
#### 自定义事件
   
#### postMessage


