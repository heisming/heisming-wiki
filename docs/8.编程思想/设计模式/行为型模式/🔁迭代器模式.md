# 🔁迭代器模式

- 顺序访问有序结构（如数组、NodeList）
- 不知道数据的长度和内部结构
- 高内聚、低耦合

> 一句话：让你能在不暴露集合底层表现形式（列表、栈和树等）的情况下遍历集合中所有的元素

**普通for循环不是迭代器, 不符合高内聚低耦合(需要知道对象的内部结构).**
```js
const arr = [10, 20, 30]
// 需要知道数组的长度
const length = arr.length
for (let i = 0; i < length; i++) {
  // 需要通过arr[i]的形式来得到item
  console.log(arr[i])
}
```


**简易迭代器**
```js
// 不知道长度
// 不知道如何获取item
const pList = document.querySelectorAll('p')
pList.forEach(p => console.log(p))
```

UML

```ts
class DataIterator {
  private data: number[]
  private index = 0
  constructor(container: DataContainer) {
    this.data = container.data
  }
  next(): number | null {
    if (this.hasNext()) {
      return this.data[this.index++]
    }
    return null
  }
  hasNext(): boolean {
    if (this.index >= this.data.length) return false
    return true
  }
}

class DataContainer {
  data: number[] = [10, 20, 30]
  // 获取迭代器
  getIterator() { return new DataIterator(this)  }
}

const container = new DataContainer()
const iterator = container.getIterator()
while(iterator.hasNext()) {
  const num = iterator.next();
  console.log(num)
}
```

是否符合设计原则？
开放封闭原则（对扩展开放，对修改关闭）
- 使用者和目标数据分离，解耦
- 目标数据自行控制内部迭代逻辑
- 使用者不关心目标数据的内部结构

## 场景
JS有序对象，都内置迭代器
- 字符串 
  - `const str = 'abc' =执行=> str[0] str[1] str[2]`
- 数组
- NodeList等DOM集合
  - `document.querySelectorAll('p')`
- Map
- Set
- arguments
  - `function fn() { console.log(arguments) } fn(1, 2, 3, 4)`

> ❗对象object不是有序结构
```js
const obj = {}
obj[0] = 'a'
obj[1] = 'b'
// { 0: 'a', 1: 'b'}
Object.keys(obj) // ['0', '1']
// 再反过来
const obj1 = {}
obj1[1] = 'b'
obj1[0] = 'a'
// { 0: 'a', 1: 'b'}
Object.keys(obj1) // ['0', '1']
```
> 结论：给Obj赋值是不能保证有序的


### Symbol.iterator(js内置迭代器)
每个有序对象，都内置了`Symbol.iterator`属性，属性值是一个函数。
执行该函数将返回iterator迭代器，有`next()`方法，执行返回`{ value, done }`结构。
```js
// 拿数组距离，其它类型也一样
const arr = [10, 20, 30]
const iterator = arr[Symbol.iterator]()
iterator // Array Iterator {}
iterator.next() // {value: 10, done: false}
iterator.next() // {value: 20, done: false}
iterator.next() // {value: 30, done: false}
iterator.next() // {value: undefined, done: true}
```
另外，有些对象的API也会生成有序对象
```js
const map = new Map([ ['k1', 'v1'], ['k2', 'v2'] ])
const mapIterator = map[Symbol.iterator]()
// or
const values = map.values() // 并不是Array
const valuesIterator = values[Symbol.iterator]()
// map还有keys entries等方法可以获取内置的迭代器
```

### 自定义迭代器
```ts
interface IteratorRes {
  value: number | undefined
  done: boolean
}

class CustomIterator {
  private length = 3
  private index = 0

  next(): IteratorRes {
    this.index++
    if (this.index <= this.length) {
      return { value: this.index, done: false}
    }
    return { value: undefined, done: true}
  }
  [Symbol.iterator]() {
    return this
  }
}

const iterator = new CustomIterator()
// or
const it = iterator[Symbol.iterator]()
console.log(iterator.next())
console.log(it.next())
```

### 有序结构(迭代器)的作用
for...of
> ❤所有有序结构(迭代器)，都支持for...of语法

#### 数组操作：解构/扩展操作符、Array.from
```js
const someDomList = document.querySelectorAll('p')
// 数组解构
const [node1, node2] = someDomList
// or
const set = new Set([100, 200])
const [n1, n2] = set

// 扩展操作符
const arr = [...someDomList]
const newArr = [...set]
const newDomList = [...someDomList]
// Array.from()
const arr = Array.from(someDomList) // [p, p, p]
```
#### 创建Map和Set
```js
// 传入有序结构
const map = new Map([ ['k1', 'v1'], ['k2', 'v2'] ])
const set = new Set(someDomList)
```
#### Promise.all和Promise.race
```js
// 传入有序结构
Promise.all([promise1, promise2, promise3])
Promise.race([promise1, promise2, promise3])
```

#### yield*操作符
Generator生成器
1. 基本使用
```js
function* genNums() {
  yield 10
  yield 20
  yield '30'
}
const numsIterator = genNums() // 返回迭代器，同 any[Symbol.Iterator]
console.log(numsIterator.next())
console.log(numsIterator.next())
console.log(numsIterator.next())
// for...of
for (let n of numsIterator) {
  console.log(n)
}
// 解构
const [n1, n2] = numsIterator;
```
2. yield*语法
```js
function* genNums(arr) {
  yield* [10, 20, '30'] // 可以使用有序结构，已经实现了[Symbol.Iterator]
  // or
  for(let i = 0; i < arr.length; i++) {
    yield arr[i]
  }
}
const numsIterator = genNums()
for (let n of numsIterator) {
  console.log(n)
}
```
```js
class CustomIterator {
  private data: number[]
  constructor() {
    this.data = [100, 200, 300]
  }
  * [Symbol.iterator]() {
    yield* this.data
  }
}
const iterator = new CustomIterator()
for(let n of iterator) {
  console.log(n)
}
```

3. yield遍历DOM树
> 深度优先遍历
```html
<body>
  <p>demo</p>
  <div id="container">
    <p><b>hello </b><em>world</em></p>
    <p><img src="" /></p>
  </div>
</body>
<script>
  function* traverse(elementList: Element[]): any {
    for (const elem of elementList) {
      yield elem
      const children = Array.from(elem.children)
      if (children.length) {
        yield* traverse(children) // 生成迭代器
      }
    }
  }
  const container = document.getElementById('container')
  if (container) {
    for(let node of traverse(container)) {
      console.log(node)
    }
  }
</script>
```
> Generator和迭代器的关系：即鸡和蛋的关系
> 简单的for循环不时迭代器，迭代器是解决for循环的问题