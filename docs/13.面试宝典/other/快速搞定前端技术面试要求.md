# 《快速搞定前端技术一面 匹配大厂面试要求》

![](D:\大前端学习\MarkDown\0基础\good\思维导图.png)

## 1、HTML&CSS面试题

### HTML

#### 1、如何理解HTML语义化？

```html
<div>标题</div>
<div>
	<div>一段文字</div>
    <div>
    	<div>列表1</div>
        <div>列表2</div>
    </div>
</div>
```

```html
<h1>标题</h1>
<div>
	<p>一段文字</p>
    <ul>
    	<li>列表1</li>
        <li>列表2</li>
    </ul>
</div>
```

根据文档页面结构合理的写出让人（增加代码可读性）和机器（搜索引擎SEO优化）都方便读取的代码，即使CSS样式丢失结构也会很清晰



#### 2、默认情况下，哪些HTML标签是块状元素，哪些是内联元素？

块状元素：div, p, h1~h6, ul, ol, li, table

内联元素：span, a, i, u, strong, 



#### 3、W3C标准

##### **1、什么是DOCTYPE**

DOCTYPE是document type(文档类型)的简写，用来说明你用的XHTML或者HTML是什么版本。其中的DTD(例如xhtml1-transitional.dtd)叫文档类型定义，里面包含了文档的规则，浏览器就根据你定义的DTD来解释你页面的标识，并展现出来。要建立符合标准的网页，DOCTYPE声明是必不可少的关键组成部分；除非你的XHTML确定了一个正确的DOCTYPE，否则你的标识和CSS都不会生效。
XHTML 1.0 提供了三种DTD声明可供选择：

i) **过渡的**(Transitional)：要求非常宽松的DTD，它允许你继续使用HTML4.01的标识(但是要符合xhtml的写法)。 

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">	
```

ii) **严格的**(Strict)：要求严格的DTD，你不能使用任何表现层的标识和属性，例如

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

iii) **框架的**(Frameset)：专门针对框架页面设计使用的DTD，如果你的页面中包含有框架，需要采用这种DTD。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
```

注：DOCTYPE声明必须放在每一个XHTML文档最顶部，在所有代码和标识之上。

##### **2、名字空间 namespace**

```html
<html xmlns="http://www.w3.org/1999/xhtml" lang="gb2312">
```

通常我们HTML4.0的代码只是<html>，这里的"xmlns"是什么呢？
这个“xmlns”是XHTML namespace的缩写，叫做“名字空间”声明。XHTML是HTML向XML过渡的标识语言，它需要符合XML文档规则，因此也需要定义名字空间。又因为XHTML1.0不能自定义标识，所以它的名字空间都相同，就是"http://www.w3.org/1999/xhtml"。目前阶段我们只要照抄代码就可以了。

##### **3、定义语言编码**

```html
<meta http-equiv=“Content-Type” content=“text/html; charset=gb2312” />
```

为了被浏览器正确解释和通过W3C代码校验，所有的XHTML文档都必须声明它们所使用的编码语言，我们一般使用gb2312(简体中文)，制作多国语言页面也有可能用Unicode、ISO-8859-1等，根据你的需要定义。
注：如果忘记了定义语言编码,可能就会出现,你在DW(dreamweaver)做完一个页面，第二次打开时所有的中文变成了乱码。

##### **4、Javascript定义**

Js必须要用<script language="javascript" type="text/javascript">来开头定义，而不是原来的<script language=javascript>或干脆直接<script>，并且需要加个注释符<!--  -->，以保证不在不支持js的浏览器上直接显示出代码来。 

```html
<script language="javascript" type="text/javascript"> 
//<![CDATA[ 
function show_layout(selObj){ 
var n = selObj.options[selObj.selectedIndex].value; 
document.getElementById('stylesheet').href = n; 
} 
//]]> 
</script> 
```

##### **5、CSS定义**

CSS必须要用<style type="text/css">开头来定义，而不是原来的直接<style>，也不建议直接写在内容代码里如：<div style="padding-left:20px;"></div>，并需要加个注释符<!-- --> 

```html
<style type="text/css" media="screen"> 
<!-- 
body {margin:0px;padding:0px;font-size:12px;text-align:center} 
--> 
</style>
```

为保证各浏览器的兼容性，在写CSS时请都写上数量单位，例如：错误：.space_10{padding-left:10} 正确：.space_10 {padding-left:10px}

##### **6、不要在注释内容中使用“--”**

“--”只能发生在XHTML注释的开头和结束，也就是说，在内容中它们不再有效。
例如下面的代码是无效的：<!--这里是注释-----------这里是注释-->
正确的应用等号或者空格替换内部的虚线。<!--这里是注释============这里是注释-->

##### **7、所有标签的元素和属性的名字都必须使用小写**

与HTML不一样，XHTML对大小写是敏感的，<title>和<TITLE>是不同的标签。XHTML要求所有的标签和属性的名字都必须使用小写。例如：<BODY>必须写成<body>。大小写夹杂也是不被认可的，通常dreamweaver自动生成的属性名字"onMouseOver"也必须修改成"onmouseover"。

##### **8、所有的属性必须用引号""括起来**

在HTML中，你可以不需要给属性值加引号，但是在XHTML中，它们必须被加引号。
例如：<height=80>必须修改为：<height="80">。
特殊情况，你需要在属性值里使用双引号，你可以用"，单引号可以使用&apos;，例如：<alt="say&apos;hello&apos;">

##### **9、把所有<和&特殊符号用编码表示**

任何小于号（<），不是标签的一部分，都必须被编码为 &lt;
任何大于号（>），不是标签的一部分，都必须被编码为 &gt;
任何与号（&），不是实体的一部分的，都必须被编码为 &amp; 

错误：
http://club.china.alibaba.com/forum/thread/search_forum.html?action=SearchForum&doSearchForum=true&main=1&catcount=10&keywords=mp3 
正确：
http://club.china.alibaba.com/forum/thread/search_forum.html?action=SearchForum&amp;doSearchForum=true&amp;main=1&amp;catcount=10&amp;keywords=mp3

##### **10、给所有属性赋一个值**

XHTML规定所有属性都必须有一个值，没有值的就重复本身。例如： 
<td nowrap><input type="checkbox" name="shirt" value="medium" checked>必须修改为：
<td nowrap="nowrap"><input type="checkbox" name="shirt" value="medium" checked="checked" />

##### **11、所有的标记都必须要有一个相应的结束标记**

以前在HTML中，你可以打开许多标签，例如<p>和<li>而不一定写对应的</p>和</li>来关闭它们。但在XHTML中这是不合法的。XHTML要求有严谨的结构，所有标签必须关闭。如果是单独不成对的标签，在标签最后加一个"/"来关闭它。 例如：<br />

```html
<img height="80" alt="网页" title="网页" src="logo.gif" width="200" /> 
```

特殊结束标记 

错误：Document.write("<td width=\"300\"><a href=\"1.html\">ok</a></td>");

正确: Document.write("<td width=\"300\"><a href=\"1.html\">ok<\/a><\/td>");

在js中，原已结束的标签需要再转义再结束。

##### **12、所有的标记都必须合理嵌套** 

同样因为XHTML要求有严谨的结构，因此所有的嵌套都必须按顺序，以前我们这样写的代码： <p><b></p></b>必须修改为：<p><b></b></p> 就是说，一层一层的嵌套必须是严格对称。

错误：<table><tr><form><td></td></form></tr></table>

正确：<form><table><tr><td></td></tr></table></form>

##### **13、图片添加有意义的alt属性**

例如：

```html
<img src="logo.gif" width="100" height="100" align="middle" boder="0" alt="w3cschool" />
```

尽可能的让作为内容的图片都带有属于自己的alt属性。
同理：添加文字链接的title属性。

```html
<a href="#" target="_blank" title="新闻新闻新闻新闻">新闻新闻…</a>，
```

在一些限定字数的内容展示尤为重要，帮助显示不完成的内容显示完整，而不用考虑页面会因此而撑大。

##### **14、在form表单中增加lable，以增加用户友好度** 

```html
<form action="http://somesite.com/prog/adduser" method="post">
  <label for="firstname">first name: </label>
  <input type="text" id="firstname" />
  <label for="lastname">last name: </label>
  <input type="text" id="lastname" />
</form>
```

**附录一
1、XHTML校验**
校验网址：http://validator.w3.org/
校验方式：网址校验、文件上传校验
一般选择"Show Source"和"Verbose Output"可以帮助你找到错误代码所在行和错误原因。

XHTML校验常见错误原因对照表
1.No DOCTYPE Found! Falling Back to HTML 4.01 Transitional--未定义DOCTYPE。
2.No Character Encoding Found! Falling back to UTF-8.--未定义语言编码。
3.end tag for "img" omitted, but OMITTAG NO was specified--图片标签没有加"/"关闭。
4.an attribute value specification must be an attribute value literal unless SHORTTAG YES is specified--属性值必须加引号。
5.element "DIV" undefined---DIV标签不能用大写，要改成小写div。
6.required attribute "alt" not specified---图片需要加alt属性。
7.required attribute "type" not specified---JS或者CSS调用的标签漏了type属性。
其中最最常见的错误就是标签的大小写问题了。通常这些错误都是关联的，比如忘记了一个</li>其他<li>标签都会报错，所以不要看到一堆的错误害怕，通常解决了一个错误，其他的错误也都没有了。

**附录二
2、CSS2校验**
校验网址：http://jigsaw.w3.org/css-validator/
校验方式：网址校验、文件上传校验、直接贴入代码校验
校验成功，会显示"恭喜恭喜，此文档已经通过样式表校验! "。校验失败，会显示两类错误：错误和警告。错误表示一定要修正，否则无法通过校验；警告表示有代码不被W3C推荐,建议修改。
同样，通过检验后，可以放置一个CSS校验通过图标。

CSS2校验常见错误原因对照表
1.(错误)无效数字：color909090不是一个color值，909090---十六进制颜色值必须加"#"号，即#909090
2.(错误)无效数字：margin-topUnknown dimension：6pixels ---pixels不是一个单位值，正确写法6px
3.(错误)属性：scrollbar-face-color 不存在 : #eeeeee --- 定义滚动条颜色是非标准的属性
4.(错误)值：cursorhand不存在 : hand是非标准属性值，修改为cursor:pointer
5.(警告)Line:0 font-family: 建议你指定一个种类族科作为最后的选择 --W3C建议字体定义的时候，最后以一个类别的字体结束，例如"sans-serif"，以保证在不同操作系统下，网页字体都能被显示。
6.(警告)Line:0 can't find the warning message for otherprofile --表示在代码中有非标准属性或值，校验程序无法判断和提供相应的警告信息。

### CSS（占比20分钟）

#### 1、布局

##### 1.1、盒子模型的宽度如何计算？

width + padding + border = 122px

```html
<!-- div1的offsetWidth是多长？ -->
<style>
#div1{
  width: 100px;
  padding: 10px;
  border: 1px solid #ccc;
  margin: 10px;
}
</style>
<body><div id="div1"></div></body>
<script>console.log(document.getElementById('div1').offsetWidth)</script>
```

offsetWidth = ( 内容宽度width + 内边距padding + 边框border )，无外边距margin

追问：如果让offsetWidth=100px，怎么实现？

```css
box-sizing: border-box;
```



##### 1.2、margin竖直方向重叠问题？

相邻元素的margin-top和margin-bottom会发生重叠

空白内容的<p></p>也会重叠

所以答案是：15px

```HTML
<!-- AAA和BBB之间的距离是多少？ -->
<p>AAA</p>
<!-- 空标签没有高度，所以只剩margin了，导致重叠在其中，最大值是15px -->
<p></p>
<p></p>
<p></p>
<p>BBB</p>
```

```CSS
p{
  font-size: 16px;
  line-height: 1;
  margin-top: 10px;
  margin-bottom: 15px;
}
```



##### 1.3、margin负值的问题

​	对margin的top left right bottom设置负值，有何效果？

​		**margin-top负值元素向上移动，margin-left负值元素向左移动**

```html
    <p>用于测试 margin top bottom 的负数情况</p>
    <div class="container">
        <div class="item border-blue" style="margin-bottom: -20px">
            this is item 1
        </div>
        <div class="item border-red" >
            this is item 2
        </div>
    </div>
    <p>用于测试 margin left right 的负数情况</p>
    <div class="container clearfix">
        <div class="item border-blue float-left" style="margin-right: -20px">
            this is item 3
        </div>
        <div class="item border-red float-left" >
            this is item 4
        </div>
    </div>
```

```css
body {
    margin: 20px;
}
.float-left {
    float: left;
}
.clearfix:after {
    content: '';
    display: table;
    clear: both;
}
.container {
    border: 1px solid #ccc;
    padding: 10px;
}
.container .item {
    width: 100px;
    height: 100px;
}
.container .border-blue {
    border: 1px solid blue;
}
.container .border-red {
    border: 1px solid red;
}
```

​     **margin-right负值，右侧元素左移，自身不受影响**

​	 **margin-bottom负值，下方元素上移，自身不受影响**



##### 1.4、BFC的理解和应用

###### 	什么是BFC? 如何应用？

​		=> block fromat context,块级格式化上下文

​		=> 一块独立渲染区域，内部元素的渲染不会影响边界以外的元素

###### 	形成BFC的条件

​		=> float不是none

​		=> position是absolute或fixed

​		=> overflow不是visible

​		=> display是flex inline-block

###### 	应用：清除浮动	

```html
<div class="container bfc">
    <img src="https://www.imooc.com/static/img/index/logo.png" class="left" style="margin-right: 10px;"/>
    <p class="bfc">某一段文字……</p>
</div>
```

```css
.left {
    float: left;
}
.bfc {
    overflow: hidden; /* 触发元素 BFC */
}
```

##### 1.5、float布局（传统PC）的问题，以及手写clearfix

###### 	·圣杯布局和双飞翼布局（目的）

​		=> 三栏布局，中间一栏最先加载和渲染（内容最重要）

​		=> 两侧内容固定，中间内容随着宽度自适应

​		=> 一般用于PC网页

​		**如何实现**

​		1、使用float布局  

​		2、两侧使用margin负值，以便和中间内容横向重叠

​		3、防止中间内容被两侧覆盖，一个用padding一个用margin

###### 圣杯布局

```html
<div id="header">this is header</div>
    <div id="container" class="clearfix">
        <div id="center" class="column">this is center</div>
        <div id="left" class="column">this is left</div>
        <div id="right" class="column">this is right</div>
    </div>
<div id="footer">this is footer</div>
```

```css
body {
    min-width: 550px;
}
#header {
    text-align: center;
    background-color: #f1f1f1;
}
#container {
    padding-left: 200px;
    padding-right: 150px;
}
#container .column {
    float: left;
}
#center {
    background-color: #ccc;
    width: 100%;
}
#left {
    width: 200px;   
    background-color: yellow;    
    margin-left: -100%;
    position: relative;
    right: 200px;
}
#right {
    background-color: red;
    width: 150px;
    margin-right: -150px;
}
#footer {
    text-align: center;
    background-color: #f1f1f1;
}
.clearfix:after {
  content: '';
  display: table;
  clear: both;
}
```



###### 双飞翼布局

```html
<div id="main" class="col">
    <div id="main-wrap">
        this is main
    </div>
</div>
<div id="left" class="col">
    this is left
</div>
<div id="right" class="col">
    this is right
</div>
```

```css
.col {
    float: left;
}
#main {
    width: 100%;
    height: 200px;
    background-color: #ccc;
}
#main-wrap {
    margin: 0 190px 0 190px;
}
#left {
    width: 190px;
    height: 200px;
    background-color: #0000FF;
    margin-left: -100%;
}
#right {
    width: 190px;
    height: 200px;
    background-color: #FF0000;
    margin-left: -190px;
}
```



###### 	·手写clearfix

```css
.clearfix::after{
    content: '';
    display: block;
    clear: both;
    overflow: hidden;
}
```

```css
.clearfix::after {
  content: '';
  display: table;
  clear: both;
}
```

```css
/* 兼容IE低版本 */
.clearfix{
    *zoom: 1;
}
```

##### 1.6、flex画随机点数的骰子🎲

###### 	三点数

​	主要考察点：flex-direction，justify-content，align-items，flex-warp，align-self

```html
<div class="parent">
    <div class="left" style="background-color: green;"></div>
    <div class="center" style="background-color: red;"></div>
    <div class="right" style="background-color: blue;"></div>
</div>
```

```css
.parent{
    display: flex;
    flex-direction: row;
    justify-content: space-betw
    width: 200px;
    height: 200px;
    background-color: #f1f1f1;
    border-radius: 20px;
    padding: 25px;
}
.left,.center,.right{
    width: 50px;
    height: 50px;
    border-radius: 50%;
}
.left{
    /* 垂直方向尾对齐 */
    align-self:flex-end;
}
.center{
    /* 垂直方向居中对齐 */
    align-self: center;
}
.right{
    align-self:flex-start;
}
```



#### 2、定位

##### absolute和relative分别依据什么定位？

​	absolute**默认是body定位**，其他情况依据**最近一层的定位元素**定位

​	relative依据自身位置定位

```html
 <div class="relative">
     <div class="absolute">
         this is absolute
     </div>
 </div>
```

```css
.relative {
    /* 注释这条后absolute盒子就会找body定位*/
    position: relative;
    width: 400px;
    height: 200px;
    border: 1px solid #ccc;
    top: 20px;
    left: 50px;
}
.absolute {
    position: absolute;
    width: 200px;
    height: 100px;
    border: 1px solid blue;
    top: 20px;
    left: 50px;
}
```



##### 居中对齐有哪些实现方式？

###### 	水平居中

​		inline元素：text-align: center

```html
<div class="container">
    <span>一段文字</span>
</div>
```

```css
.container {
    border: 1px solid #ccc;
    margin: 10px;
    padding: 10px
    text-align: center;
}
```

​		

​		block元素：margin:auto;

```html
<div class="container">
    <div class="item">
        this is block item
    </div>
</div>
```

```css
.container {
    border: 1px solid #ccc;
    margin: 10px;
    padding: 10px;
}
.container.item {
    width: 500px;
    margin: auto;
    background-color: #ccc;
}
```

​	

​	absolute元素：left:50%,margin-left负值or transform:translateX(-50%)

```html
<div class="container">
    <div class="item">
        this is absolute item
    </div>
</div>
```

```css
.container {
    border: 1px solid #ccc;
    margin: 10px;
    padding: 10px;
}
.container .item {
    width: 300px;
    height: 100px;
    position: absolute;
    left: 50%;
    /* 让盒子向左移动自己的一半宽度，相当于将平分线拉到了盒子的中间 */
    margin-left: -150px;
    /*transform:translateX(-50%)*/
}
```



###### 	垂直居中

​		inline元素：line-height = height

```html
<div class="container container-1">
    <span>一段文字</span>
</div>
```

```css
.container {
    border: 1px solid #ccc;
    margin: 10px;
    padding: 10px;
    height: 200px;
}
.container-1{
    text-align: center;
    line-height: 200px;
    height: 200px;
}
```

​		

​		absolute元素：top:50%,margin-top负值or transform:translateY(-50%)

```html
<div class="container">
    <div class="item">
        this is item
    </div>
</div>
```

```css
.container {
 	position: relative;
    border: 1px solid #ccc;
    margin: 10px;
    padding: 10px;
    height: 200px;
}
.container .item {
    width: 300px;
    height: 100px;
    position: absolute;
    left: 50%;    
    top: 50%;
    margin-left: -150px;
    margin-top: -50px;
    /* 将margin换成这一条也行*/
    /* transform: translate(-50%, -50%) */
    background-color: #ccc;
}
```

​	

​	absolute元素：top, left, bottom, right = 0  + margin: auto;

​	既要保证兼容性，子元素高度未知

```html
<div class="container">
    <div class="item">
        this is item
    </div>
</div>
```

```css
.container {
	position: relative;
    border: 1px solid #ccc;
    margin: 10px;
    padding: 10px;
    height: 200px;
}
.container .item {
    width: 100px;
    height: 50px;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    /* 自动填充 */
    margin: auto;
    background-color: #ccc;
}
```



#### 3、图文样式

##### line-height的继承问题

​	写具体数值，如30px，则继承改值。

​	写比例，如2/1.5，则继承该比例。

​	写百分比，如200%，则继承计算出来的值。

```html
<p>这是一行文字</p>
```

```css
body {
    font-size: 20px;   
    /* line-height: 30px; */
    /* line-height: 1.5; */
    line-height: 200%;
}
p {
    background-color: #ccc;
    font-size: 16px;
    /* 30px */
    /* 1.5 * 16 = 24px */
    /* 20px * 200% = 40px */
}
```



#### 4、响应式

##### rem是什么？

​	px是绝对长度单位，常用

​	em是相对长度单位，相对于父元素，不常用

​	rem是相对长度单位，相对于根元素，常用于响应式布局

```html
<p style="font-size: 0.1rem">rem 1</p>
<p style="font-size: 0.2rem">rem 1</p>
<p style="font-size: 0.3rem">rem 1</p>
<div style="width: 1rem;">
    this is div1
</div>
<div style="width: 2rem;">
    this is div2
</div>
<div style="width: 3rem;">
    this is div3
</div>
```

```css
/* 根元素 */
html {
    font-size: 100px;
}
div {
    background-color: #ccc;
    margin-top: 10px;
    font-size: 0.16rem;
}
```



##### 如何实现响应式？

​	media-query根据不同的屏幕宽度设置根元素font-size

​	极少用，因为它是全局定义的，基本只写一次

```html
<div id="div1">
    this is div
</div>
```

```css
@media only screen and (max-width: 374px) {
    /* iphone5 或者更小的尺寸，以 iphone5 的宽度（320px）比例设置 font-size */
    html {
        font-size: 86px;
    }
}
@media only screen and (min-width: 375px) and (max-width: 413px) {
    /* iphone6/7/8 和 iphone x */
    html {
        font-size: 130px;
    }
}
@media only screen and (min-width: 414px) {
    /* iphone6p 或者更大的尺寸，以 iphone6p 的宽度（414px）比例设置 font-size */
    html {
        font-size: 180px;
    }
}
body {
    font-size: 0.16rem;
}
#div1 {
    width: 1rem;
    background-color: #ccc;
}
```



##### rem的弊端？

​	有"阶梯"性

##### 网页视口尺寸

​	屏幕高度(可以发光的) => window.screen.height

​	网页视口高度(除了浏览器自己底部和顶部菜单的高度，即可显示内容的高度) => window.innerHeight

​	body高度(实际内容的高度) => document.body.clientHeight

##### vw/vh

​	vh => **网页视口**高度的1/100

​	vw => **网页视口**宽度的1/100

​	vmax取vh和vm(即高度和宽度)中的两者最大值，vmin取两者最小值

```html
<div id="container">
</div>
```

```css
body {
    margin: 0;
    padding: 0;
}
#container {
    background-color: red;
    width: 10vw;
    height: 10vh;
}
```

```js
window.innerHeight === 100vh
window.innerWidth === 100vw
```



#### 5、CSS3

##### CSS3动画（非重点）

​	并不是面试的重点，除非你面试是一个专门做动画的职位









## 2、JS基础

### 2.1、《变量和计算》

#### 题目

typeof能判断哪些类型？

答：所有值类型，函数、是否是引用类型

何时使用=== 何时使用==？

==会做隐式类型装换，除了null，其他一律用===

值类型和引用类型的区别

```js
const obj1 = { x:100, y:200 }
const obj2 = obj1
let x1 = obj1.x
obj2.x = 101
x1 = 102
console.log(obj1.x) // 101
```

手写深拷贝

·注意判断值类型和引用类型

·注意判断是数组还是对象

·递归

#### 知识点

#### 变量类型

##### 值类型VS引用类型

```js
// 值类型
let a = 100
let b = a
a = 200
console.log(b) // 100
```

```js
// 引用类型
let a = { age: 20 }
let b = a
b.age = 21
console.log(a.age) //21
```

###### 差异原因

值类型在不同的栈内存，占用空间小

引用类型在相同的堆内存，占用空间大

![image-20210905082438346](D:\front-end\study\MarkDown\0基础\img\值与引用类型.png)

常见值类型

```js
const a //报错
let z //undefined
const abc = 'abc'
const n = 100
const b = true
const s = Symbol('s')
```

常见引用类型

```js
const obj = { x: 100}
const arr = ['a', 'b', 'c']
const n = null //特殊引用类型，指针指向为空地址
// 特殊引用类型，但不用于存储数据，所以没有“拷贝、复制函数”这一说
function fn() {}
```



##### typeof运算符

识别所有的**值类型**

```js
let z //undefined
const str = 'abc'
const n = 100
const b = true
const s = Symbol('s')
typeof a // 'undefined'
typeof str // 'string'
typeof n // 'number'
typeof b // 'boolean'
typeof s // 'symbol'
```

识别函数

```js
typeof console.log // 'function'
typeof function () {}  // 'function'
```

判断是否是引用类型

```js
// 只能识别是否是引用类型
typeof null // 'object'
typeof ['a', 'b'] // 'object'
typeof { x: 100 } // 'object'
```

###### 手写深拷贝

```js
const obj1 = { 
	age:20,
	name: 'xxx',
	address:{
	  city:'beijing'
	},
	arr:['a', 'b', 'c']
}
/**	深拷贝
  *	obj要拷贝的对象
  */
function deepClone(obj = {}){
    // 不是对象和数组，直接返回
	if(typeof obj !== 'object' || obj == null) return obj
    // 初始化返回结果
    let result
    // 判断是否是数组
    if(obj instanceof Array){
        result = []
    } else {
        result = {}
    }
    for(let key in obj){
       // 保证key不是原型的属性
       if(obj.hasOwnProperty(key)){
         // 递归再调用！！！
       	result[key] = deepClone(obj[key])
       }
    }
    // 返回结果
    return result
}
```

```js
//原数组
var arr1 = [33,44,11,22,[88,66]];
//函数，这个函数会被递归
function deepClone(arr){
    //结果数组,每一层都有一个结果数组
    var result = []
    //遍历数组的每一项
    for(var i = 0; i < arr.length; i++){
        //类型判断，如果遍历到的项是数组
        if(Array.isArray(arr[i])){
            //递归
            result.push(deepClone(arr[i]))
        }else{
            //如果遍历到项是基本类型值，则直接推入结果数组；
            //递归的出口
            result.push(arr[i])
        }
    }
    return result
}
```

#### 变量计算

类型转换

##### 字符串拼接

```js
const a = 100 + 10 // 110
const b = 100 + '10' // '10010'
const c = true + '10' // 'true10'
```

##### == 运算符

```js
100 == '100' //true
0 == '' // true
0 == false // true
false == '' // true
null == undefined // true

//除了 == null 之后，其他一律使用 ===
const obj = { x: 100 }
if(obj.a == null) {}
// 相当于:
// if(obj.a === null || obj.a === undefined) {}
```



##### if语句与逻辑运算

truly变量：!!a === true的变量

```js
const n = 100
!n // false
!!n // true
!!{} // true
```

faslely变量：!!a === false的变量,相当于调用了Boolean()函数

```js
const z = 0
!z // true
!!z // false
!!null // false
!!undefined // false
!!'' // false
!!0 // false
!!NaN // false
!!false // false
```

逻辑判断

```js
10 && 0 // 0
'' || 'abc' // 'abc'
!window.abc // true
```



### 《原型和原型链》

#### 题目

如何准备判断一个变量是不是数组？

```js
// ES6
arr instanceof Array
// ES5
Array.isArray(arr)
```

手写一个简易的jQuery，考虑插件和扩展性

```js
class jQuery{
  constructor(selector){
    const result = document.querySelectorAll(selector)
    const length = result.length
    for(let i = 0; i < length; i++){
       this[i] = result[i]
    }
    this.length = length  
    this.selector = selector  
  }
  get(index){
    return this[index]
  }
  each(fn){
    for(let i = 0; i < length; i++){
      const elem = this[i]  
      fn(elem)
    }
  }
  on(type, fn){
     return this.each(elem => {
        elem.addEventListener(type, fn, false)
     })
  }
  // 扩展DOM API
}

// 插件
jQuery.prototype.dialog = function (info){
    alert(info)
}
// 扩展性 “造轮子”
class myJQuery extends jQuery{
   constructor(selector){
      super(selector)
   }
   // 扩展自己的方法
   addClass(className){
       
   }
   style(data){
       
   }
}
// const $p = new jQuery('p')
// $p.get(1)
// $p.each((elem) => console.log(elem.nodeName))
// $p.on('click', () => alert('clicked'))
```

class的原型本质，怎么理解？



#### 知识点

##### class和继承

```js
// 类
class Student {
    // construcotr
    constructor(name, number) {
        // 属性
        this.name = name
        this.number = number
        // this.gender = 'male'
    }
    // 方法
    sayHi() {
        console.log(
            `姓名 ${this.name} ，学号 ${this.number}`
        )
        // console.log(
        //     '姓名 ' + this.name + ' ，学号 ' + this.number
        // )
    }
    // study() {
    // }
}

// 通过类 new 对象/实例
const xialuo = new Student('夏洛', 100)
console.log(xialuo.name)
console.log(xialuo.number)
xialuo.sayHi()
//类似于使用xialuo.__proto__.sayHi.cal(xiaoluo)
xialuo.__proto__.sayHi()
const madongmei = new Student('马冬梅', 101)
console.log(madongmei.name)
console.log(madongmei.number)
madongmei.sayHi()
```

继承

```js
// 父类
class People {
    constructor(name) {
        this.name = name
    }
    eat() {
        console.log(`${this.name} eat something`)
    }
}
// 子类
class Student extends People {
    constructor(name, number) {
        super(name)
        this.number = number
    }
    sayHi() {
        console.log(`姓名 ${this.name} 学号 ${this.number}`)
    }
}
// 子类
class Teacher extends People {
    constructor(name, major) {
        super(name)
        this.major = major
    }
    teach() {
        console.log(`${this.name} 教授 ${this.major}`)
    }
}
// 实例
const xialuo = new Student('夏洛', 100)
console.log(xialuo.name)
console.log(xialuo.number)
xialuo.sayHi()
xialuo.eat()
// 实例
const wanglaoshi = new Teacher('王老师', '语文')
console.log(wanglaoshi.name)
console.log(wanglaoshi.major)
wanglaoshi.teach()
wanglaoshi.eat()
```



##### 类型判断 instanceof

```js
xialuo instanceof Student // true
xialuo instanceof People // true
xialuo instanceof Object // true
[] instanceof Array // true
[] instanceof Object // true
{} instanceof Object // true
```



##### 原型和原型链

###### 原型关系

每个class都有显示原型prototype

每个实例都有隐式原型__ prototype__

实例的__ prototype__指向对应class的prototype

```js
// class 实际上是函数，可见是语法糖
typeof Student // 'function'
typeof People // 'function'
// 隐式原型
console.log( xialuo.__proto__ )
// 显示原型
console.log( Student.prototype )
console.log( xialuo.__proto__ === Student.prototype )
```

![image-20210905100347100](D:\front-end\study\MarkDown\0基础\img\prototype-base.png)

###### 执行规则

获取属性xialuo.name或执行方法xialuo.sayhi()时

现在自身属性和方法寻找

找不到则自动去__ prototype__查找



###### 原型链

```js
console.log( Student.prototype.__proto__ )
console.log( People.prototype )
console.log( People.prototype === Student.prototype.__proto__ )
console.log( xiaoluo instanceof Arrary ) // false
```

###### 手画图

![image-20210905101939417](D:\front-end\study\MarkDown\0基础\img\原型链.png)

重要提示！！！

class是ES6语法规范，由ECMA委员会发布

ECMA只规定语法规则，即我们代码的书写规范，不规定如何实现

以上实现方式都是V8引擎的实现方式，也是主流的





### 2.2、《作用域和闭包》

#### 题目

this的不同应用场景，如何取值？

##### 手写bind函数★★ or  call  apply 

```js
Function.prototype.bind1 = function (){
  // 将参数拆解为数组
  // ES5
  const args = Array.prototype.slice.call(arguments)
  // ES6
  // const args = [...arguments]
  // 获取this（数组第一项,剩余的就是传递的参数）
  const t = args.shift()
  // fn1.bind中的fn1，当前函数的this
  const self = this
  // 返回一个函数 
  return function (){
     return self.apply(t, args)
  }
}

function fn1(a, b, c){
  console.log('this', this)
  console.log(a, b, c)
  return 'this is fn1'
}

const fn2 = fn1.bind1({x:1}, 1,2,3)
fn2()
```

实际开发中闭包的应用场景，举例说明

​	**隐藏数据**

​	**做一个简单的cache工具**

```JS
// 闭包隐藏数据，只提供API
function createCache(){
  const data = {} // 闭包中的数据，被隐藏，不被外界访问
  return {
      set: function(key, val){
         data[key] = val
      },
      get:function(){
         return data[key]
      }
  }
}
const c = createCache()
c.set('a', 100)
console.log(c.get)
```



创建10个a标签，点击的时候弹出来对应序号

```js
// 全局作用域
let i, a
for(i = 0; i < 10; i++){
  a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', function(e){
  	e.preventDefault()
  	alert(i)
  },)
  // 上树
  document.body.appendChild(a)
}
```



#### 知识点

##### 作用域和自由变量

###### 作用域

​	全局作用域

​	函数作用域

​	块级作用域（ES6新增）

###### 自由变量

​	**一个变量在当前作用域没有定义，但被使用了**

​	向上（父）级作用域，一层一层依次寻找，先找到先用，直到找到为止

​	如果到全局作用域都没找到，则报错XX is not defined

![](D:\front-end\study\MarkDown\0基础\img\作用域链.png)

##### 闭包★(定义的地方)

​	作用域应用的特殊情况，有两种表现

###### 		函数作为参数被传递

```js
function print(fn){
  let a = 200
  fn()
}
let a = 100
function fn() {
  console.log(a)
}
print(fn)
```

###### 		函数作为返回值被返回

```js
function create() {
  let a = 100
  return function(){
    console.log(a)
  }
}
let fn = create()
let a = 200
fn()
```

闭包自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方



##### this★★★（函数执行的时候）

###### 作为普通函数

```js
function fn1(){
  console.log(this)
}
fn1()
```



###### 使用call apply bind

```js
fn1.call({ x: 100 })
// bind返回一个新的函数
const fn2 = fn1.bind({ x: 200 })
fn2()
```



###### 作为对象方法被调用

```js
const zhangsan = {
  name: 'zhansan',
  sayHi{
  	//this即当前对象
  	console.log(this)
  },
  wait(){
  	setTimeout( function() {
  	  // this === window
  	  console.log(this)
  	})
  }
}
```



###### 在class方法中调用

```js
class People{
  constructor(name){
    this.name = name
    this.age = 20
  }
  sayHi(){
    // 实例zhansan
    console.log(this)
  }
}
const zhangsan = new People('zhansan')
zhangsan.sayHi()
```



###### 箭头函数

```js
const zhangsan = {
  name: 'zhansan',
  sayHi{
  	//this即当前对象
  	console.log(this)
  },
  waitAgain(){
    setTimeout( function() {
  	  // this即当前对象
  	  console.log(this)
  	})
  }
}
```





### 2.3、《异步和单线程》

#### 题目

##### 同步和异步的区别是什么？

​	JS是单线程语言，只能同时做一件事

​	异步不会阻塞代码执行，同步会

##### 手写用Promise加载一张图片

```js
function loadImg(src){
    return new Promise((resovle, reject) => {
        const img = document.createElement('img')
        img.onload = () => {
            resovle(img)
        }
        img.onerror = () =>{
            reject(new Error(`图片加载失败${src}`))
        }
        im.src = src
    })
}

const url =''
const url2 =''
loadImg(url).then(img =>{
    console.log(img.width)
    return img // 普通对象
}).then(img => {
    console.log(img.height)
    return loadImg(url2) // promise实例
}).then(img2 => {
    console.log(img2.width)
    return img2
}).then(img2 => {
    console.log(img2.height)
}).catch(err => console.error(err))
```

##### 前端使用异步的场景有哪些？

等待的场景: 网络请求和定时任务

#### 场景题

```js
// 笔试题
function fn(){
    console.log(1)
    setTimeout(function() {
      console.log(2)
    }, 1000)
    console.log(3)
    setTimeout(function() {
      console.log(4)
    }, 0)
    console.log(5)
}
fn()
console.log(6)
// 135642
```



#### 知识点

##### 单线程和异步

JS是单线程语言，只能同时做一件事

浏览器和nodejs已支持JS启动**进程**，如Web Worker

JS和DOM渲染共用同一个线程，因为JS可修改DOM结构

###### 异步和同步

遇到等待(网络请求，定时任务)不能卡住

异步不会阻塞代码执行，同步会

回调callback函数形式

```js
// 异步
console.log(100)
setTimeout(function (){
  console.log(200)
}, 0)
console.log(300)

// 同步
console.log(100)
// 这个地方需要等待
alert(200)
console.log(300)
```



#### 应用场景

网络请求，如ajax图片加载

```js
console.log('start')
$.get('./data1.json', function (data1){
  console.log(data1)
})
console.log('end')
```

```js
// 图片加载
console.log('start')
let img = document.createElement('img')
img.onload = function(){
  console.log('loaded')
}
img.src ='./xxx.png'
console.log('end')
```

定时任务，如setTimeout/setInterval

```js
console.log(100)
setTimeout(function (){
  console.log(200)
}, 0)
console.log(300)
// 定时任务
console.log(100)
setInterval(function (){
  console.log(200)
}, 0)
console.log(300)
```



##### callback hell回调地狱 和 Promise

解决callback 的语法嵌套问题

```js
//获取第一份数据
$.get(url1, (data1) => {
  console.log(data1)
      // 获取第二份数据
      $.get(url2, (data2) => {
      console.log(data2)
  		  // 获取第三份数据
          $.get(url3, (data3) => {
          console.log(data3)
          // 还可能获取更多的数据
		})
	})
})
```

```js
function getData(url){
  return new Promise((resolve, reject) => {
    $.ajax({
      url,
      success(data){
        resolve(data)
      },
      error(err){
        reject(err)
      }
    })
  })
}
const url = 'x1.json'
const url = 'x11.json'
const url = 'x111.json'
getData(url1).then(data1 => {
   console.log(data1)
   return getData(url2)
}).then(data2 => {
   console.log(data2)
   return getData(url3)
}).then(data3 => {
   console.log(data3)
}).catch(err =>{
   console.log(err)
})
```









### 2.4、《JS异步-进阶》

#### 面试题

请描述event loop（事件循环/事件论询）的机制，可画图

什么是宏任务和微任务，两者有什么区别？

Promise有哪三种状态？如何变化？

#### 场景题

##### promise then和catch的连接

```js
// 第一题
Promise.resolve().then(() => {
  console.log(1) // resolved
}).catch(() => {
  console.log(2)
}).then(() => {
  console.log(3) // resolved
})
// 13

// 第二题
Promise.resolve().then(() => {
  console.log(1)
  throw new Error('error1')
}).catch(() => {
  console.log(2) // resolved
}).then(() => {
  console.log(3) // resolved
})
// 12 ✖
// 123

// 第三题
Promise.resolve().then(() => {
  console.log(1)
  throw new Error('error1')
}).catch(() => {
  console.log(2) // resolved
}).catch(() => {
  console.log(3)
})
// 12
```

##### async/await语法

```js
async function fn(){
 return 100
}
(async function(){
  // 100 ✖
  // Promise {<fulfilled>: 100}  ✔
  const a = fn() 
  
  const b = await fn() // 100 ✔
})()

// 执行完毕打印哪些内容
(async function(){
  console.log('start')
  const a = await 100
  console.log('a', a)
  const b = await Promise.resolve(200)
  console.log('b', b)
  const c = await Promise.reject(300)
  console.log('c', c)
  console.log('end')
})()
// start a 100 b 200 c 300 end ✖
// start a 100 b 200 报错
```

##### promise和setTimeout的顺序

```JS
console.log(100)
setTimeout(() => {
  console.log(200)
}, 0)
Promise.resolve().then(() => {
  console.log(300)
})
console.log(400)
// 100 400 200 300 ✖
// 100 400 300 200 ✔
```

##### 外加async/await的顺序问题

```js
async function async1(){
 console.log('async1 start')
 await async2()
 console.log('async1 end')
}
async function async2(){
 console.log('async2 start')
}
console.log('script start')

setTimeout(function () {
 console.log('setTimeout')
}, 0)

async1()

// 初始化promise时，传入的函数会立刻被执行
new Promise (function (resolve) {
 console.log('promise1')
 resolve()
}).then(function (){
 console.log('promise2')
})
console.log('script end')
// script start => script end => async1 start => async2 start => async1 end => setTimeout => promise1 => promise2 ✖
// script start => async1 start => async2 start => promise1 => script end  => async1 end => promise2 => setTimeout ✔
```



#### 知识点

##### event loop★★★

https://www.jianshu.com/p/de7aba994523

JS是单线程

异步要基于回调来实现

event loop就是JS异步回调的实现原理



###### JS如何执行的？

从前到后，一行一行执行

如果某一行执行报错，则停止下面代码的执行

先把同步代码执行完，再执行异步



###### 过程

- 同步代码，一行一行的放在call stack执行

- 遇到异步，会先“记录”下，等待时机（定时、网络请求等）

- 时机到了，就移动到Callback Queue

- 如果Call Stack为空（即同步代码执行完），Event  Loop开始工作

- 轮询查找Callback Queue，如有则移动到Call Stack执行

- 然后继续轮询查找（永动机）



按钮节流失效

###### DOM事件与event loop

DOM事件也使用回调，基于event loop





##### Promise

###### 三种状态的表现和变化

pending  resolved(fulfilled)  rejected

​	变化不可逆

pending => resolved 或 pending => rejected

```js
// 刚定义时，状态默认为 pending
const p1 = new Promise((resolve, reject) => {

})

// 执行 resolve() 后，状态变成 resolved
const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve()
    })
})

// 执行 reject() 后，状态变成 rejected
const p3 = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject()
    })
})

const p4 = Promise.resolve(100)
p4.then(data => {
  console.log('data', data) //
}).catch(err => {
  console.log('err', err)
})

const p5 = Promise.reject('err')
p5.then(data => {
  console.log('data2', data)
}).catch(err => {
  console.log('err2', err) //
})
```

###### then和catch对状态的影响

- then正常返回resolved，里面有报错则返回rejected

  ```js
  const p1 = Promise.resolve(100).then(()=>{
    return 100
  })
  p1.then(data => {
    console.log('data', data) //
  }).catch(err => {
    console.log('err', err)
  })
  
  const p2 = Promise.resolve().then(()=>{
    throw new Error('then error')
  })
  p2.then(data => {
    console.log('data', data)
  }).catch(err => {
    console.log('err', err) //
  })
  ```

- catch正常返回resolved，里面有报错则返回rejected

  ```js
  const p1 = Promise.reject('my error').catch(err=>{
    // resolved
    console.error(err)
  })
  p1.then(data => {
    // resolved 
    console.log('data', data) // 执行
  }).catch(err => {  
    console.log('err', err) // 不执行
  })
  
  const p2 = Promise.reject('my error').catch(()=>{
    // rejected
    throw new Error('then error')
  })
  p2.then(data => {
    console.log('data', data) // 不执行
  }).catch(err => {
    // resolved
    console.log('err', err) // 执行
  })
  ```

状态变化会触发 then catch

- pending 不会触发任何 then catch 回调
- 状态变为 resolved 会触发后续的 then 回调
- 状态变为 rejected 会触发后续的 catch 回调

then catch 会继续返回 Promise ，**此时可能会发生状态变化！！！**

```js
// then() 一般正常返回 resolved 状态的 promise
Promise.resolve().then(() => {
    return 100
})

// then() 里抛出错误，会返回 rejected 状态的 promise
Promise.resolve().then(() => {
    throw new Error('err')
})

// catch() 不抛出错误，会返回 resolved 状态的 promise
Promise.reject().catch(() => {
    console.error('catch some error')
})

// catch() 抛出错误，会返回 rejected 状态的 promise
Promise.reject().catch(() => {
    console.error('catch some error')
    throw new Error('err')
})
```







##### async/await★★★

异步回调 callback hell

Promise then catch 链式调用，但也是基于回调函数

async/await是同步语法，彻底消灭回调函数



###### 语法介绍

用同步的方式，编写异步。

```js
function loadImg(src) {
    const promise = new Promise((resolve, reject) => {
        const img = document.createElement('img')
        img.onload = () => {
            resolve(img)
        }
        img.onerror = () => {
            reject(new Error(`图片加载失败 ${src}`))
        }
        img.src = src
    })
    return promise
}

async function loadImg1() {
    const src1 = 'http://www.imooc.com/static/img/index/logo_new.png'
    const img1 = await loadImg(src1)
    return img1
}

async function loadImg2() {
    const src2 = 'https://avatars3.githubusercontent.com/u/9583120'
    const img2 = await loadImg(src2)
    return img2
}

(async function () {
    // 注意：await 必须放在 async 函数中，否则会报错
    try {
        // 加载第一张图片
        const img1 = await loadImg1()
        console.log(img1)
        // 加载第二张图片
        const img2 = await loadImg2()
        console.log(img2)
    } catch (ex) {
        console.error(ex)
    }
})()
```



###### 和 Promise 的关系★★★

- async 函数返回结果都是 Promise 对象（如果函数内没返回 Promise ，则自动封装一下）

  ```js
  async function fn1(){
      return 100
  }
  const res1 = fn1()
  console.log('res1', res1) // Promise {<fulfilled>: 100}
  res1.then(data => console.log(data)) 	
  ```

  

- await相当于Promise的then

  - await 后面跟 Promise 对象：会阻断后续代码，等待状态变为 resolved ，才获取结果并继续执行

    ```js
    !(async function(){
      const p1 = Promise.resolve(300)
      const data = await p1
      console.log('data', data)
    })()
    ```

  - await 后续跟非 Promise 对象：会直接返回（如果函数内没返回 Promise ，则自动封装一下）

    ```js
    !(async function(){
      const p1 = 300
      const data = await p1
      console.log('data', data)
    })()
    ```

    

- try...catch可捕获异常，代替了Promise的catch

  ```js
  (async function () {
      const p4 = Promise.reject('some err')
      try {
          const res = await p4
          console.log(res)
      } catch (ex) {
          console.error(ex)
      }
  })()
  ```

总结来看：

- async 封装 Promise, 返回Promise

- await 处理 Promise 成功

- try...catch 处理 Promise 失败

  

###### 异步de本质

​	async/await语法糖

​	saync不是异步

​    await 是同步写法，但本质还是异步调用。

```js
async function async1 () {
  console.log('async1 start')
  // 先去执行async2()，再去执行await操作
  await async2()
  console.log('async1 end') // ★★★★关键在这一步，它相当于放在 callback 中，最后执行
}

async function async2 () {
  console.log('async2')
}

console.log('script start')
async1()
console.log('script end')
// script start => async1 start => async2 => async1 end => async1 end => script end ✖
// script start => async1 start => async2 => async1 end => script end => async1 end ✔
```

★★★★即，只要遇到了 **`await`** ，后面的代码都相当于放在 `callback Queue`   里，异步回调。





###### for...of

for... in(froEach for) 是常规的同步遍历

常用于异步的遍历

```js
// 定时算乘法
function multi(num) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(num * num)
        }, 1000)
    })
}

// // 使用 forEach ，是 1s 之后打印出所有结果，即 3 个值是一起被计算出来的
// function test1 () {
//     const nums = [1, 2, 3];
//     nums.forEach(async x => {
//         const res = await multi(x);
//         console.log(res);
//     })
// }
// test1();

// 使用 for...of ，可以让计算挨个串行执行
async function test2 () {
    const nums = [1, 2, 3];
    for (let x of nums) {
        // 在 for...of 循环体的内部，遇到 await 会挨个串行计算
        const res = await multi(x)
        console.log(res)
    }
}
test2()
```







##### 宏任务和微任务

macroTask和microTask

###### what is？

- 微任务：Promise  async/await（对于前端来说）
- 宏任务：setTimeout setInterval Ajax DOM 事件
- **微任务比宏任务执行的更早**

```js
console.log(100)
setTimeout(() => {
    console.log(200)
})
Promise.resolve().then(() => {
    console.log(300)
})
console.log(400)
// 100 400 300 200
```



###### event loop 和DOM渲染

- 再次回顾 event loop 的过程

  ![](D:\front-end\study\MarkDown\0基础\Event Loop\DOM渲染.png)

- JS是单线程，和DOM渲染共用一个线程，每一次 call stack 任务结束清空，都会尝试触发 DOM 渲染（不一定非得渲染，就是给一次 DOM 渲染的机会！！！）

- 然后再进行 event loop

  ```js
  const $p1 = $('<p>一段文字</p>')
  const $p2 = $('<p>一段文字</p>')
  const $p3 = $('<p>一段文字</p>')
  $('#container')
              .append($p1)
              .append($p2)
              .append($p3)
  
  console.log('length',  $('#container').children().length )
  
  alert('本次 call stack 结束，DOM 结构已更新，但尚未触发渲染')
  // （alert 会阻断 js 执行，也会阻断 DOM 渲染，便于查看效果）
  // 到此，即本次 call stack 结束后（同步任务都执行完了），浏览器会自动触发渲染，不用代码干预
  
  // 另外，按照 event loop 触发 DOM 渲染时机，setTimeout 时 alert ，就能看到 DOM 渲染后的结果了
  setTimeout(function () {
      alert('setTimeout 是在下一次 Call Stack ，就能看到 DOM 渲染出来的结果了')
  })
  ```

  

###### 区别

- 宏任务：DOM 渲染后再触发，如setTimeout
- 微任务：DOM 渲染前会触发，如Promise

```js
// 修改 DOM
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
    .append($p1)
    .append($p2)
    .append($p3)

// 微任务：渲染之前执行（DOM 结构已更新）
Promise.resolve().then(() => {
    const length = $('#container').children().length
    alert(`micro task ${length}`)
})

// 宏任务：渲染之后执行（DOM 结构已更新）
setTimeout(() => {
    const length = $('#container').children().length
    alert(`macro task ${length}`)
})
```

从event loop解释，为什么微任务执行更早

再深入思考一下：为何两者会有以上区别，一个在渲染前，一个在渲染后？

- 微任务：ES 语法标准规定之内，JS 引擎来统一处理。即，不用浏览器有任何关于，即可一次性处理完，更快更及时。
- 宏任务：ES 语法没有,浏览器语法规定的，JS 引擎不处理，浏览器（或 nodejs）干预处理。

![](D:\front-end\study\MarkDown\0基础\Event Loop\why.png)



![](D:\front-end\study\MarkDown\0基础\Event Loop\why2.png)



###### 总结

宏任务有哪些？微任务有哪些？微任务触发时机更早 

微任务、宏任务和DOM渲染的关系

微任务、宏任务和DOM渲染在 event loop的过程





 

### 2.5、JS Web API

JS基础知识，规定语法 (ECMA262标准)

JS Web API，网页操作的API (W3C标准)

前者是后者的基础，两者结合才能真正实际应用



#### DOM

- Document Object Model

- vue和React框架应用广泛，封装了DOM操作

- 但DOM操作一直都会前端工程师的基础、必备知识

- 只会vue而不懂DOM操作的前端程序员，不会长久

##### 面试题

- DOM是哪种数据结构？

- DOM操作的常用API？

- attribute和property的区别？

- 一次性插入多个DOM节点，考虑性能？



##### 知识点

###### DOM的本质

- JS操作HTML和CSS的桥梁（节点思维）, 特点：将文档表示为节点树。

- nodeType常用属性值

  - **1**：元素节点<p>和<div>
  - **3**：文字节点
  - **8**：注释节点
  - **9**：document节点
  - **10**：DTD（文档类型声明）节点

  ![](D:\front-end\study\MarkDown\0基础\img\DOM节点树.png)



###### DOM节点操作

- 获取DOM节点

  ```html
  <style>
    .container {
        border: 1px solid #ccc;
     }
     .red {
        color: red;
     }
  </style>
  <div id="div1" class="container">
     <p id="p1">一段文字 1</p>
     <p>一段文字 2</p>
     <p>一段文字 3</p>
  </div>
  <div id="div2">
    <img src="https://img3.mukewang.com/5a9fc8070001a82402060220-100-100.jpg"/>
  </div>
  <ul id="list">
  </ul>
  ```

  ```js
  const div1 = document.getElementById('div1')
  console.log('div1', div1)
  
  const divList = document.getElementsByTagName('div') // 集合
  console.log('divList.length', divList.length)
  console.log('divList[1]', divList[1])
  
  const containerList = document.getElementsByClassName('container') // 集合
  console.log('containerList.length', containerList.length)
  console.log('containerList[1]', containerList[1])
  
  const pList = document.querySelectorAll('p')
  console.log('pList', pList)
  ```

  

- attribute

  作用到DOM结构节点属性，修改HTML属性，会改变HTML结构，尽量少用，很大可能会引起重新渲染

  ```js
  const pLists = document.querySelectorAll('p')
  const p1 = pLists[0]
  // attribute
  p1.setAttribute('data-name', 'imooc')
  console.log( p1.getAttribute('data-name') )
  p1.setAttribute('style', 'font-size: 50px;')
  console.log( p1.getAttribute('style') )
  ```

- property

  作用到JS变量属性，修改对象属性，不会体现到HTML结构中，可以用，很可能会引起重新渲染，JS机制会避免DOM渲染

  ```js
  const pLists = document.querySelectorAll('p')
  const p1 = pLists[0]
  // property 形式
  p1.style.width = '100px'
  console.log( p1.style.width )
  p1.className = 'red'
  console.log( p1.className )
  console.log(p1.nodeName)
  console.log(p1.nodeType) // 1
  ```

  

###### DOM结构操作

![](D:\front-end\study\MarkDown\0基础\img\节点的关系.png)

|  考虑所有节点   |      关系      |     只考虑元素节点     |
| :-------------: | :------------: | :--------------------: |
|   childNodes    |     子节点     |        children        |
|   parentNode    |     父节点     |       parentNode       |
|   fristChild    |  第一个子节点  |   firstElementChild    |
|    lastChild    | 最后一个子节点 |    lastElementChild    |
| previousSibling | 前一个兄弟节点 | perviousElementSibling |
|   nextSibling   | 后一个兄弟节点 |   nextElementSibling   |

**注意**：在DOM中，文本节点也属于节点。在标准的W3C的规范中，空白文本节点也应该算作节点，

- 新增插入节点，移动节点

  ```js
  const div1 = document.getElementById('div1')
  const div2 = document.getElementById('div2')
  // 新建节点
  const newP = document.createElement('p')
  newP.innerHTML = 'this is newP'
  // 插入节点
  div1.appendChild(newP)
  // 移动节点
  const p1 = document.getElementById('p1')
  div2.appendChild(p1)
  ```

  

- 获取子元素列表，获取父元素

  ```js
  // 获取父元素
  console.log( p1.parentNode )
  
  // 获取子元素列表
  const div1ChildNodes = div1.childNodes
  console.log( div1.childNodes )
  // 过滤文本节点
  const div1ChildNodesP = Array.prototype.slice.call(div1.childNodes).filter(child => {
      if (child.nodeType === 1) {
          return true
      }
      return false
  })
  console.log('div1ChildNodesP', div1ChildNodesP)
  ```

  

- 删除子元素（只能其父元素操作）

  ```js
  div1.removeChild( div1ChildNodesP[0] )
  ```

  

###### DOM性能★

- 渲染优化

  - 减少 DOM 元素数量和嵌套层级

  - 尽量避免使用 table 布局，用其他标签代替

  - table 是作为一个整体解析的，要等整个表格都解析完成才显示

    

- 选择器优化

  - 优先使用 id 来获取单个元素

  - 获取多个元素时，尽量直接通过元素本身的 className 获取

    ```js
    console.log(document.querySelectorAll('ul.list li.item')); // 不推荐
    console.log(document.getElementsByClassName('item')); // 推荐
    console.log(document.querySelectorAll('.item')); // 推荐
    ```



- 对DOM查询做缓存

- 总是将选择器的选择结果缓存起来

  ```js
  // 不缓存DOM查询结果
  for(let = 0; i < document.getElementsByTagName('p').length; i++){
    // 每次循环，都会计算length，频繁进行DOM查询
  }
  // 缓存DOM查询结果
  const $list document.getElementsByTagName('p')
  const length = $list.length
  for(let i = 0; i < length; i++){
      // 缓存length，只进行一次DOM查询
  }
  ```

  

- 避免在循环中多次使用 innerHTML，在循环结束后使用一次

  ```js
  // 多次使用innerHTML（不推荐）
  const todoDatas = ['洗衣服', '做饭', '写代码'];
  for (const item of todoDatas) {
    $list.innerHTML += `<li class="item">${item}</li>`;
  }
  // 一次性使用innerHTML （推荐）
  // 避免在循环中多次使用 innerHTML，在循环结束后使用一次
  let html = '';
  for (const item of todoDatas) {
    html += `<li class="item">${item}</li>`;
  }
  $list.innerHTML = html;
  ```

  

- 将频繁操作改为一次性操作，使用 DocumentFragment 优化多次的 appendChild新创建的元素，完成必要操作后再添加到页面中

  ```js
  // 创建元素方式（不推荐）
  const todoDatas = ['洗衣服', '做饭', '写代码'];
  for (const item of todoDatas) {
    const $li = document.createElement('li');
    // 新创建的元素，完成必要操作后再添加到页面中
    $li.className = 'item';
    $li.innerHTML = item;
    $list.appendChild($li);
  }
  // 使用 DocumentFragment 优化多次的 appendChild（推荐）
  const $liFragment = document.createDocumentFragment();
  for (const item of todoDatas) {
    const $li = document.createElement('li');
    $li.className = 'item';
    $li.innerHTML = item;
    $liFragment.appendChild($li);
  }
  $list.appendChild($liFragment);
  ```

  

- 不要直接通过 JS 修改元素的 style，通过添加移除 class 修改元素样式

  ```js
  const $box = document.getElementById('box');
  // let active = false;
  $box.addEventListener('click',() => {
      // if (!active) {
      //   active = true;
      //   // $box.style.width = '100px';
      //   // $box.style.height = '100px';
      //   // $box.style.backgroundColor = 'yellow';
      //   $box.classList.add('active');
      // } else {
      //   active = false;
      //   // $box.style.width = '200px';
      //   // $box.style.height = '200px';
      //   // $box.style.backgroundColor = 'red';
      //   $box.classList.remove('active');
      // }
      //简化用toggle就行，不用判断
      $box.classList.toggle('active');
    },
    false
  );
  ```

  

- 注意强制回流

- 当获取的属性值包括但不限于 offsetTop、offsetLeft、scrollTop、clientTop 这些“全局属性”时，需要此时页面上的其他元素的布局和样式处于最新状态，这会引起多次的回流和重绘。这样的操作称为强制回流

  ```js
  const $backtop = document.getElementById('backtop');
  // 注意强制回流
  let winHeight = window.innerHeight;
  // 当浏览器的窗口大小变化的时候，将浏览器窗口的高度赋值使用减少回流
  window.addEventListener(
    'resize',
    () => {
      winHeight = window.innerHeight;
    },
    false
  );
  window.addEventListener('scroll', scrollHandler, false);
  function scrollHandler() {
    // console.log('scroll');
    if (document.documentElement.scrollTop >= winHeight) {
      $backtop.classList.remove('none');
    } else {
      $backtop.classList.add('none');
    }
  
  ```



#### BOM

- Document Object Model

##### 面试题

如何识别浏览器的类型？

分析拆解url各个部分

##### 知识点

###### navigator

```js
// 是否是谷歌浏览器
const ua = navigator.userAgent
const isChorme = ua.indexOf('Chrome')
console.log(isChorme)
```

###### screen

```js
console.log(screen.width)
console.log(screen.htight)
```

###### location

```js
// 拆解url各部分
console.log(location.href)
// 协议
console.log(location.protocol)
// 
console.log(location.host)
//
console.log(location.hash)
//
console.log(location.search)
// 
console.log(location.pathname)
```



###### history

```js
history.back()
history.go(-1)
history.forward()
```



#### 事件绑定

##### 面试题

- 手写编写一个通用的事件监听函数
- 描述事件冒泡的流程★
- 无限下拉的图片列表，如何监听每个图片的点击？

##### 知识点

###### 事件绑定

```js
const btn = document.getElementById('btn')
btn.addEventListener('click', event => {
    console.log(event.target) // 获取触发的元素
    event.preventDeafult() // 阻止默认行为
  console.log('clicked')
})
```



###### 事件冒泡

```html
<div id="div1">
  <p id="p1">激活</p>
  <p id="p2">取消</p>
  <p id="p3">取消</p>
  <p id="p4">取消</p>
</div>
<div id="div2">
  <p id="p5">取消</p>
  <p id="p6">取消</p>
</div>
```

```js
const p1 = document.getElementById('p1')
bindEvent(p1, 'click', event => {
    event.stopPropagation() // 阻止冒泡
    console.log('激活')
})
const body = document.body
bindEvent(body, 'click', event => {
    console.log('取消')
    // console.log(event.target)
})
const div2 = document.getElementById('div2')
bindEvent(div2, 'click', event => {
    console.log('div2 clicked')
    console.log(event.target)
})
```



###### 事件代理（面试必考）

- 代码简洁

- 减少浏览器内存占用

```html
<div id="div3">
  <a href="#">a1</a><br>
  <a href="#">a2</a><br>
  <a href="#">a3</a><br>
  <a href="#">a4</a><br>
  <button id="btn1">加载更多...</button>
</div>
```

```js
function bindEvent(elem, type, selector, fn) {
    // 如果没有传递第四个参数，即为普通绑定
    if (fn == null) {
        fn = selector
        selector = null
    }
    elem.addEventListener(type, event => {
        // 获取事件元素
        const target = event.target
        if (selector) {
            // 代理绑定
            // 使用matches来判断是否是触发元素（是否符合CSS选择器）
            // 如果元素被指定的选择器字符串选择，Element.matches()  方法返回true; 否则返回false。
            if (target.matches(selector)) {
                fn.call(target, event)
            }
        } else {
            // 普通绑定
            fn.call(target, event)
        }
    })
}
// 普通绑定
const btn1 = document.getElementById('btn1')
bindEvent(btn1, 'click', function (event) {
    // console.log(event.target) // 获取触发的元素
    event.preventDefault() // 阻止默认行为
    alert(this.innerHTML)
})

// 代理绑定
const div3 = document.getElementById('div3')
bindEvent(div3, 'click', 'a', function (event) {
    event.preventDefault()
    alert(this.innerHTML)
})
```



#### Ajax

##### 面试题

手写一个简易的ajax

```js
function ajax(url){
  const p = new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest()
    xhr.open('GET', url, true)
    xhr.onreadystatechange = function(){
      if(xhr.readyState === 4){
         if(xhr.status === 200){
           resolve(JSON.parse(xhr.responseText))
         } else if(xhr.status === 404){
         	reject(new Error('404 not found'))
         }
      }
    }
    xhr.send(null)
  })
  return p
}
```

跨域的常用实现方式

JSONP的原理

CORS服务端



##### 知识点

###### XMLHttpRequest

```js
// get请求
const xhr = new XMLHttpRequest
xhr.open("GET","/api",true)
xhr.onreadystatechange = function(){
  // 这里的函数异步执行，可参考之前JS基础中的异步模板
  if(xhr.readyState === 4){
    if(xhr.status === 200){
      console.log(JSON.parse(xhr.responseText))
    }
  }
}
xhr.send(null)

// post请求
xhr.open('POST', '/api', true)
const data ={
    username: 'xx',
    password: '12312312'
}
xhr.send(JSON.stringify(data))
```



###### 状态码

**readystatechange 事件监听 readyState 这个状态的变化**

它的值从 0 ~ 4，一共 5 个状态

0：未初始化。尚未调用 open()
1：启动。已经调用 open()，但尚未调用 send()
2：发送。已经调用 send()，但尚未接收到响应
3：接收。已经接收到部分响应数据
4：完成。已经接收到全部响应数据，而且已经可以在浏览器中使用了

**HTTP 状态码的语义**

100~199 消息	代表请求已被接受，需要继续处理

200~299 成功

300~399 重定向

​		http://www.jd.com/

​		https://www.jd.com/

​		301 Moved Permanently   永久重定向

​		302 Move Temporarily   临时重定向

​		304 Not Modified   资源未改变

400~499 请求错误

​		404 Not Found

500~599 服务器错误

​		500 Internal Server Error 



###### 跨域：同源策略，跨域解决方案

**什么是跨域（同源策略）**

ajax请求时，浏览器要求当前网页和server必须同源（安全） 

同源：协议、域名、端口、三者必须一致

加载图片css，js可无视同源策略 

```html
<!-- 可以用于统计打点，可以使用第三方统计服务 -->
<img src=跨域的图片地址/>
<!-- 可以使用CDN,CDN一般都是外域 -->
<link href=跨域的css地址/>
<script src=跨域的js地址>可以实现JSONP<script>
```

所有的跨域，都必须经过server端允许和配合

未经server端允许就实现跨域，说明浏览器有漏洞，危险信号



**JSONP**

- `<script>`可以绕过跨域限制

- 服务器可以任意动态拼接数据返回，只要符号html格式要求

- 所以`<script>`就可以获得跨域的数据，**只要服务端愿意返回**

- 只能使用get请求，不推荐使用

  ```html
  <script>
  window.demo = function(data){
    // 这是我们跨域得到的信息
    console.log(data)
  }
  </script>
  <script src="https://localhost:3000/getData.js?username=xxx&callback=demo"></script>
  <!-- 将返回callback({ x: 100, y: 200}) -->  
  ```

  getData.js

  ```js
  callback(
  {
   name: 'abctext' 
  })
  ```

  - jQuery实现jsonp

    ```js
    $.ajax({
      url: 'http://localhost:8882/x-origin.json',
      dataType: 'jsonp',
      jsonpCallback: 'callback',
      success: function(data){
        console.log(data)
      }
    })
    ```

    

###### **CORS(服务端支持)**

服务器设置http header

```js
// 第二个参数填写允许跨域的域名称，不建议直接写★
response.setHeader("Access-Control-Allow-Origin", "http://localhost:8000");
response.setHeader("Access-Control-Allow-Headers", "X-Requested-With");
response.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");

//接收跨域的cookie
response.setHeader("Access-Control-Allow-Credentials", "true");
```





#### 存储

##### 面试题

- 描述cookie localStorage sessionStorage区别

  容量

  API易用性

  存储时间

  是否跟随http请求发送出去

##### 知识点

###### cookie

- name:cookie名称
- domain:cookie生效的域名
- path:cookie生效的路径
- expires:cookie过期时间
- HttpOnly:用户端不可更改

本身用于浏览器的server通讯

被“借用”到本地存储来

可用document.cookie = '...' 来修改

```js
// 一般名称使用英文字母，不要用中文，值可以用中文，但是要编码
document.cookie = `username=${encodeURIComponent('张三')}`;
document.cookie = `${encodeURIComponent('用户名')}=${encodeURIComponent(
  '张三'
)}`;
```

**缺点**

存储大小，最大4KB

http请求时需要发送到服务端，增加请求数据量

只能用document.cookie= ‘...’来修改，太过简陋



###### localStorage和sessionStorage

- HTML5专门为存储而设计，最大可寸5M

- API简单易用setItem, getItem

- 不会随着http请求被发送出去

localStorage数据会永久存储，除非代码或手动删除

sesiionStorage数据只存在于当前会话，浏览器关闭清空

一般用localStorage会更多一些







## 3、HTTP

### 面试题

- http常见的状态码有哪些？

- http常见的header有哪些？

- 什么是Restful API

- 描述一下http的缓存机制★★★

### 知识点

#### http状态码

##### 状态码分类

100~199 消息	代表请求已被接受，需要继续处理

200~299 成功

300~399 重定向

​		http://www.jd.com/

​		https://www.jd.com/

​		301 Moved Permanently   永久重定向

​		302 Move Temporarily   临时重定向

​		304 Not Modified   资源未改变

400~499 请求错误

​		404 Not Found

500~599 服务器错误

​		500 Internal Server Error

 

##### 常见状态码

- 200成功

- 301永久重定向（配合location，浏览器自动处理）

- 302临时重定向（配合location，浏览器自动处理）
  - 短网址（例如百度搜索中的结果）

- 304资源未被修改

- 403没有权限
- 404资源未找到
- 500服务器错误
- 504网关超时



#### http methods

传统的methods

- get获取服务器的数据
- post向服务器提交数据

现在的methods

- get获取数据
- post新建数据
- patch/put更新数据
- delete删除数据



##### Restful API

已推广的API设计方法

###### 传统API设计

​		**把每个url当做一个功能★★★**

###### Restful API设计

​		**把每个url当做一个唯一的资源★★★**

###### 如何设计成一个资源

- 尽量不用url参数
  - 传统API设计：/api/list?pageIndex=2
  - Restful API设计：/api/list/2

- 用**method**表示**操作类型**
  - 传统API设计
    - 增加 => /api/create-blog   
    - 更新 => /api/update-blog?id = 100 
    - 获得 => /api/get-blog?id = 100
  - Restful API设计
    - post => /api/blog
    - patch => /api/blog/100
    - get => /api/blog/100



#### http headers

浏览器F12

##### 常见的Request Headers

- Accept浏览器可接收的数据格式
- Accept-Encoding浏览器可接收的压缩算法，如gzip
- Accept-Languange浏览器可接收的语言，如zh-CN
- Connection：keep-alive一次TCP连接重复使用
- cookie
- Host
- User-Agent（简称UA）浏览器信息
- Content-type发送数据的格式，如application/json

##### 常见的Response Headers

- Content-type返回数据的格式，如application/json
- Content-length返回数据的大小，多少字节
- Content-Encoding返回数据的压缩算法，如gzip
- Set-Cookie



##### 自定义header

```js
// 'headers' are custom headers to be sent
headers: {'X-Requested-With' : 'XMLHttpRequest'}
```



##### 缓存相关的headers

- Cache-Control  **Expires**

- Last-Modified  **If-Modified-Since**

- Etag  **If-None-Match**





#### http缓存

##### 关于缓存

把没有必要重新再次下载的资源保存起来

- 为什么需要缓存？

- 哪些资源可以被缓存？

  - 静态资源（js css img）

    ```js
    entry: path.join(__dirname, 'src', 'index'),
    output: {
      // contenthash保证文件缓存，如果文件变了，缓存就替换了
      filename: 'bundle.[contenthash].js',
      path: path.join(__dirname, 'dist')
    }
    ```

    

##### http缓存策略

###### 强制缓存

![](D:\front-end\study\MarkDown\0基础\http\强制缓存.png)

![](D:\front-end\study\MarkDown\0基础\http\缓存过期.png)

Cahce-Control 

- 在**Response Header**中

  ![image-20210909200510334](D:\front-end\study\MarkDown\0基础\http\responseHeaders.png)

- 控制强制缓存的逻辑

- 缓存一年时间 => Cahce-Control：max-age=31536000s

  ![image-20210909200254008](D:\front-end\study\MarkDown\0基础\http\diskCache.png)



- 值
  - max-age => 设置时间
  - no-cache => 浏览器不处理，交给服务端
  - no-store =>  浏览器不处理，服务器强制返回给浏览器
  - private => 最终用户缓存
  - public => 路由代理可以缓存

- expires已经被Cahce-Control代替

  

###### 协商（对比）缓存

![](D:\front-end\study\MarkDown\0基础\http\协商缓存.png)

- 服务端缓存策略

- 服务端判断客户端资源，是否和服务端资源一样

- 一致则返回**304**，否则返回**200**和最新的资源、资源标识

- 资源标识

  - 在Response Headers中，有两种

    - Last-Modified**资源的最后修改时间**（精确到秒）

    ![](D:\front-end\study\MarkDown\0基础\http\Last-Modified.png)

    

    - Etag**资源的唯一标识**（一个字符串，类似人类的指纹，**优先使用**，资源被重复生成，而内容不变，则Etag更精准）

      ![](D:\front-end\study\MarkDown\0基础\http\Etag.png)

    - 示例

      ![image-20210909205207372](D:\front-end\study\MarkDown\0基础\http\headers示例.png)

###### 手写综述

![image-20210909205902440](D:\front-end\study\MarkDown\0基础\http\综述.png)

三种刷新操作

- 属性操作方式，对缓存的影响

  - 正操操作：地址栏输入url，跳转链接，前进后退等
    - 强制缓存有效，协商缓存有效

  - 手动刷新：F5，点击刷新按钮，右击菜单刷新
    - 强制缓存失效，协商缓存有效
  - 强制刷新：ctrl + F5
    - 强制缓存失效，协商缓存失效







## 4、关于开发环境

面试官想通过开发环境了解候选人的实际工作情况

开发环境得到工具，能体现工作产出的效率

会以聊天形式为主，不会问具体的问题



### 开发环境

#### git

最常用的代码版本管理工具

大型项目需要多人协作开发，必须熟练使用git

git服务端常见的有 github coding.net等

##### 常用git命令

git add .

git checkout xxx

git commit -m 'xxx'

git push origin master

git pull origin master

git branch

git checkout -b xxx/ git checkout xxx

git merge xxx

1、操作未切换分支新建代码错误
git stash
git status
切换新建分支
git checkout -b feature-logout
git stash pop
git add .
git commit -m 'xxx'



#### 调试工具

##### chrome调试工具

- Elements

- Console

- Source

  - debugger

    ![image-20210824214140961](D:\front-end\study\MarkDown\0基础\debugger\debugger.png)

- Network

- Application



#### 抓包（H5页）

查看网络请求，需要用工具抓包

win => fiddler

mac => charles

手机和电脑连同一个局域网

将手机代理到电脑上

手机浏览器网页，即可抓包

查看网络请求

网址代理

https



#### webpack和babel

ES6模块化，浏览器暂不支持

ES6语法，浏览器并不完全支持

压缩代码，整合代码，以让网页加载更快

##### package.json

```json
{
  "name": "webpack-demo",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack --config webpack.prod.js",
    "dev": "webpack-dev-server"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "^7.6.2",
    "@babel/preset-env": "^7.6.2",
    "babel-loader": "^8.0.6",
    "html-webpack-plugin": "^3.2.0",
    "webpack": "^4.41.0",
    "webpack-cli": "^3.3.9",
    "webpack-dev-server": "^3.8.1"
  }
}
```

##### .babelrc

```json
{
    "presets": ["@babel/preset-env"],
    "plugins": []
}
```

##### webpack.config.js

```js
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
    // mode 可选 development 或 production ，默认为后者
    // production 会默认压缩代码并进行其他优化（如 tree shaking）
    mode: 'development',
    entry: path.join(__dirname, 'src', 'index'),
    output: {
        filename: 'bundle.js',
        path: path.join(__dirname, 'dist')
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                loader: ['babel-loader'],
                include:  path.join(__dirname, 'src'),
                exclude: /node_modules/
            },
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: path.join(__dirname, 'src', 'index.html'),
            filename: 'index.html'
        })
    ],
    devServer: {
        port: 3000,
        contentBase: path.join(__dirname, 'dist'),  // 根目录
        open: true,  // 自动打开浏览器
    }
}
```



##### ES6模块化规范是什么？

```js
// export function fn() {
//     console.log('fn')
// }
// export const name = 'b'

export default function aabbcc(){
    return 'aabbcc'
}

function fn() {
    console.log('fn')
}
const name = 'b'

export {  // 注意这里不能有 default ！！！
    fn as fnfn,
    name
}
```

```js
// 导入
import aabbcc, { fnfn , name } from './fn'
fnfn()
```



##### 配置webpack生产环境

webpack.prod.js

```js
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
    mode: 'production',
    entry: path.join(__dirname, 'src', 'index'),
    output: {
        // hash值校验文件名是否变化
        filename: 'bundle.[contenthash].js',
        path: path.join(__dirname, 'dist')
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                loader: ['babel-loader'],
                include:  path.join(__dirname, 'src'),
                exclude: /node_modules/
            },
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: path.join(__dirname, 'src', 'index.html'),
            filename: 'index.html'
        })
    ]
}
```



#### linux常用命令

测试机需要和线上机器保持一致，用linux

测试机或者线上机器出了问题，本地又不能复现，需要去排查

远程登录 => ssh username@192.168.2.23

查看文件排列 => ls -la

查看列表 =>  ll

清屏 =>  clear

创建文件夹 => mkdir dirname

删除文件夹 => rm -rf dirname

目录切换 => cd dirname

修改文件 =>  mv index.html  index.php

移动文件 =>  mv index.html  ../index.html

拷贝文件 =>  cp a.js  b.js

删除文件 =>  rm b.js

新建文件 =>  touch c.js

新建并编辑文件 => vi d.js

Insert编辑

​	:wq退出并保存

查看文件内容 => cat c.js

​	head c.js

​	tail c.js

查找文件内容 => grep “babel” c.js







## 5、运行环境

运行环境即浏览器（server端有nodejs）

下载网页代码，渲染出页面，期间会执行若干JS

要保证代码再浏览器中：稳定且高效



### 网页加载过程

#### 题目

从url到渲染出页面的整个过程

window.onload和DOMContentLoaded的区别

#### 知识点

##### 加载资源的形式

- html代码

- 媒体文件，图片，视频

- javascript css

##### 加载资源的过程

- URL解析
- DNS解析：域名 => IP地址
  - DNS-prefetch缓存起来
- 浏览器根据IP地址向服务器发起http请求
- 服务器处理http请求，并返回给浏览器

##### 渲染页面的过程

- 根据HTML代码生成DOM树

- 根据CSS代码生成CSSOM

- 将DOM树和CSSOM整合形成Render Tree

- 根据Render Tree 渲染页面

- 遇到<script>则暂停渲染，优先加载并执行JS代码，完成再继续

  ```js
  document.getElementById('app').innerHTML = 'update'
  ```

  ```html
  <body>
      <div id=“app”>default</div>
      <script src="index.js"></script>
      <p>test</p>
  </body>
  ```

  

- 直至把Render tree渲染完成



为何建议把CSS放在head中？

- DOM树生成之前加载完，和CSSDOM整合形成Render Tree一次渲染完

为何建议把JS放在body最后？

- 先尽量渲染，再执行JS

媒体资源不会阻塞DOM渲染



window.onload和DOMContentLoaded

```js
window.addEventListener('load', function(){
  // 页面的全部资源加载完才会执行，包括图片、视频等
})
document.addEventListener('DOMContentLoaded', function(){
  // DOM渲染完即可执行，此时图片、视频还可能没有加载完 
})
```



示例

```html
<body>
    <p>test1</p>
    <p>test2</p>
    <p>test3</p>
    <img id="img1" src="https://tse1-mm.cn.bing.net/th/id/R-C.8c372fd892b3bd371eb3a1df8bd7fc88?rik=4KxekfOQD28FKA&riu=http%3a%2f%2fwww.desktx.com%2fd%2ffile%2fwallpaper%2fscenery%2f20170303%2fdfe53a7300794009a029131a062836d5.jpg&ehk=6ayU5y%2fwtGnzhu7g%2bJimm2REgEbHGczl9Mkbg3I1%2b5I%3d&risl=&pid=ImgRaw&r=0"/>
    <script type="text/javascript">
      const img1 = document.getElementById('img1')
      img1.onload = function(){
        console.log('img loaded')
      }
      window.addEventListener('load', function(){
  		// 页面的全部资源加载完才会执行，包括图片、视频等
        console.log('window loaded')
	  })
	  document.addEventListener('DOMContentLoaded', function(){
  		// DOM渲染完即可执行，此时图片、视频还可能没有加载完
        console.log('DOMContentLoaded loaded')
	  })
    </script>
</body>
```



### 性能（体验）优化

没有标准答案，太多案例了

#### 原则（空间换时间）

- 多使用内存、缓存或其他方法

- 减少CPU计算量，减少网络加载耗时



#### 从何入手

- 让加载更快

  - 减少资源体积：压缩代码

  - 减少访问次数：合并代码，SSR服务器端渲染，缓存

    ```html
    <script src="a.js"></script>
    <script src="b.js"></script>
    <script src="c.js"></script>
    <!-- 合并代码减少网络请求次数 -->
    <script src="abc.js"></script>
    ```

    缓存：静态资源加hash后缀，根据文件内容计算hash

    文件内容不变，则hash不变，则url不变

    url和文件不变，则会自动触发http缓存机制，返回304

    ```js
    module.exports = {
        mode: 'production',
        entry: path.join(__dirname, 'src', 'index'),
        output: {
            // hash值校验文件名是否变化
            filename: 'bundle.[contenthash].js',
            path: path.join(__dirname, 'dist')
        },
    ```

    SSR：服务器端渲染：将网页和数据一起加载，一起渲染

    非SSR（前后端分离）：先加载网页，再加载数据，再渲染数据

  - 使用更快的网络：CDN

    ![](D:\front-end\study\MarkDown\0基础\good\CDN.png)

    

- 让渲染更快

  - CSS放在head，JS放在body最下面
  - 尽早开始执行JS，用DOMContentLoaded触发
  - 懒加载和预加载（图片懒加载，上滑加载更多）
  - 对DOM查询进行缓存
  - 多次DOM操作，合并到一起插入DOM结构
  - 防抖debounce和节流throttle



#### 手写防抖

监听一个输入框的，文字变化后的触发change事件

直接用keyup事件，则会频繁触发change事件

防抖：用户输入结束后暂停时一段时间，才会触发change事件

```html
<body>
  <input type="text" id="input1"/>
  <script>
    const input1 = document.getElementById('input1')
    function debounce(fn, miliseconds = 500){
        let timer = null
        return function(){
          if(timer) clearTimeout(timer)
          timer = setTimeout(() => {
            fn()
            timer = null
          }, miliseconds)
        }
    }
    function check(){
      console.log(input1.value) 
    }
    input1.addEventListener('keyup', debounce(check))
  </script>
</body>
```



#### 手写节流

拖拽一个元素时，要随时拿到该元素被拖拽的位置

直接用drag事件，则会频繁触发，很容易导致卡顿

无论拖拽速度多快，都会每隔100ms触发一次

```html
<body>
  <div id="div1" draggable="true" style="border: 1px solid #ccc; width: 200px; height: 200px;">可以拖拽</div>
  <script>
    const div1 = document.getElementById('div1')
    function throttle(fn, miliseconds = 500){
        let timer = null
        return function(){
          if(timer) return
          timer = setTimeout(() => {
            // 接收e
            fn.apply(this, arguments)
            timer = null
          }, miliseconds)
        }
    }
    div1.addEventListener('drag', throttle(function(e){
	  console.log(e.offsetX, e.offsetY) 
	}))
  </script>
</body>
```



### 安全

常见的web前端攻击方式有哪些？

#### XSS跨站请求攻击

一个博客网站，我发表一篇博客，其中嵌入<script>脚本

脚本内容：获取cookie，发送到我的服务器（服务器配合跨域）

发布这篇博客，有人查看它，我轻松收割访问者的cookie

##### XSS预防 

```shell
npm i xss
```

替换特殊字符，如<变为&lt ;  >变为&gt ;

- `<script>`变为&lt ;script&gt ;直接显示，而不会作为脚本执行
- 前端要替换，后端也要替换

#### XSRF跨站请求伪造

你正在购物，看中了某个商品，商品id是100

付费接口是xxx.com/pay?id=100, 但没有任何验证

我是攻击者，我看中了一个商品，id是200

我向你发送一封电子邮件，邮件标题很吸引人

但邮件正文隐藏着<img src=xxx.com/pay?id=200 />

你一查看邮件，就帮我购买了id是200的商品

##### XSRF预防 

使用post接口

增加验证，例如密码、短信验证码、指纹等

